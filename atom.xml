<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shado&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shado.com.cn/"/>
  <updated>2019-06-18T08:43:33.543Z</updated>
  <id>https://www.shado.com.cn/</id>
  
  <author>
    <name>Shado Fung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程并发</title>
    <link href="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/"/>
    <id>https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/</id>
    <published>2019-05-06T12:03:19.000Z</published>
    <updated>2019-06-18T08:43:33.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java并发知识库"><a href="#Java并发知识库" class="headerlink" title="Java并发知识库"></a>Java并发知识库</h2><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/java-util-concurrent.jpg" alt="J.U.C"><br><a id="more"></a></p><h2 id="Java线程实现-创建方式"><a href="#Java线程实现-创建方式" class="headerlink" title="Java线程实现/创建方式"></a>Java线程实现/创建方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread 类本质上是实现了Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的start()实例方法。start()方法是一个native 方法，它将启动一个新线程，并执行run()方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public void run() &#123;</span><br><span class="line">    <span class="type">System</span>.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="type">MyThread</span> myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">    myThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>如果自己的类已经extends 另一个类，就无法直接extends Thread，此时，可以实现一个Runnable 接口。</p><p><strong>Runnable接口对比Callable接口</strong>：Runnable不能抛出异常，不能带返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread 实例：</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ExecutorService、Callable、Future有返回值线程"><a href="#ExecutorService、Callable、Future有返回值线程" class="headerlink" title="ExecutorService、Callable、Future有返回值线程"></a>ExecutorService、Callable<class>、Future有返回值线程</class></h3><p>有返回值的任务必须实现Callable 接口，类似的，无返回值的任务必须实现Runnable 接口。执行Callable 任务后，可以获取一个Future 的对象，在该对象上调用get 就可以获取到Callable 任务返回的Object 了，再结合线程池接口ExecutorService 就可以实现传说中有返回结果的多线程了。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.<span class="keyword">new</span> FixedThreadPool(taskSize);</span><br><span class="line"><span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line"><span class="keyword">List</span>&lt;Future&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">  Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</span><br><span class="line">  <span class="comment">// 执行任务并获取Future 对象</span></span><br><span class="line">  Future f = pool.submit(c);</span><br><span class="line">  <span class="keyword">list</span>.add(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line"><span class="keyword">for</span> (Future f : <span class="keyword">list</span>) &#123;</span><br><span class="line">  <span class="comment">// 从Future 对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">  System.out.println(<span class="string">"res："</span> + f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a>基于线程池的方式</h3><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的基本大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> corePoolSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最大数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maximumPoolSizeSize = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程活动保持时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> keepAliveTime = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue workQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池拒绝策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                corePoolSize,</span><br><span class="line">                maximumPoolSizeSize,</span><br><span class="line">                keepAliveTime,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                workQueue,</span><br><span class="line">                <span class="comment">// Google guava</span></span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build(),</span><br><span class="line">                <span class="comment">// 线程池拒绝策略</span></span><br><span class="line">                handler);</span><br><span class="line">        <span class="comment">//提交一个任务</span></span><br><span class="line">        executor.execute(() -&gt; System.<span class="keyword">out</span>.println(<span class="string">"ok"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">corePoolSize</td><td style="text-align:center">int</td><td style="text-align:center">核心线程池大小</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">maximumPoolSize</td><td style="text-align:center">int</td><td style="text-align:center">最大线程池大小</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">keepAliveTime</td><td style="text-align:center">long</td><td style="text-align:center">线程最大空闲时间</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">unit</td><td style="text-align:center">TimeUnit</td><td style="text-align:center">时间单位</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">workQueue</td><td style="text-align:center">BlockingQueue<runnable></runnable></td><td style="text-align:center">线程等待队列</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">threadFactory</td><td style="text-align:center">ThreadFactory</td><td style="text-align:center">线程创建工厂</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">handler</td><td style="text-align:center">RejectedExecutionHandler</td><td style="text-align:center">拒绝策略</td></tr></tbody></table><h2 id="4种线程池"><a href="#4种线程池" class="headerlink" title="4种线程池"></a>4种线程池</h2><p>Java 里面线程池的顶级接口是Executor，但是严格意义上讲Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/executor.jpg" alt="Executor"></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式(可能会导致OOM)来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initialDelay = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> period = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"延迟三秒"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"延迟1 秒后每三秒执行一次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。</p><h2 id="线程生命周期-状态"><a href="#线程生命周期-状态" class="headerlink" title="线程生命周期(状态)"></a>线程生命周期(状态)</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU 独自运行，所以CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-lifecycle.jpg" alt="Thread lifecycle"></p><h3 id="新建状态-new"><a href="#新建状态-new" class="headerlink" title="新建状态(new)"></a>新建状态(new)</h3><p>当程序使用new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM 为其分配内存，并初始化其成员变量的值</p><h3 id="就绪状态-runnable"><a href="#就绪状态-runnable" class="headerlink" title="就绪状态(runnable)"></a>就绪状态(runnable)</h3><p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><h3 id="运行状态-running"><a href="#运行状态-running" class="headerlink" title="运行状态(running)"></a>运行状态(running)</h3><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。</p><h3 id="阻塞状态-blocked"><a href="#阻塞状态-blocked" class="headerlink" title="阻塞状态(blocked)"></a>阻塞状态(blocked)</h3><p>阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：<br><strong>等待阻塞(o.wait-&gt;等待队列)</strong><br>运行(running)的线程执行o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。<br><strong>同步阻塞(lock-&gt;锁池)</strong><br>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM 会把该线程放入锁池(lock pool)中。<br><strong>其他阻塞(sleep/join)</strong><br>运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O 请求时，JVM 会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p><h3 id="线程死亡-dead"><a href="#线程死亡-dead" class="headerlink" title="线程死亡(dead)"></a>线程死亡(dead)</h3><p>线程会以下面三种方式结束，结束后就是死亡状态。<br><strong>正常结束</strong><br>1.run()或call()方法执行完成，线程正常结束。<br><strong>异常结束</strong><br>2.线程抛出一个未捕获的Exception 或Error。<br><strong>调用stop</strong><br>3.直接调用该线程的stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p><h2 id="终止线程的4种方式"><a href="#终止线程的4种方式" class="headerlink" title="终止线程的4种方式"></a>终止线程的4种方式</h2><h3 id="正常运行结束"><a href="#正常运行结束" class="headerlink" title="正常运行结束"></a>正常运行结束</h3><p>程序运行结束，线程自动结束。</p><h3 id="使用退出标志退出线程"><a href="#使用退出标志退出线程" class="headerlink" title="使用退出标志退出线程"></a>使用退出标志退出线程</h3><p>一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean 类型的标志，并通过设置这个标志为true 或false 来控制while循环是否退出，代码示例：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafe extends Thread &#123;</span><br><span class="line">  public volatile boolean <span class="keyword">exit</span> = false;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">exit</span>) &#123;</span><br><span class="line">      <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义了一个退出标志exit，当exit 为true 时，while 循环退出，exit 的默认值为false.在定义exit时，使用了一个Java 关键字volatile，这个关键字的目的是使exit 同步，也就是说在同一时刻只能由一个线程来修改exit 的值。</p><h3 id="Interrupt方法结束线程"><a href="#Interrupt方法结束线程" class="headerlink" title="Interrupt方法结束线程"></a>Interrupt方法结束线程</h3><p>使用interrupt()方法来中断线程有两种情况：<br><strong>1. 线程处于阻塞状态</strong><br>如使用了sleep,同步锁的wait,socket 中的receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用interrupt 方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException 异常之后通过break 来跳出循环，才能正常结束run 方法。<br><strong>2. 线程未处于阻塞状态</strong><br>使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="comment">// 非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞过程捕获中断异常来退出</span></span><br><span class="line">                <span class="type">Thread</span>.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 捕获到异常之后，执行break 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="stop方法终止线程-线程不安全）"><a href="#stop方法终止线程-线程不安全）" class="headerlink" title="stop方法终止线程(线程不安全）"></a>stop方法终止线程(线程不安全）</h3><p>程序中可以直接使用thread.stop()来强行终止线程，但是stop 方法是很危险的，就像突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop 方法来终止线程。</p><h2 id="sleep与wait区别"><a href="#sleep与wait区别" class="headerlink" title="sleep与wait区别"></a>sleep与wait区别</h2><ol><li>对于sleep()方法，我们首先要知道该方法是属于Thread 类中的。而wait()方法，则是属于<br>Object 类中的。</li><li>sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然<br>保持者，当指定的时间到了又会自动恢复运行状态。</li><li>在调用sleep()方法的过程中，线程不会释放对象锁。</li><li>而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li></ol><h2 id="start与run区别"><a href="#start与run区别" class="headerlink" title="start与run区别"></a>start与run区别</h2><ol><li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待run 方法体代码执行完毕，<br>可以直接继续执行下面的代码。</li><li>通过调用Thread 类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运<br>行，需要有可用的CPU资源才运行。</li><li>方法run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运<br>行run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后CPU 再调度其它线程。</li></ol><h2 id="Java后台线程"><a href="#Java后台线程" class="headerlink" title="Java后台线程"></a>Java后台线程</h2><ol><li>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。</li><li>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</li><li>设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的setDaemon 方法。</li><li>在Daemon 线程中产生的新线程也是Daemon 的。</li><li>线程则是JVM 级别的，以Tomcat 为例，如果你在Web 应用中启动一个线程，这个线程的生命周期并不会和Web 应用程序保持同步。也就是说，即使你停止了Web 应用，这个线程依旧是活跃的。</li><li>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</li><li>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则JVM 不会退出。  </li></ol><h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。<br>java 中的乐观锁基本都是通过CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。  </p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block 直到拿到锁。<br>java 中的悲观锁就是Synchronized,AQS 框架下的锁则是先尝试cas 乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<br>线程自旋是需要消耗cup 的，说白了就是让cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。<br><strong>自旋锁的优缺点</strong><br>自旋锁尽可能的减少线程的阻塞，这对于<code>锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升</code>，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！<br>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu 做无用功，占着XX 不XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup 的线程又不能获取到cpu，造成cpu 的浪费。所以这种情况下我们要关闭自旋锁；<br><code>自旋锁时间阀值(1.6引入量适应性自旋锁)</code><br>自旋锁的目的是为了占着CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！<br>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM 还针对当前CPU 的负荷情况做了较多的优化，如果平均负载小于CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果CPU 处于节电模式则停止自旋，自旋时间的最坏情况是CPU的存储延迟（CPU A 存储了一个数据，到CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。<br><code>自旋锁的开启</code><br>JDK1.6 中-XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数；<br>JDK1.7 后，去掉此参数，由jvm 控制；</p><h3 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a>synchronized同步锁</h3><p>synchronized 它可以把任意一个非NULL 的对象当作锁。他属于独占式的悲观锁、非公平锁，同时属于可重入锁。<br><strong>Synchronized 作用范围</strong>  </p><ol><li>作用于方法时，锁住的是当前对象的实例(this)；</li><li>当作用于静态方法时，锁住的是Class 实例，又因为Class 的相关数据存储在永久代PermGen<br>（jdk1.8 则是metaspace），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，<br>会锁所有调用该方法的线程；</li><li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，<br>当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li></ol><p><strong>Synchronized 核心组件</strong>  </p><ol><li>Wait Set：哪些调用wait 方法被阻塞的线程被放置在这里；</li><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li><li>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到Entry List 中；</li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</li><li>Owner：当前已经获取到锁资源的线程被称为Owner；</li><li>!Owner：当前释放锁的线程。  </li></ol><p><strong>Synchronized 实现</strong><br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/synchronized-principle.jpg" alt="Synchronized Principle"></p><ol><li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行CAS 访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList 中作为候选竞争线程。</li><li>Owner 线程会在unlock 时，将ContentionList 中的部分线程迁移到EntryList 中，并指定EntryList 中的某个线程为OnDeck 线程（一般是最先进去的那个线程）。</li><li>Owner 线程并不直接把锁传递给OnDeck 线程，而是把锁竞争的权利交给OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</li><li>OnDeck 线程获取到锁资源后会变为Owner 线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner 线程被wait 方法阻塞，则转移到WaitSet 队列中，直到某个时刻通过notify或者notifyAll 唤醒，会重新进去EntryList 中。</li><li>处于ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用pthread_mutex_lock 内核函数实现的）。</li><li>Synchronized 是非公平锁。 Synchronized 在线程进入ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck 线程的锁资源。</li><li>每个对象都有个monitor 对象，加锁就是在竞争monitor 对象，代码块加锁是在前后分别加上monitorenter 和monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</li><li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</li><li>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7 与1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</li><li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</li><li>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</li></ol><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentantLock 继承接口Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。<br><strong>Lock 接口的主要方法</strong>  </p><ol><li>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.  </li><li>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回true, 否则返回false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.  </li><li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.  </li><li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。  </li><li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock 方法的次数。  </li><li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动10 个线程，1 个线程获得锁，此时返回的是9  </li><li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程计数。比如10 个线程，用同一个condition 对象，并且此时这10 个线程都执行了condition 对的await 方法，那么此时执行此方法返回10  </li><li>hasWaiters(Condition condition) ： 查询是否有线程等待与此锁有关的给定条件(condition)，对于指定contidion 对象，有多少线程执行了condition.await 方法  </li><li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁  </li><li>hasQueuedThreads()：是否有线程等待此锁  </li><li>isFair()：该锁是否公平锁  </li><li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行lock 方法的前后分别是false 和true  </li><li>isLock()：此锁是否有任意线程占用  </li><li>lockInterruptibly（）：如果当前线程未被中断，获取锁  </li><li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁  </li><li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。  </li></ol><p><strong>非公平锁</strong><br>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。<br><strong>公平锁</strong><br>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。<br><strong>ReentrantLock 与 synchronized</strong>  </p><ol><li>ReentrantLock 通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized 会被JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock 必须在finally 控制块中进行解锁操作。</li><li>ReentrantLock 相比synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用ReentrantLock。</li></ol><p><strong>ReentrantLock</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// lock 加锁</span></span><br><span class="line">            <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">            <span class="comment">// 1：wait 方法等待：</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过创建Condition 对象来使线程wait，必须先执行lock.lock 方法获得锁</span></span><br><span class="line">            condition.<span class="keyword">await</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2：condition 对象的signal 方法可以唤醒wait 线程</span></span><br><span class="line">            condition.signal();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName() + (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Condition 类和 Object 类锁方法区别</strong>  </p><ol><li>Condition 类的awiat 方法和Object 类的wait 方法等效</li><li>Condition 类的signal 方法和Object 类的notify 方法等效</li><li>Condition 类的signalAll 方法和Object 类的notifyAll 方法等效</li><li>ReentrantLock 类可以唤醒指定条件的线程，而object 的唤醒是随机的</li></ol><p><strong>tryLock 和 lock 和 lockInterruptibly 的区别</strong>  </p><ol><li>tryLock 能获得锁就返回true，不能就立即返回false，tryLock(long timeout,TimeUnitunit)，可以增加时间限制，如果超过该时间段还没获得锁，返回false</li><li>lock 能获得锁就返回true，不能的话一直等待获得锁</li><li>lock 和lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而lockInterruptibly 会抛出异常。</li></ol><h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池<br><strong>实现互斥锁(计数器为1)</strong><br>我们也可以创建计数为1 的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。<br>它的用法如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个计数阈值为5 的信号量对象</span></span><br><span class="line">        <span class="comment">// 只能5 个线程同时访问</span></span><br><span class="line">        Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 申请许可</span></span><br><span class="line">            semp.acquire();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放许可</span></span><br><span class="line">                semp.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Semaphore 与 ReentrantLock</strong><br>Semaphore 基本能完成ReentrantLock 的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。<br>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire 与tryLock不同，其使用方法与ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。<br>Semaphore 的锁释放操作也由手动进行，因此与ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally 代码块中完成。</p><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首先说明， 此处AtomicInteger ， 一个提供原子操作的Integer 的类， 常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过AtomicReference<v>将一个对象的所有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized 将该操作变成一个原子操作，但JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock 的好几倍。</v></p><h3 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h3><p>本文里面讲的是广义上的可重入锁，而不是单指JAVA 下的ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA 环境下 ReentrantLock 和synchronized 都是 可重入锁。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p><strong>公平锁(Fair)</strong><br>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br><strong>非公平锁(Nonfair)</strong><br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待  </p><ol><li>非公平锁性能比公平锁高5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li><li>Java 中的synchronized 是非公平锁，ReentrantLock 默认的lock()方法采用的是非公平锁。</li></ol><h3 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h3><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm 自己控制的，你只要上好相应的锁即可。<br><strong>读锁</strong><br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁<br><strong>写锁</strong><br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>Java 中读写锁有个接口java.util.concurrent.locks.ReadWriteLock ， 也有具体的实现ReentrantReadWriteLock。  </p><h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>java 并发包提供的加锁模式分为独占锁和共享锁。<br><strong>独占锁</strong><br>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。<br><strong>共享锁</strong><br>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li>AQS 的内部类Node 定义了两个常量SHARED 和EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li><li>java 的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li></ol><h3 id="重量级锁-Mutex-Lock"><a href="#重量级锁-Mutex-Lock" class="headerlink" title="重量级锁(Mutex Lock)"></a>重量级锁(Mutex Lock)</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br><strong>锁升级</strong><br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。  </p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁也并非一种实际的锁，而是一种思想ConcurrentHashMap 是学习分段锁的最好实践</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p><strong>减少持有时间</strong><br>只用在有线程安全要求的程序上加锁<br><strong>减小粒度</strong><br>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。<br><strong>锁分离</strong><br>最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发Java 五]JDK 并发包1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据<br><strong>锁粗化</strong><br>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。<br><strong>锁消除</strong><br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p><h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p>线程相关的基本方法有wait，notify，notifyAll，sleep，join，yield 等。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-method.jpg" alt="Thread Method"></p><h3 id="线程等待-wait"><a href="#线程等待-wait" class="headerlink" title="线程等待(wait)"></a>线程等待(wait)</h3><p>调用该方法的线程进入WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。</p><h3 id="线程睡眠-sleep"><a href="#线程睡眠-sleep" class="headerlink" title="线程睡眠(sleep)"></a>线程睡眠(sleep)</h3><p>sleep 导致当前线程休眠，与wait 方法不同的是sleep 不会释放当前占有的锁,sleep(long)会导致线程进入TIMED-WATING 状态，而wait()方法会导致当前线程进入WATING 状态</p><h3 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步(yield)"></a>线程让步(yield)</h3><p>yield 会使当前线程让出CPU 执行时间片，与其他线程一起重新竞争CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p><h3 id="线程中断-interrupt"><a href="#线程中断-interrupt" class="headerlink" title="线程中断(interrupt)"></a>线程中断(interrupt)</h3><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。</p><ol><li>调用interrupt()方法并不会中断一个正在运行的线程。也就是说处于Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</li><li>若调用sleep()而使线程处于TIMED-WATING 状态，这时调用interrupt()方法，会抛出InterruptedException,从而使线程提前结束TIMED-WATING 状态。</li><li>许多声明抛出InterruptedException 的方法(如Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用isInterrupted()方法将会返回false。</li><li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread 的时候，可以调用thread.interrupt()方法，在线程的run 方法内部可以根据thread.isInterrupted()的值来优雅的终止线程。</li></ol><h3 id="join等待其他线程终止"><a href="#join等待其他线程终止" class="headerlink" title="join等待其他线程终止"></a>join等待其他线程终止</h3><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p><h3 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h3><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">Thread</span>.currentThread().getName() + <span class="string">"线程运行开始!"</span>);</span><br><span class="line"><span class="keyword">Thread</span> thread1 = <span class="literal">new</span> <span class="keyword">Thread</span>();</span><br><span class="line">thread1.setName(<span class="string">"线程B"</span>);</span><br><span class="line">thread1.<span class="keyword">join</span>();</span><br><span class="line">System.out.println(<span class="string">"这时thread1 执行完毕之后才能执行主线程"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="线程唤醒-notify"><a href="#线程唤醒-notify" class="headerlink" title="线程唤醒(notify)"></a>线程唤醒(notify)</h3><p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ol><li>sleep()：强迫一个线程睡眠Ｎ毫秒。</li><li>isAlive()： 判断一个线程是否存活。</li><li>join()： 等待线程终止。</li><li>activeCount()： 程序中活跃的线程数。</li><li>enumerate()： 枚举程序中的线程。</li><li>currentThread()： 得到当前线程。</li><li>isDaemon()： 一个线程是否为守护线程。</li><li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线<br>程依赖于主线程结束而结束)</li><li>setName()： 为线程设置一个名称。</li><li>wait()： 强迫一个线程等待。</li><li>notify()： 通知一个线程继续运行。</li><li>setPriority()： 设置一个线程的优先级。</li><li>getPriority():：获得一个线程的优先级。</li></ol><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗CPU 上执行变成了可能。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-context-switch.jpg" alt="Thread-Context-Switch"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>（有时候也称做任务）是指一个程序运行的实例。在Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。</p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>是指某一时间点 CPU 寄存器和程序计数器的内容。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p><h3 id="PCB-“切换帧”"><a href="#PCB-“切换帧”" class="headerlink" title="PCB-“切换帧”"></a>PCB-“切换帧”</h3><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到CPU 的内存中，直到他们被再次使用。</p><h3 id="上下文切换的活动"><a href="#上下文切换的活动" class="headerlink" title="上下文切换的活动"></a>上下文切换的活动</h3><ol><li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</li><li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</li><li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序<br>中。</li></ol><h3 id="引起线程上下文切换的原因"><a href="#引起线程上下文切换的原因" class="headerlink" title="引起线程上下文切换的原因"></a>引起线程上下文切换的原因</h3><ol><li>当前执行任务的时间片用完之后，系统CPU 正常调度下一个任务；</li><li>当前执行任务碰到IO 阻塞，调度器将此任务挂起，继续下一任务；</li><li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</li><li>用户代码挂起当前任务，让出CPU 时间；</li><li>硬件中断；</li></ol><h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用synchronized 关键字来取得一个对象的同步锁。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shado</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-06-03 14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method1"</span> + <span class="string">"\t lock o1"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method1"</span> + <span class="string">"\t lock o2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method2"</span> + <span class="string">"\t lock o2"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method2"</span> + <span class="string">"\t lock o1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock deadLock1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock deadLock2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line"></span><br><span class="line">        deadLock1.flag = <span class="number">1</span>;</span><br><span class="line">        deadLock2.flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(deadLock1,<span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(deadLock2, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>执行结果，程序不终止，输出内容如下:</code><br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread1method1 <span class="keyword">lock</span> o1</span><br><span class="line">thread2method2 <span class="keyword">lock</span> o2</span><br></pre></td></tr></table></figure></p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。</p><h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>每一个 Thread 的类都有一个 start 方法。 当调用start 启动线程时Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。</p><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><p>一般的线程池主要分为以下4 个组成部分：</p><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol><p>Java 中的线程池是通过Executor 框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和Future、FutureTask 这几个类。</p><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-pool.jpg" alt="Thread-Pool"></p><p>ThreadPoolExecutor的构造方法如下:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters, the default thread factory and the default rejected</span></span><br><span class="line"><span class="comment"> * execution handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125;</span></span><br><span class="line"><span class="comment"> * factory methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>corePoolSize：指定了线程池中的线程数量。</li><li>maximumPoolSize：指定了线程池中的最大线程数量。</li><li>keepAliveTime：当前线程池数量超过corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li>unit：keepAliveTime 的单位。</li><li>workQueue：任务队列，被提交但尚未被执行的任务。</li><li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li><li>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。</li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。<br>JDK 内置的拒绝策略如下：</p><ol><li>AbortPolicy ： 直接抛出异常，阻止系统正常运行。</li><li>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li><li>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</li></ol><p>以上内置拒绝策略均实现了RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展RejectedExecutionHandler 接口。</p><h3 id="Java-线程池工作过程"><a href="#Java-线程池工作过程" class="headerlink" title="Java 线程池工作过程"></a>Java 线程池工作过程</h3><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面<br>有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ol><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-pool-process.jpg" alt="Thread-Pool-Process"></p><h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：  </p><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-1.jpg" alt="BlockingQueue"></li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-2.jpg" alt="BlockingQueue"><h3 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h3><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-3.jpg" alt="BlockingQueue"></li></ol><ul><li>抛出异常：抛出一个异常；</li><li>特殊值：返回一个特殊值（null 或false,视情况而定）</li><li>则塞：在成功操作之前，一直阻塞线程</li><li>超时：放弃前只在最大的时间内阻塞</li></ul><p><strong>插入操作:</strong>  </p><ol><li>public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是NULL，则会抛出NullPointerException 异常。</li><li>public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。</li><li>public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</li><li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间<br>内，还不能往队列中加入BlockingQueue，则返回失败。</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment"> * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取数据操作:</strong>  </p><ol><li>poll(time):取走BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time 参数<br>规定的时间,取不到时返回null;</li><li>poll(long timeout, TimeUnit unit)：从BlockingQueue 取出一个队首的对象，如果在<br>指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数<br>据可取，返回失败。</li><li>take():取走BlockingQueue 里排在首位的对象,若BlockingQueue 为空,阻断进入等待状<br>态直到BlockingQueue 有新的数据被加入。</li><li>drainTo():一次性从BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个<br>数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ol><h3 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h3><ol><li>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。</li><li>DelayQueue：使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：不存储元素的阻塞队列。</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</li></ol><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-class.jpg" alt="BlockingQueue"></p><h3 id="ArrayBlockingQueue（公平、非公平）"><a href="#ArrayBlockingQueue（公平、非公平）" class="headerlink" title="ArrayBlockingQueue（公平、非公平）"></a>ArrayBlockingQueue（公平、非公平）</h3><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>(<span class="number">1000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><h3 id="LinkedBlockingQueue（两个独立锁提高并发）"><a href="#LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="LinkedBlockingQueue（两个独立锁提高并发）"></a>LinkedBlockingQueue（两个独立锁提高并发）</h3><p>基于链表的阻塞队列，同ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h3 id="PriorityBlockingQueue（compareTo-排序实现优先）"><a href="#PriorityBlockingQueue（compareTo-排序实现优先）" class="headerlink" title="PriorityBlockingQueue（compareTo 排序实现优先）"></a>PriorityBlockingQueue（compareTo 排序实现优先）</h3><p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化PriorityBlockingQueue 时，指定构造参数Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="DelayQueue（缓存失效、定时任务-）"><a href="#DelayQueue（缓存失效、定时任务-）" class="headerlink" title="DelayQueue（缓存失效、定时任务 ）"></a>DelayQueue（缓存失效、定时任务 ）</h3><p>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue 来实现。队列中的元素必须实现Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue 运用在以下应用场景：</p><ol><li>缓存系统的设计：可以用DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度： 使用DelayQueue 保存当天将会执行的任务和执行时间， 一旦从DelayQueue 中获取到任务就开始执行，从比如TimerQueue 就是使用DelayQueue 实现的。</li></ol><h3 id="SynchronousQueue（不存储数据、可用于传递数据）"><a href="#SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="SynchronousQueue（不存储数据、可用于传递数据）"></a>SynchronousQueue（不存储数据、可用于传递数据）</h3><p>是一个不存储元素的阻塞队列。每一个put 操作必须等待一个take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用， SynchronousQueue 的吞吐量高于LinkedBlockingQueue 和ArrayBlockingQueue。</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>是一个由链表结构组成的无界阻塞TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了tryTransfer 和transfer 方法。</p><ol><li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的tail 节点，并等到该元素被消费者消费了才返回。</li><li>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer 方法的区别是tryTransfer 方法无论消费者是否接收，方法立即返回。而transfer 方法是必须等到消费者消费了才返回。</li></ol><p>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列， LinkedBlockingDeque 多了addFirst ， addLast ， offerFirst ， offerLast ，peekFirst，peekLast 等方法，以First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add 等同于addLast，移除方法remove 等效于removeFirst。但是take 方法却等同于takeFirst，不知道是不是Jdk 的bug，使用时还是用带有First 和Last 后缀的方法更清楚。在初始化LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p><h2 id="CyclicBarrier、CountDownLatch、Semaphore的用法"><a href="#CyclicBarrier、CountDownLatch、Semaphore的用法" class="headerlink" title="CyclicBarrier、CountDownLatch、Semaphore的用法"></a>CyclicBarrier、CountDownLatch、Semaphore的用法</h2><h3 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h3><p>CountDownLatch 类位于java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4 个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    final CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"正在执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"正在执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"等待2 个子线程执行完毕..."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"2 个子线程已经执行完毕"</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="CyclicBarrier（回环栅栏-等待至barrier-状态再全部同时执行）"><a href="#CyclicBarrier（回环栅栏-等待至barrier-状态再全部同时执行）" class="headerlink" title="CyclicBarrier（回环栅栏-等待至barrier 状态再全部同时执行）"></a>CyclicBarrier（回环栅栏-等待至barrier 状态再全部同时执行）</h3><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier 了。<br>CyclicBarrier 中最重要的方法就是await 方法，它有2 个重载版本：</p><ol><li>public int await()：用来挂起当前线程，直至所有线程都到达barrier 状态再同时执行后续任务。</li><li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达barrier 状态就直接让到达barrier 的线程执行后续任务。<br>具体使用如下，另外CyclicBarrier 是可以重用的。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Writer</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span>(<span class="params">CyclicBarrier cyclicBarrier</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟线程写入数据操作</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">" 线程"</span> + Thread.currentThread().getName() + <span class="string">"写入数据完毕,等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.<span class="keyword">await</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"所有线程写入完毕，继续处理其他任务，比如数据操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Semaphore（信号量-控制同时访问的线程个数）"><a href="#Semaphore（信号量-控制同时访问的线程个数）" class="headerlink" title="Semaphore（信号量-控制同时访问的线程个数）"></a>Semaphore（信号量-控制同时访问的线程个数）</h3><p>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>Semaphore 类中比较重要的几个方法：</p><ol><li>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</li><li>public void acquire(int permits):获取permits 个许可</li><li>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。</li><li>public void release(int permits) { }:释放permits 个许可上面4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</li><li>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</li><li>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</li><li>public boolean tryAcquire(int permits):尝试获取permits 个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</li><li>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</li><li>还可以通过availablePermits()方法得到可用的许可数目。<br>例子：若一个工厂有5 台机器，但是有8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore 来实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工人数</span></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// 机器数目</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>CountDownLatch 和CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程A 等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而CyclicBarrier 是可以重用的。</li><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。<h2 id="volatile关键字的作用-变量可见性、禁止重排序"><a href="#volatile关键字的作用-变量可见性、禁止重排序" class="headerlink" title="volatile关键字的作用(变量可见性、禁止重排序)"></a>volatile关键字的作用(变量可见性、禁止重排序)</h2>Java 语言提供了一种稍弱的同步机制，即volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile 类型的变量时总会返回最新写入的值。<br><strong>变量可见性</strong><br>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。<br><strong>禁止重排序</strong><br>volatile 禁止了指令重排。<br><code>比 synchronized 更轻量级</code><br><code>在访问volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile 变量是一种比synchronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。</code><br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/volatile.jpg" alt="volatile"><br>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPUcache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache这一步。<br><strong>适用场景</strong><br>值得说明的是对volatile 变量的单次读/写操作可以保证原子性的，如long 和double 类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。在某些场景下可以代替Synchronized。但是,volatile 的不能完全取代Synchronized 的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<br>（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。<br>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。  <h2 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据"></a>如何在两个线程之间共享数据</h2>Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法：<br><strong>将数据抽象成一个类，并将数据的操作作为这个类的方法</strong>  </li></ul><ol><li>将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到<br>同步，只要在方法上加”synchronized“</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable <span class="keyword">add</span> = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">add</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AddRunnable(MyData <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">data</span>.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DecRunnable(MyData <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">data</span>.dec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runnable 对象作为一个类的内部类</strong>  </p><ol start="2"><li>将Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable 对象调用外部类的这些方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br><strong>ThreadLocalMap(线程的一个属性)</strong>  </p><ol><li>每个线程中都有一个自己的ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，<br>各管各的，线程可以正确的访问到自己的对象。  </li><li>将一个共用的ThreadLocal 静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态ThreadLocal 实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li><li>ThreadLocalMap 其实就是线程里面的一个属性，它在Thread 类中定义<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap <span class="attr">threadLocals</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-local.jpg" alt="Thread-Local"><br><strong>适用场景</strong><br>最常见的ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal threadSession = <span class="keyword">new</span> <span class="type">ThreadLocal</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Session getSession() throws InfrastructureException &#123;</span><br><span class="line">        Session s = (Session) threadSession.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">                s = getSessionFactory().openSession();</span><br><span class="line">                threadSession.<span class="keyword">set</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InfrastructureException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="synchronized和reentrantLock的区别"><a href="#synchronized和reentrantLock的区别" class="headerlink" title="synchronized和reentrantLock的区别"></a>synchronized和reentrantLock的区别</h2><h3 id="两者的共同点："><a href="#两者的共同点：" class="headerlink" title="两者的共同点："></a>两者的共同点：</h3><ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁，同一线程可以多次获得同一个锁</li><li>都保证了可见性和互斥性</li></ol><h3 id="两者的不同点："><a href="#两者的不同点：" class="headerlink" title="两者的不同点："></a>两者的不同点：</h3><ol><li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li><li>ReentrantLock 是API 级别的，synchronized 是JVM级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而synchronized 是Java 中的关键字，synchronized 是内置的语言实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock 在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock 时需要在finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li><li>通过Lock 可以知道有没有成功获取锁，而synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li></ol><h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h3 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><p>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是ConcurrentHashMap(高性能的HashMap)类的实现。对于HashMap 而言，最重要的两个方法是get 与set 方法，如果我们对整个HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为ConcurrentHashMap 的并发度。</p><h3 id="ConcurrentHashMap-分段锁"><a href="#ConcurrentHashMap-分段锁" class="headerlink" title="ConcurrentHashMap 分段锁"></a>ConcurrentHashMap 分段锁</h3><p>ConcurrentHashMap，它内部细分了若干个小的HashMap，称之为段(Segment)。默认情况下一个ConcurrentHashMap 被进一步细分为16 个段，既就是锁的并发度。<br>如果需要在ConcurrentHashMap 中添加一个新的表项，并不是将整个HashMap 加锁，而是首先根据hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成put 操作。在多线程环境中，如果多个线程同时进行put 操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</p><p><strong>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</strong><br>ConcurrentHashMap 是由Segment 数组结构和HashEntry 数组结构组成。Segment 是一种可重入锁ReentrantLock，在ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个ConcurrentHashMap 里包含一个Segment 数组，Segment 的结构和HashMap类似，是一种数组和链表结构， 一个Segment 里包含一个HashEntry 数组，每个HashEntry 是一个链表结构的元素， 每个Segment 守护一个HashEntry 数组里的元素,当对HashEntry 数组的数据进行修改时，必须首先获得它对应的Segment 锁。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/segment.jpg" alt="Segment"></p><h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h3 id="抢占式调度："><a href="#抢占式调度：" class="headerlink" title="抢占式调度："></a>抢占式调度：</h3><p>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p><h3 id="协同式调度："><a href="#协同式调度：" class="headerlink" title="协同式调度："></a>协同式调度：</h3><p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-scheduling.jpg" alt="Thread Scheduling"></p><h3 id="JVM-的线程调度实现（抢占式调度）"><a href="#JVM-的线程调度实现（抢占式调度）" class="headerlink" title="JVM 的线程调度实现（抢占式调度）"></a>JVM 的线程调度实现（抢占式调度）</h3><p>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p><h3 id="线程让出cpu-的情况："><a href="#线程让出cpu-的情况：" class="headerlink" title="线程让出cpu 的情况："></a>线程让出cpu 的情况：</h3><ol><li>当前运行线程主动放弃CPU，JVM 暂时放弃CPU 操作（基于时间片轮转调度的JVM 操作系<br>统不会让线程永久放弃CPU，或者说放弃本次时间片的执行权），例如调用yield()方法。</li><li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在I/O 上。</li><li>当前运行线程结束，即运行完run()方法里面的任务。</li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h3><p><strong>1. 先来先服务调度算法（FCFS）</strong><br>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。<br><strong>2. 短作业(进程)优先调度算法</strong><br>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p><h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。<br><strong>1. 非抢占式优先权算法</strong><br>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。<br><strong>2. 抢占式优先权调度算法</strong><br>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。<br><strong>3. 高响应比优先调度算法</strong><br>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-scheduling-2.jpg" alt="Thread Scheduling"><br>(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。<br>(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。<br>(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h3 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h3><p><strong>1. 时间片轮转法</strong><br>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。<br><strong>2. 多级反馈队列调度算法</strong><br>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1 个队列的时间片要比第i 个队列的时间片长一倍。<br>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n 队列后，在第n 队列便采取按时间片轮转的方式运行。<br>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i 队列中的进程运行。如果处理机正在第i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p><h2 id="什么是CAS-乐观锁-自旋锁-比较并交换-compare-and-swap"><a href="#什么是CAS-乐观锁-自旋锁-比较并交换-compare-and-swap" class="headerlink" title="什么是CAS(乐观锁-自旋锁-比较并交换 compare and swap)"></a>什么是CAS(乐观锁-自旋锁-比较并交换 compare and swap)</h2><h3 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h3><p>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当V 值等于E 值时，才会将V 的值设为N，如果V 值和E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前V 的真实值。<br>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><h3 id="原子包-java-util-concurrent-atomic（锁自旋）"><a href="#原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="原子包 java.util.concurrent.atomic（锁自旋）"></a>原子包 java.util.concurrent.atomic（锁自旋）</h3><p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般CPU 切换时间比CPU 指令集操作更加长， 所以J.U.C 在性能上有了很大的提升。如下代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getAndIncrement 采用了CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行CAS 操作，如果成功就返回结果，否则重试直到成功为止。而compareAndSet 利用JNI 来完成CPU 指令的操作。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmpxchg</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * accumulator = AL,AX,or EAX,depending on whether</span></span><br><span class="line"><span class="comment"> * a byte,word,or doubleword comparison is being performed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> // 更新的变量和旧的预期值是否相等</span><br><span class="line"> <span class="keyword">if</span>(<span class="attr">accumulator</span> == Destination) &#123;</span><br><span class="line">   // 设置跳转标识</span><br><span class="line">   <span class="attr">ZF</span> = <span class="number">1</span>;</span><br><span class="line">   <span class="attr">Destination</span> = Source;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   // 不设置值类</span><br><span class="line">   <span class="attr">ZF</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="attr">accumulator</span> = Destination;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。<br>比如说一个线程one 从内存位置V 中取出A，这时候另一个线程two 也从内存中取出A，并且two 进行了一些操作变成了B，然后two 又将V 位置的数据变成A，这时候线程one 进行CAS 操作发现内存中仍然是A，然后one 操作成功。尽管线程one 的CAS 操作成功，但是不代表这个过程就是没有问题的。<br>部分乐观锁的实现是通过版本号（version）的方式来解决ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA 问题，因为版本号只会增加不会减少。</p><h2 id="什么是AQS-抽象的队列同步器AbstractQueuedSynchronizer"><a href="#什么是AQS-抽象的队列同步器AbstractQueuedSynchronizer" class="headerlink" title="什么是AQS(抽象的队列同步器AbstractQueuedSynchronizer)"></a>什么是AQS(抽象的队列同步器AbstractQueuedSynchronizer)</h2><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/abstract-queued-synchronizer.jpg" alt="AbstractQueuedSynchronizer"><br>它维护了一个volatile int state（代表共享资源）和一个FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile 是核心关键词，具体volatile 的语义，在此不述。state 的访问方式有三种:</p><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><h3 id="AQS-定义两种资源共享方式"><a href="#AQS-定义两种资源共享方式" class="headerlink" title="AQS 定义两种资源共享方式"></a>AQS 定义两种资源共享方式</h3><p><strong>Exclusive 独占资源-ReentrantLock</strong><br>Exclusive（独占，只有一个线程能执行，如ReentrantLock）<br><strong>Share 共享资源-Semaphore/CountDownLatch</strong><br>Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。<br>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state 的get/set/CAS)之所以没有定义成abstract ， 是因为独占模式下只用实现tryAcquire-tryRelease ， 而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition 才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余<br>可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<br>true，否则返回false。</li></ol><p><code>同步器的实现是ABS核心(state资源状态计数)</code><br>同步器的实现是ABS 核心，以ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A 线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state 是能回到零态的。<br>以CountDownLatch 以例，任务分为N 个子线程去执行，state 也初始化为N（注意N 要与线程个数一致）。这N 个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS 减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p><code>ReentrantReadWriteLock 实现独占和共享两种方式</code><br>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但AQS 也支持自定义同步器,同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java并发知识库&quot;&gt;&lt;a href=&quot;#Java并发知识库&quot; class=&quot;headerlink&quot; title=&quot;Java并发知识库&quot;&gt;&lt;/a&gt;Java并发知识库&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/05/06/2019-05-06-concurrency-and-multithreading/java-util-concurrent.jpg&quot; alt=&quot;J.U.C&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://www.shado.com.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="多线程" scheme="https://www.shado.com.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://www.shado.com.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件MQ总结</title>
    <link href="https://www.shado.com.cn/2019/04/16/2019-04-16-message-queue/"/>
    <id>https://www.shado.com.cn/2019/04/16/2019-04-16-message-queue/</id>
    <published>2019-04-16T13:32:19.000Z</published>
    <updated>2019-06-18T08:20:12.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>消息队列提供 <code>异步</code> 通信协议，这意味着消息的发送方和接收方不需要同时与消息队列交互。放置在队列中的消息将被存储，直到收件人检索它们。消息队列对可以在单个消息中传输的数据大小以及可能在队列中保持未完成的消息数具有隐式或显式限制。<br><a id="more"></a></p><h3 id="为什么在项目中使用MQ"><a href="#为什么在项目中使用MQ" class="headerlink" title="为什么在项目中使用MQ"></a>为什么在项目中使用MQ</h3><h4 id="使用MQ的优点"><a href="#使用MQ的优点" class="headerlink" title="使用MQ的优点"></a>使用MQ的优点</h4><h5 id="解藕"><a href="#解藕" class="headerlink" title="解藕"></a>解藕</h5><p>现场画个图来说明一下，A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？头发都白了啊。。。</p><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>现场画个图来说明一下，A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，太慢了。</p><h5 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h5><p>每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会崩溃。。。</p><h4 id="使用MQ的缺点"><a href="#使用MQ的缺点" class="headerlink" title="使用MQ的缺点"></a>使用MQ的缺点</h4><h5 id="系统可用性降低："><a href="#系统可用性降低：" class="headerlink" title="系统可用性降低："></a>系统可用性降低：</h5><p>MQ故障，生产者无法生产消息，消费者无法消费消息</p><h5 id="系统复杂性变高"><a href="#系统复杂性变高" class="headerlink" title="系统复杂性变高"></a>系统复杂性变高</h5><p>消息丢失，消息重复，消息乱序，消息积压，消息一致性等问题</p><h3 id="如何保证消息队列的高可用"><a href="#如何保证消息队列的高可用" class="headerlink" title="如何保证消息队列的高可用"></a>如何保证消息队列的高可用</h3><h4 id="RabbitMQ的高可用性"><a href="#RabbitMQ的高可用性" class="headerlink" title="RabbitMQ的高可用性"></a>RabbitMQ的高可用性</h4><p>RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式  </p><h5 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h5><p>单机模式，几乎没有高可用性，一旦故障就不可用</p><h5 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h5><p>多台机器上启动多个rabbitmq实例，每个机器启动一个。但是创建的queue，只会放在某一个rabbtimq实例上。消费数据的时候，如果连接到了不是存放queue的那个实例，那么连接的实例会从queue所在实例上拉取数据过来。</p><p>如果存放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。</p><p>这方案主要是提高吞吐量的，基本没有高可用性。</p><h5 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h5><p>这种模式，才是rabbitmq的高可用模式。</p><p>跟普通集群模式不一样的是，创建的queue，无论元数据还是queue里的消息都会同步保存到多个实例上，然后每次写消息到queue的时候，都会自动把消息同步到多个实例的queue里。</p><p>好处在于，任何一个机器宕机了，别的机器都可以用，不会导致MQ系统直接故障。</p><p>坏处在于，第一，性能开销大，消息同步所有机器，导致网络带宽压力、内存压力大。第二，扩展性低，如果某个queue负载很重，要减轻这个queue的负载，新增机器，但是新增的机器也同步这个queue的所以数据，并没有减轻这个queue的负载。</p><h4 id="Kafka的高可用性"><a href="#Kafka的高可用性" class="headerlink" title="Kafka的高可用性"></a>Kafka的高可用性</h4><p>kafka一个最基本的架构认识：多个broker组成，每个broker是一个节点；创建一个topic，这个topic可以划分为多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。</p><p>replica副本机制。每个partition的数据都会同步其他机器上，形成自己的多个replica副本。然后所有replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上数据即可。只能读写leader？很简单，要是可以随意读写每个follower，那么就要care数据一致性的问题，系统复杂度太高，很容易出问题。kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才可以提高容错性。</p><p>这么搞，就有所谓的高可用性了，因为如果某个broker宕机了，没事儿，那个broker上面的partition在其他机器上都有副本的，如果这上面有某个partition的leader，那么此时会重新选举一个新的leader出来，大家继续读写那个新的leader即可。这就有所谓的高可用性了。</p><p>写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据。一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p>消费的时候，只会从leader去读，但是只有一个消息已经被所有follower都同步成功返回ack的时候，这个消息才会被消费者读到。</p><h3 id="如何保证消息不被重复消费（消息幂等性）"><a href="#如何保证消息不被重复消费（消息幂等性）" class="headerlink" title="如何保证消息不被重复消费（消息幂等性）"></a>如何保证消息不被重复消费（消息幂等性）</h3><p>rabbitmq、rocketmq、kafka，都有可能会出现消费重复消费的问题。</p><p>（1）比如拿个数据要写库，先根据主键查一下，如果这数据都有了，就别插入了，update一下</p><p>（2）比如是写redis，那没问题了，反正每次都是set，天然幂等性</p><p>（3）比如不是上面两个场景，那做的稍微复杂一点，需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，就处理，然后这个id写redis。如果消费过了，那就别处理了，保证别重复处理相同的消息即可。</p><p>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据</p><p>如何保证MQ的消费是幂等性的，需要结合具体的业务来看</p><h3 id="如何保证消息的可靠性传输（如何处理消息丢失的问题）"><a href="#如何保证消息的可靠性传输（如何处理消息丢失的问题）" class="headerlink" title="如何保证消息的可靠性传输（如何处理消息丢失的问题）"></a>如何保证消息的可靠性传输（如何处理消息丢失的问题）</h3><h4 id="RabbitMQ解决消息丢失问题"><a href="#RabbitMQ解决消息丢失问题" class="headerlink" title="RabbitMQ解决消息丢失问题"></a>RabbitMQ解决消息丢失问题</h4><h5 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h5><p>生产者将数据发送到rabbitmq的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。</p><h6 id="使用rabbitmq的事务机制"><a href="#使用rabbitmq的事务机制" class="headerlink" title="使用rabbitmq的事务机制"></a>使用rabbitmq的事务机制</h6><p>用rabbitmq提供的事务功能，就是生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，rabbitmq事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p><h6 id="使用rabbitmq的confirm机制"><a href="#使用rabbitmq的confirm机制" class="headerlink" title="使用rabbitmq的confirm机制"></a>使用rabbitmq的confirm机制</h6><p>在生产者那里设置开启confirm模式之后，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会回传一个ack消息，告诉你这个消息ok了。如果rabbitmq没能处理这个消息，会回调一个nack接口，告诉你这个消息接收失败，你可以重试。而且可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么可以重发。</p><p>事务机制和cnofirm机制最大的不同在于，事务机制是同步的，提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调一个接口通知你这个消息接收到了。</p><p>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p><h5 id="RabbitMQ弄丢了数据"><a href="#RabbitMQ弄丢了数据" class="headerlink" title="RabbitMQ弄丢了数据"></a>RabbitMQ弄丢了数据</h5><p>rabbitmq自己弄丢了数据，这个必须开启rabbitmq的持久化，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p><p>设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p><p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，也是可以自己重发的。</p><p>哪怕是给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。</p><h5 id="消费者弄丢了数据"><a href="#消费者弄丢了数据" class="headerlink" title="消费者弄丢了数据"></a>消费者弄丢了数据</h5><p>rabbitmq如果丢失了数据，主要是因为消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，rabbitmq认为你都消费了，这数据就丢了。</p><p>这个时候得用rabbitmq提供的ack机制，简单来说，就是关闭rabbitmq自动ack，可以通过一个api来调用就行，然后每次自己代码里确保处理完的时候，再程序里ack一把。这样的话，如果还没处理完，不就没有ack？那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的。</p><h4 id="Kafka解决消息丢失问题"><a href="#Kafka解决消息丢失问题" class="headerlink" title="Kafka解决消息丢失问题"></a>Kafka解决消息丢失问题</h4><h5 id="Kafka消费者弄丢了数据"><a href="#Kafka消费者弄丢了数据" class="headerlink" title="Kafka消费者弄丢了数据"></a>Kafka消费者弄丢了数据</h5><p>唯一可能导致消费者弄丢数据的情况，就是说，你那个消费到了这个消息，然后消费者那边自动提交了offset，让kafka以为你已经消费好了这个消息，其实刚准备处理这个消息，还没处理，自己就挂了，此时这条消息就丢咯。</p><p>这不是一样么，大家都知道kafka会自动提交offset，那么只要关闭自动提交offset，在处理完之后自己手动提交offset，就可以保证数据不会丢。但是此时确实还是会重复消费，比如刚处理完，还没提交offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><h5 id="Kafka弄丢了数据"><a href="#Kafka弄丢了数据" class="headerlink" title="Kafka弄丢了数据"></a>Kafka弄丢了数据</h5><p>这块比较常见的一个场景，就是kafka某个broker宕机，然后重新选举partiton的leader时。大家想想，要是此时其他的follower刚好还有些数据没有同步，结果此时leader挂了，然后选举某个follower成leader之后，他不就少了一些数据？这就丢了一些数据啊。</p><p>生产环境也遇到过，我们也是，之前kafka的leader机器宕机了，将follower切换为leader之后，就会发现说这个数据就丢了</p><p>所以此时一般是要求起码设置如下4个参数：</p><p>给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition必须有至少2个副本</p><p>在kafka服务端设置min.insync.replicas参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系，没掉队，这样才能确保leader挂了还有一个follower吧</p><p>在producer端设置acks=all：这个是要求每条数据，必须是写入所有replica之后，才能认为是写成功了</p><p>在producer端设置retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了</p><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在kafka broker端就可以保证在leader所在broker发生故障，进行leader切换时，数据不会丢失</p><h5 id="生产者会不会弄丢数据"><a href="#生产者会不会弄丢数据" class="headerlink" title="生产者会不会弄丢数据"></a>生产者会不会弄丢数据</h5><p>如果按照上述的思路设置了ack=all，一定不会丢，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h3 id="如何保证消息的顺序"><a href="#如何保证消息的顺序" class="headerlink" title="如何保证消息的顺序"></a>如何保证消息的顺序</h3><h4 id="RabbitMQ消息乱序场景"><a href="#RabbitMQ消息乱序场景" class="headerlink" title="RabbitMQ消息乱序场景"></a>RabbitMQ消息乱序场景</h4><p>一个queue，多个consumer，比如依次发送3条消息到queue，分配到不同消费者处理，消费者处理的速度各异，很可能导致消息的顺序错乱。</p><h5 id="RabbitMQ解决方案"><a href="#RabbitMQ解决方案" class="headerlink" title="RabbitMQ解决方案"></a>RabbitMQ解决方案</h5><p>拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理</p><h4 id="Kafka消息乱序场景"><a href="#Kafka消息乱序场景" class="headerlink" title="Kafka消息乱序场景"></a>Kafka消息乱序场景</h4><p>一个topic，一个partition，一个consumer，内部多线程，这不也明显乱了</p><h5 id="Kafka解决方案"><a href="#Kafka解决方案" class="headerlink" title="Kafka解决方案"></a>Kafka解决方案</h5><p>一个topic，一个partition，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个内存queue即可</p><h3 id="消息队列的消息积压、队列快满了、消息快过期的解决方案"><a href="#消息队列的消息积压、队列快满了、消息快过期的解决方案" class="headerlink" title="消息队列的消息积压、队列快满了、消息快过期的解决方案"></a>消息队列的消息积压、队列快满了、消息快过期的解决方案</h3><h4 id="临时扩容消费者"><a href="#临时扩容消费者" class="headerlink" title="临时扩容消费者"></a>临时扩容消费者</h4><p>1）先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉<br>2）新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量<br>3）然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue<br>4）接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据<br>5）这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据<br>6）等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p><h4 id="消息快速消费"><a href="#消息快速消费" class="headerlink" title="消息快速消费"></a>消息快速消费</h4><p>修改消费者的操作，对消息先不做处理，快速消费掉所有的消息，等过了高峰期以后，再重新将消费者修改成原来的逻辑操作，补回之前没有处理的消息。</p><h3 id="ActiveMQ、RabbitMQ、Kafka、RocketMQ有什么区别"><a href="#ActiveMQ、RabbitMQ、Kafka、RocketMQ有什么区别" class="headerlink" title="ActiveMQ、RabbitMQ、Kafka、RocketMQ有什么区别"></a>ActiveMQ、RabbitMQ、Kafka、RocketMQ有什么区别</h3><table><thead><tr><th>特性</th><th style="text-align:right">ActiveMQ</th><th style="text-align:center">RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td style="text-align:right">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td style="text-align:center">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td>10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>时效性</td><td style="text-align:right">毫秒级</td><td style="text-align:center">微秒级，这是rabbitmq的一大特点，延迟是最低的</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>topic数量对吞吐量的影响</td><td style="text-align:right">ActiveMQ</td><td style="text-align:center">RabbitMQ</td><td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降，这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td><td>topic从几十个到几百个的时候，吞吐量会大幅度下降，所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td></tr><tr><td>可用性</td><td style="text-align:right">高，基于主从架构实现高可用性</td><td style="text-align:center">高，基于主从架构实现高可用性</td><td>非常高，分布式架构</td><td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td style="text-align:right">有较低的概率丢失数据</td><td style="text-align:center">RabbitMQ</td><td>经过参数优化配置，可以做到0丢失</td><td>经过参数优化配置，消息可以做到0丢失</td></tr><tr><td>功能支持</td><td style="text-align:right">MQ领域的功能极其完备</td><td style="text-align:center">基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td>优劣势总结</td><td style="text-align:right">非常成熟，功能强大。偶尔会有较低概率丢失消息。主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用。现在社区以及国内应用都越来越少，官方社区对ActiveMQ维护越来越少。</td><td style="text-align:center">erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备，开源提供的管理界面很方便监测，社区相对比较活跃，在国内互联网公司近几年用RabbitMQ也比较多。但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，因为实现机制比较重。而且erlang开发，源码级别的研究和定制比较困难，基本只能依赖于开源社区的快速维护和修复bug，并且RabbitMQ集群动态扩展会很麻烦。</td><td>日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。阿里出品、java实现，我们可以自己阅读源码，定制自己公司的MQ，可以掌控。社区活跃度一般，文档相对来说简单一些，接口这块不是按照标准JMS规范有些系统要迁移需要修改大量代码。</td><td>kafka的特点很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略。这个特性天然适合大数据实时计算以及日志收集</td></tr></tbody></table><p>综上所述，得出以下结论：</p><p>一般的业务系统要引入MQ，最早的公司都用ActiveMQ，但是现在确实用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以渐渐被抛弃。</p><p>后来开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，但是是开源的，比较稳定的支持，活跃度也高，图形化界面易于维护；</p><p>现在确实越来越多的公司，会去用RocketMQ，确实很不错，还支持MQ事务，大型项目首选。</p><p>所以中小型公司项目，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择。</p><p>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，何况几乎是全世界大数据领域的事实性规范</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;消息队列提供 &lt;code&gt;异步&lt;/code&gt; 通信协议，这意味着消息的发送方和接收方不需要同时与消息队列交互。放置在队列中的消息将被存储，直到收件人检索它们。消息队列对可以在单个消息中传输的数据大小以及可能在队列中保持未完成的消息数具有隐式或显式限制。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.shado.com.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="https://www.shado.com.cn/2019/03/02/2019-03-02-arraylist-source/"/>
    <id>https://www.shado.com.cn/2019/03/02/2019-03-02-arraylist-source/</id>
    <published>2019-03-02T12:21:32.000Z</published>
    <updated>2019-06-18T08:44:13.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ArrayList</code>是可调整大小的数组,线程不安全。实现了<code>List</code>,<code>RandomAccess</code>,<code>Cloneable</code>,<code>Serializable</code>接口,可插入空数据。<br><a id="more"></a><br><code>size</code>, <code>isEmpty</code>, <code>get</code>, <code>set</code>, <code>iterator</code>,<code>listIterator</code>操作可以在常数时间(O(1))内完成, <code>add</code>元素操作是<em>amortized constant time</em>, <code>add</code> n个元素需要花费O(n)时间。所有操作都是线性时间关系（粗略地说）。与<code>LinkedList</code>实现相比，常数因子较低。</p><p>每个<code>ArrayList</code>实例都有一个容量<em>capacity</em>，容量是用于存储列表中元素的数组的大小，它始终至少与列表大小一样大。当元素添加到<code>ArrayList</code>时，其容量会自动扩容。扩容的具体策略不是特定的，添加一个元素花费<em>constant amortized constant time</em>。</p><p>程序在添加大量元素之前，应该进行<code>ensureCapacity(int minCapacity)</code>操作，可以增加<code>ArrayList</code>实例的容量<em>capacity</em>，这可能会减少增量重新分配的次数。</p><p>值得注意的是<code>ArrayList</code>的实现不是同步的。如果多线程并发操作一个<code>ArrayList</code>，并且至少有一个线程修改了<code>ArrayList</code>的结构，必须在操作外部实现同步。（结构修改是添加或删除一个或多个元素或显式调整后备数组大小的任何操作;仅设置元素的值不是结构修改。）通常可以通过对包裹list的对象进行同步，或者可以使用<code>Collections.synchronizedList</code>方法来对list同步，如<code>List list = Collections.synchronizedList(new ArrayList(...));</code></p><p>迭代器<code>iterator</code>具有<em>fail-fast</em>(快速失败)机制：如果list的结构在<code>iterator</code>创建后的任意时刻发生改变，除了通过<code>iterator</code>实现的方法<code>remove()</code>或<code>add()</code>操作的，<code>iterator</code>都会抛出<code>ConcurrentModificationException</code>。因此，在并发修改的情况下，迭代器快速而干净地失败，而不是在未来的未确定时间冒着任意的、非确定性行为的风险。请注意，迭代器的快速失败行为无法得到保证，因为一般来说，在存在不同步的并发修改时，不可能做出任何硬性保证。 <em>fail-fast</em> <code>iterator</code>会尽最大努力抛出<code>ConcurrentModificationException</code>。因此，程序不能依靠<code>iterator</code>的 <em>fail-fast</em> 抛出异常来确保正确性，<code>iterator</code> 的 <em>fail-fast</em> 行为应该用来检测bug。</p><p><code>ArrayList</code>底层数据结构是数组，主要的两个属性是<code>elementData</code>数组和<code>size</code>集合大小。</p><h1 id="add-E-e-在ArrayList末尾添加元素"><a href="#add-E-e-在ArrayList末尾添加元素" class="headerlink" title="add(E e)在ArrayList末尾添加元素"></a>add(E e)在ArrayList末尾添加元素</h1><p><code>add(E e)</code>方法的操作步骤:</p><ol><li><code>modCount++</code> 修改次数自增</li><li>进行扩容校验，如果<code>size</code>等于数组长度，会进行数组复制，使得数组<code>size</code>+1，前<code>size</code>个元素数据不变</li><li>将值放到尾部</li><li>size+1</li></ol><p>下面是源码实现：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="built_in">add</span>(E e) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="built_in">add</span>(e, elementData, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">add</span>(E e, <span class="keyword">Object</span>[] elementData, <span class="built_in">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">            elementData = grow();</span><br><span class="line">        elementData[s] = e;</span><br><span class="line">        <span class="built_in">size</span> = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span>[] grow() &#123;</span><br><span class="line">        <span class="keyword">return</span> grow(<span class="built_in">size</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">Object</span>[] grow(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,</span><br><span class="line">                                           newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a capacity at least as large as the given minimum capacity.</span></span><br><span class="line"><span class="comment"> * Returns the current capacity increased by 50% if that suffices.</span></span><br><span class="line"><span class="comment"> * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span></span><br><span class="line"><span class="comment"> * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> * @throws OutOfMemoryError if minCapacity is less than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> newCapacity(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="built_in">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="built_in">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> hugeCapacity(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="add-int-index-E-element-在指定位置添加元素"><a href="#add-int-index-E-element-在指定位置添加元素" class="headerlink" title="add(int index, E element)在指定位置添加元素"></a>add(int index, E element)在指定位置添加元素</h1><p><code>add(int index, E element)</code>在指定位置添加元素的步骤:</p><ol><li>对index的界限判断</li><li><code>modCount++</code>  修改次数自增</li><li>进行扩容校验，如果<code>size</code>等于数组长度，会进行数组复制，使得数组<code>size</code>+1</li><li>数组复制，将 index 后面的数据都向后移动一个位置，目的是把 index 位置空出来插入的数据</li><li>将数据插入到 index 位置</li></ol><p>下面是源码实现：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">        Object[] elementData;</span><br><span class="line">        <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">            elementData = grow();</span><br><span class="line">        System.arraycopy(elementData, index,</span><br><span class="line">                         elementData, index + <span class="number">1</span>,</span><br><span class="line">                         s - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">grow</span><span class="params">(size + <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a capacity at least as large as the given minimum capacity.</span></span><br><span class="line"><span class="comment"> * Returns the current capacity increased by 50% if that suffices.</span></span><br><span class="line"><span class="comment"> * Will not return a capacity greater than MAX_ARRAY_SIZE unless</span></span><br><span class="line"><span class="comment"> * the given minimum capacity is greater than MAX_ARRAY_SIZE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError if minCapacity is less than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="function"><span class="keyword">return</span> Math.<span class="title">max</span><span class="params">(DEFAULT_CAPACITY, minCapacity)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过两个增加元素方法源码可以看出<code>ArrayList</code>在数组扩容和数组移位的操作消耗较大，在创建<code>ArrayList</code>时最好通过<code>new ArrayList(int initialCapacity)</code>定义初始化容量，减少数组扩容的性能消耗。</p><h1 id="get-int-index-获取指定位置的元素"><a href="#get-int-index-获取指定位置的元素" class="headerlink" title="get(int index)获取指定位置的元素"></a>get(int index)获取指定位置的元素</h1><p>get(int index)获取指定位置的元素的操作步骤：</p><ol><li>index的合法性校验</li><li>返回指定位置的数组元素</li></ol><p>下面是源码实现：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  index index of the element to return</span></span><br><span class="line"><span class="comment"> * @return the element at the specified position in this list</span></span><br><span class="line"><span class="comment"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E get(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    Objects.checkIndex(<span class="keyword">index</span>, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="keyword">index</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> checkIndex(<span class="keyword">int</span> <span class="keyword">index</span>, <span class="keyword">int</span> length) &#123;</span><br><span class="line">    <span class="keyword">return</span> Preconditions.checkIndex(<span class="keyword">index</span>, length, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;X extends RuntimeException&gt;</span><br><span class="line"><span class="keyword">int</span> checkIndex(<span class="keyword">int</span> <span class="keyword">index</span>, <span class="keyword">int</span> length,</span><br><span class="line">               BiFunction&lt;String, List&lt;Integer&gt;, X&gt; oobef) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &lt; <span class="number">0</span> || <span class="keyword">index</span> &gt;= length)</span><br><span class="line">        <span class="keyword">throw</span> outOfBoundsCheckIndex(oobef, <span class="keyword">index</span>, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">index</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E elementData(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[<span class="keyword">index</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="remove-int-index-删除元素"><a href="#remove-int-index-删除元素" class="headerlink" title="remove(int index)删除元素"></a>remove(int index)删除元素</h1><ol><li>检查 index 合法性</li><li>将数组<code>size</code> - 1，判断 index 的位置，在数组中间则数组移位复制，在数组末尾则将<code>elementData[index] = null</code></li></ol><p>下面是源码实现：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E remove(<span class="built_in">int</span> index) &#123;</span><br><span class="line">    Objects.checkIndex(index, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Object</span>[] es = elementData;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>) E oldValue = (E) es[index];</span><br><span class="line">    fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment"> * return the value removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> fastRemove(<span class="keyword">Object</span>[] es, <span class="built_in">int</span> i) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = <span class="built_in">size</span> - <span class="number">1</span>) &gt; i)</span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    es[<span class="built_in">size</span> = newSize] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="remove-Object-o-删除元素"><a href="#remove-Object-o-删除元素" class="headerlink" title="remove(Object o)删除元素"></a>remove(Object o)删除元素</h1><ol><li>判断 o 是否为空，为空则遍历数组查找元素为空的位置</li><li>o 不为空，遍历数组，用o.equals(es[i])判断是否相等</li><li>找到第一个相等的元素，调用<code>fastRemove(es, i)</code>删除</li><li>没有找到相等的元素则不做改变</li></ol><p>下面是源码实现：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes <span class="keyword">the</span> <span class="keyword">first</span> occurrence <span class="keyword">of</span> <span class="keyword">the</span> specified element <span class="keyword">from</span> this <span class="built_in">list</span>,</span><br><span class="line"> * <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> present.  If <span class="keyword">the</span> <span class="built_in">list</span> <span class="keyword">does not contain</span> <span class="keyword">the</span> element, <span class="keyword">it</span> <span class="keyword">is</span></span><br><span class="line"> * unchanged.  More formally, removes <span class="keyword">the</span> element <span class="keyword">with</span> <span class="keyword">the</span> lowest index</span><br><span class="line"> * &#123;@code i&#125; such <span class="keyword">that</span></span><br><span class="line"> * &#123;@code Objects.<span class="keyword">equals</span>(o, <span class="keyword">get</span>(i))&#125;</span><br><span class="line"> * (<span class="keyword">if</span> such an element exists).  Returns &#123;@code <span class="literal">true</span>&#125; <span class="keyword">if</span> this <span class="built_in">list</span></span><br><span class="line"> * contained <span class="keyword">the</span> specified element (<span class="keyword">or</span> equivalently, <span class="keyword">if</span> this <span class="built_in">list</span></span><br><span class="line"> * changed <span class="keyword">as</span> a <span class="literal">result</span> <span class="keyword">of</span> <span class="keyword">the</span> call).</span><br><span class="line"> *</span><br><span class="line"> * @param o element <span class="keyword">to</span> be removed <span class="keyword">from</span> this <span class="built_in">list</span>, <span class="keyword">if</span> present</span><br><span class="line"> * @<span class="literal">return</span> &#123;@code <span class="literal">true</span>&#125; <span class="keyword">if</span> this <span class="built_in">list</span> contained <span class="keyword">the</span> specified element</span><br><span class="line"> */</span><br><span class="line">public <span class="built_in">boolean</span> remove(Object o) &#123;</span><br><span class="line">    final Object[] es = elementData;</span><br><span class="line">    final int size = this.size;</span><br><span class="line">    int i = <span class="number">0</span>;</span><br><span class="line">    found: &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == null) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (es[i] == null)</span><br><span class="line">                    break found;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.<span class="keyword">equals</span>(es[i]))</span><br><span class="line">                    break found;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">        return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fastRemove(es, i);</span><br><span class="line"><span class="built_in">    return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Vector与ArrayList类似，也是实现List，底层数据结构也是动态数组。不同的是Vector线程安全的。在<code>add()</code>方法和<code>remove()</code>方法加了 <code>synchronized</code> 进行同步操作，但是加锁使得<code>Vector</code>性能较低，Vector 是一个同步容器并不是一个并发容器。</p><h1 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h1><p>下面是源码实现：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">synchronized </span><span class="keyword">boolean </span><span class="keyword">add(E </span>e) &#123;</span><br><span class="line">    modCount++<span class="comment">;</span></span><br><span class="line">    <span class="keyword">add(e, </span>elementData, elementCount)<span class="comment">;</span></span><br><span class="line">    return true<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h1><p>下面是源码实现：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> synchronized E remove(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="keyword">index</span>);</span><br><span class="line">    E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt;是可调整大小的数组,线程不安全。实现了&lt;code&gt;List&lt;/code&gt;,&lt;code&gt;RandomAccess&lt;/code&gt;,&lt;code&gt;Cloneable&lt;/code&gt;,&lt;code&gt;Serializable&lt;/code&gt;接口,可插入空数据。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.shado.com.cn/categories/java/"/>
    
    
      <category term="源码" scheme="https://www.shado.com.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="集合" scheme="https://www.shado.com.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置</title>
    <link href="https://www.shado.com.cn/2019/01/21/2019-01-21-nginx/"/>
    <id>https://www.shado.com.cn/2019/01/21/2019-01-21-nginx/</id>
    <published>2019-01-21T11:13:54.000Z</published>
    <updated>2019-06-19T02:13:43.398Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。</p><p>在高连接并发的情况下，Nginx是Apache服务器不错的替代品。<br><a id="more"></a></p><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><p>参考：<strong><a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">菜鸟教程Nginx安装</a></strong></p><p>安装完成之后将Nginx目录添加到环境变量中</p><p>执行命令，编辑系统的环境变量<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@root</span> nginx]<span class="meta"># vim /etc/profile</span></span><br></pre></td></tr></table></figure></p><p>在文件末尾追加nginx的目录<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nginx</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">NGINX_HOME</span>=/usr/local/webserver/nginx</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$NGINX_HOME/sbin</span><br></pre></td></tr></table></figure></p><p>刷新系统环境变量，令之前的修改立即生效<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@root <span class="keyword">conf</span>]# <span class="keyword">source</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure></p><p>查看nginx版本，输入如下命令显示出nginx版本即安装成功<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@root nginx]<span class="comment"># nginx -v</span></span><br><span class="line">nginx <span class="built_in">version</span>: nginx/<span class="number">1.6</span><span class="number">.2</span></span><br></pre></td></tr></table></figure></p><p>启动nginx之后，可以通过日志来查看进程的相关信息<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@root nginx]<span class="comment"># ps -ef | grep nginx</span></span><br><span class="line">root      <span class="number"> 627 </span>29830 <span class="number"> 0 </span>15:46 pts/1    00:00:00 grep --color=auto nginx</span><br><span class="line">root    <span class="number"> 18474 </span>   <span class="number"> 1 </span><span class="number"> 0 </span>May17 ?        00:00:00 nginx: master process /usr/local/webserver/nginx/sbin/nginx</span><br><span class="line">nobody  <span class="number"> 29997 </span>18474 <span class="number"> 0 </span>14:44 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure></p><p>nginx: master process 主要是负责日志的更新，热装载 主进程<br>nginx: worker process 工作进程 处理客户端的连接，处理请求</p><h2 id="Nginx-常用命令"><a href="#Nginx-常用命令" class="headerlink" title="Nginx 常用命令"></a>Nginx 常用命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx                     <span class="comment"># 默认方式启动nginx</span></span><br><span class="line">nginx -s <span class="keyword">reload</span>           <span class="comment"># 重新载入配置文件，热装载</span></span><br><span class="line">nginx -s reopen           <span class="comment"># 重启 Nginx</span></span><br><span class="line">nginx -s stop             <span class="comment"># 快速停止 Nginx</span></span><br><span class="line">nginx -s <span class="keyword">quit</span>             <span class="comment"># 当前请求处理完停止 Nginx</span></span><br><span class="line">nginx -c <span class="string">/tmp/nginx.conf</span>  <span class="comment"># 指定配置文件启动</span></span><br><span class="line">nginx -t                  <span class="comment"># 测试配置是否正确</span></span><br></pre></td></tr></table></figure><h2 id="Nginx-常用配置"><a href="#Nginx-常用配置" class="headerlink" title="Nginx 常用配置"></a>Nginx 常用配置</h2><p>Nginx服务器的基础配置，默认的配置存放在nginx/nginx.conf。</p><p>在 nginx.conf 的注释符号为： #</p><h3 id="默认的-nginx-配置文件-nginx-conf"><a href="#默认的-nginx-配置文件-nginx-conf" class="headerlink" title="默认的 nginx 配置文件 nginx.conf"></a>默认的 nginx 配置文件 nginx.conf</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx的文件结构"><a href="#Nginx的文件结构" class="headerlink" title="Nginx的文件结构"></a>Nginx的文件结构</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span>.              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">..</span>.   #http全局块</span><br><span class="line">   <span class="built_in"> server </span>       #server块</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">..</span>.       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">..</span>.</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">..</span>.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">..</span>.</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">..</span>.     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>5、location块：配置请求的路由，以及各种页面的处理情况。</li></ul><h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="attribute">error_log</span> log/error.log <span class="literal">debug</span>;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    <span class="attribute">log_format</span> myFormat <span class="string">'<span class="variable">$remote_addr</span>–<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="variable">$request</span> <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="variable">$http_referer</span> <span class="variable">$http_user_agent</span> <span class="variable">$http_x_forwarded_for</span>'</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    <span class="attribute">access_log</span> log/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    <span class="attribute">sendfile_max_chunk</span> <span class="number">100k</span>;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> mysvr &#123;   </span><br><span class="line">      <span class="attribute">server</span> <span class="number">127.0.0.1:7878</span>;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.10.121:3333</span> backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">keepalive_requests</span> <span class="number">120</span>; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">4545</span>;   <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;   <span class="comment">#监听地址       </span></span><br><span class="line">        <span class="attribute">location</span>  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           <span class="attribute">proxy_pass</span>  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           <span class="attribute">deny</span> <span class="number">127.0.0.1</span>;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           <span class="attribute">allow</span> <span class="number">172.18.5.54</span>; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是nginx的基本配置，需要注意的有以下几点：</p><h4 id="1、几个常见配置项："><a href="#1、几个常见配置项：" class="headerlink" title="1、几个常见配置项："></a>1、几个常见配置项：</h4><p>1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；<br>2.$remote_user ：用来记录客户端用户名称；<br>3.$time_local ： 用来记录访问时间与时区；<br>4.$request ： 用来记录请求的url与http协议；<br>5.$status ： 用来记录请求状态；成功是200；<br>6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；<br>7.$http_referer ：用来记录从那个页面链接访问过来的；<br>8.$http_user_agent ：记录客户端浏览器的相关信息；</p><h4 id="2、惊群现象："><a href="#2、惊群现象：" class="headerlink" title="2、惊群现象："></a>2、惊群现象：</h4><p>一个网路连接到来，多个睡眠的进程被同事叫醒，但只有一个进程能获得链接，这样会影响系统性能。</p><h4 id="3、每个指令必须有分号结束。"><a href="#3、每个指令必须有分号结束。" class="headerlink" title="3、每个指令必须有分号结束。"></a>3、每个指令必须有分号结束。</h4><p><code>原文地址：https://www.cnblogs.com/knowledgesea/p/5175711.html</code></p><h2 id="配置动静分离"><a href="#配置动静分离" class="headerlink" title="配置动静分离"></a>配置动静分离</h2><p>所谓的动静分离实质上是指我们对于nginx配置里面的动态请求和静态文件都做了一定的分离。例如以下的配置信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  www.idea.com  <span class="regexp">*.idea.com</span>  <span class="regexp">idea.*</span>;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/www;    </span><br><span class="line">    <span class="comment">#这里面添加映射static的记录</span></span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/local/static/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>  /usr/local/www/;</span><br><span class="line">            <span class="attribute">index</span> idea.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ps:这里面的配置内容，我引入了host文件的修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.43</span><span class="selector-class">.235</span> <span class="selector-tag">www</span><span class="selector-class">.idea</span><span class="selector-class">.com</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.43</span><span class="selector-class">.235</span> <span class="selector-tag">test</span><span class="selector-class">.idea</span><span class="selector-class">.com</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.43</span><span class="selector-class">.235</span> <span class="selector-tag">idea</span><span class="selector-class">.test</span></span><br></pre></td></tr></table></figure><p>图片的实际存储位置是：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="keyword">local</span>/<span class="keyword">static</span>/img/logo.jpg</span><br></pre></td></tr></table></figure><p>按照上述的配置来讲，访问的方式是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.idea.com<span class="regexp">/static/img</span><span class="regexp">/logo.jpg</span></span><br></pre></td></tr></table></figure><p>但是这种情况下，我们通过nginx来访问图片的方式是不会成功的，原因是这个地址会被nginx处理成为：</p><p>前往root地址+static的最终地址进行查询：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="keyword">local</span>/<span class="keyword">static</span>/<span class="keyword">static</span></span><br></pre></td></tr></table></figure><p>为了避免这种情况，通常会用别名alias来进行匹配，具体配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  www.idea.com  <span class="regexp">*.idea.com</span>  <span class="regexp">idea.*</span>;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/www;    </span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">            <span class="attribute">alias</span> /usr/local/static/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>  /usr/local/www/;</span><br><span class="line">            <span class="attribute">index</span> idea.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们再去访问 <a href="http://www.idea.com/static/img/logo.jpg" target="_blank" rel="noopener">http://www.idea.com/static/img/logo.jpg</a> 就会访问成功了。</p><p>同样对于别名我们可以进行更加复杂一些的逻辑操作案例：</p><p>假设我们需要访问static底下的文件内容，这个时候不需要携带相应的名称，直接通过访问<br><a href="http://www.idea.com/static/css/test.css" target="_blank" rel="noopener">http://www.idea.com/static/css/test.css</a> 就可以访问到 /usr/local/www/static/css/ 底下的内容了</p><p>那么，假如说有很多种类型的静态文件需要进行映射该如何配置呢？这个时候可以引入正则表达式的配置：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.idea.com  <span class="regexp">*.idea.com</span>  <span class="regexp">idea.*</span>;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/www;    </span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="attribute">alias</span> /usr/local/static/;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#这里的~是指忽略大小写</span></span><br><span class="line">    <span class="attribute">location</span>  <span class="regexp">~* \.(gif|png|jpg|css|js)</span> &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/static/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>  /usr/local/www/;</span><br><span class="line">        <span class="attribute">index</span>  idea.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加入了这段正则表达式的配置之后（~* .(gif|png|css|js)$） 通过访问该路径：<br><a href="http://www.idea.com/css/test.css" target="_blank" rel="noopener">http://www.idea.com/css/test.css</a> 我们就可以访问到/usr/local/static/css/底下的文件内容了。</p><h2 id="代理访问机制"><a href="#代理访问机制" class="headerlink" title="代理访问机制"></a>代理访问机制</h2><p>nginx还提供了一个非常灵活的代理访问机制，供我们通过代理的方式来进行访问location</p><p>通过nginx配置完全匹配代理进行页面跳转：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.idea.com  <span class="regexp">*.idea.com</span>  <span class="regexp">idea.*</span>;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/www;    </span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="attribute">alias</span> /usr/local/static/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~* \.(gif|png|jpg|css|js)</span> &#123;</span><br><span class="line">        <span class="attribute">alias</span> /usr/local/static/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span>  =/idea-serach &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://www.baidu.com</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="attribute">root</span>  /usr/local/www/;</span><br><span class="line">        <span class="attribute">index</span> idea.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过proxy_pass配置来提供代理的请求转发，当我们访问<a href="http://www.idea.com/idea-serach的时候，就会匹配到访问百度的页面了。" target="_blank" rel="noopener">http://www.idea.com/idea-serach的时候，就会匹配到访问百度的页面了。</a></p><p><strong>小结</strong></p><ol><li><p>nginx对于访问的常见配置支持以下几种：</p></li><li><p>通过全路径访问location</p></li><li><p>通过关键字static匹配来访问location</p></li><li><p>通过正则表达式来访问location</p></li><li><p>通过反向代理进行访问location</p></li></ol><h2 id="防盗链匹配"><a href="#防盗链匹配" class="headerlink" title="防盗链匹配"></a>防盗链匹配</h2><p>设置某些链接只允许在固定的网站站点进行访问，防止某些特殊的域名进行ip访问之后盗取本网站的资源文件，因此可以设置这个防盗链的功能。具体配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  www.idea.com  <span class="regexp">*.idea.com</span>  <span class="regexp">idea.*</span>;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/www/;   </span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">            <span class="attribute">alias</span> /usr/local/static/;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 防盗链配置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~* \.(gif|png|jpg|css|js)</span> &#123;</span><br><span class="line">            <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> <span class="regexp">*.idea.com</span>;</span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">root</span> /usr/local/static/;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> =/idea-serach &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>  /usr/local/www/;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网站黑名单"><a href="#网站黑名单" class="headerlink" title="网站黑名单"></a>网站黑名单</h2><p>黑名单的配置比较简单，只需要先创建好黑名单文件，然后在http块里面引入就好了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建黑名单文件</span></span><br><span class="line">echo <span class="string">'deny 192.168.0.132;'</span> <span class="meta">&gt;&gt; </span>balck.ip</span><br><span class="line"><span class="comment">#http 配置块中引入 黑名单文件</span></span><br><span class="line"><span class="keyword">include</span>       black.ip;</span><br></pre></td></tr></table></figure><p>记得配置成功之后要让nginx reload一下,同时请求的时候查看是否是203，如果是的话说明是缓存请求。</p><h2 id="Nginx的日志配置"><a href="#Nginx的日志配置" class="headerlink" title="Nginx的日志配置"></a>Nginx的日志配置</h2><p>当我们需要对于客户端发送的数据进行一些详细信息的查看时候，需要对nginx进行日志的记录，相应的可选参数有以下几点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log_format格式变量：</span><br><span class="line">    <span class="variable">$remote_addr</span>  <span class="comment">#记录访问网站的客户端地址</span></span><br><span class="line">    <span class="variable">$remote_user</span>  <span class="comment">#远程客户端用户名</span></span><br><span class="line">    <span class="variable">$time_local</span>  <span class="comment">#记录访问时间与时区</span></span><br><span class="line">    <span class="variable">$request</span>  <span class="comment">#用户的http请求起始行信息</span></span><br><span class="line">    <span class="variable">$status</span>  <span class="comment">#http状态码，记录请求返回的状态码，例如：200、301、404等</span></span><br><span class="line">    <span class="variable">$body_bytes_sent</span>  <span class="comment">#服务器发送给客户端的响应body字节数</span></span><br><span class="line">    <span class="variable">$http_referer</span>  <span class="comment">#记录此次请求是从哪个连接访问过来的，可以根据该参数进行防盗链设置。</span></span><br><span class="line">    <span class="variable">$http_user_agent</span>  <span class="comment">#记录客户端访问信息，例如：浏览器、手机客户端等</span></span><br><span class="line">    <span class="variable">$http_x_forwarded_for</span>  <span class="comment">#当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置</span></span><br><span class="line">将日志配置放在http块里面即可。</span><br></pre></td></tr></table></figure><p>通常我们会将日志的配置放置于http模块当中，例如下边的这组案例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx-负载均衡"><a href="#Nginx-负载均衡" class="headerlink" title="Nginx 负载均衡"></a>Nginx 负载均衡</h2><p>nginx里面有个叫做upstream的模块，专门用于配置负载均衡的内容，upstream里面提供有以下的相关参数：</p><p><strong>service</strong> 反向服务地址 加端口<br><strong>weight</strong> 权重<br><strong>max_fails</strong> 失败多少次 认为主机已挂掉则，踢出<br><strong>fail_timeout</strong> 移除server之后重新请求的时间 当服务挂了之后，这段时间内重新连接<br><strong>backup</strong> 备用服务 （当服务全部都挂了，那么就会请求这里的服务）<br><strong>max_conns</strong> 允许最大连接数<br><strong>slow_start</strong> 当节点恢复，不立即加入,而是等待 slow_start 后加入服务对列。</p><p><strong>相应参数的具体配置如下：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    <span class="built_in"> server </span>192.168.43.191:8080 <span class="attribute">weight</span>=5 <span class="attribute">fail_timeout</span>=10s;</span><br><span class="line">    <span class="built_in"> server </span>192.168.43.191:8089 <span class="attribute">weight</span>=5 <span class="attribute">fail_timeout</span>=10s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ngixn里面默认支持的负载均衡策略是轮询加权重的方式，除此之外，nginx自身还支持额外的多种负载均衡策略：</p><p><strong>ll+weight：轮询加权重 (默认)</strong><br>容易出现失重的情况，例如说某一台机器的访问过慢，容易导致请求堆积。</p><p><strong>ip_hash : 基于Hash 计算 ,常用于保持session 一致性</strong><br>基于hash计算的时候，可以根据ip进行hash计算请求到指定的服务器。<br>（通常session一致性在分布式中最好的处理手段是将session存储在第三方的存储中心）</p><p>首先对ip进行hash计算之后，将该值和服务器个数进行取模运算。</p><p><strong>url_hash: 静态资源缓存,节约存储，加快速度</strong><br>可以根据图片的url请求到指定的服务器，比较好理解。</p><p><strong>least_conn : 最小连接数</strong><br>每次请求都只会请求到最少客户端连接数的那台服务器去。</p><p><strong>least_time ：最小的响应时间</strong><br>计算节点平均响应时间，然后取响应最快的那个，分配权重更高</p><p>通过使用ip进行哈希计算的方式来请求后端服务器</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">     ip_hash;</span><br><span class="line">     <span class="keyword">server</span> <span class="number">192.168</span><span class="number">.43</span><span class="number">.191</span>:<span class="number">8080</span> weight=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">server</span> <span class="number">192.168</span><span class="number">.43</span><span class="number">.191</span>:<span class="number">8089</span> weight=<span class="number">8</span> fail_timeout=<span class="number">10</span>s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">          <span class="meta">#root   html;</span></span><br><span class="line">          <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</span><br><span class="line">          proxy_pass http:<span class="comment">//backend;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当然Nginx除了这些常用功能以外，还提供有非常丰富的其他功能配置，具体配置可以参考nginx的官方文档配置信息<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。&lt;/p&gt;
&lt;p&gt;在高连接并发的情况下，Nginx是Apache服务器不错的替代品。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.shado.com.cn/categories/java/"/>
    
    
      <category term="nginx" scheme="https://www.shado.com.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="https://www.shado.com.cn/2018/11/22/2018-11-22-java-collection/"/>
    <id>https://www.shado.com.cn/2018/11/22/2018-11-22-java-collection/</id>
    <published>2018-11-22T11:25:11.000Z</published>
    <updated>2019-06-19T02:14:07.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="接口继承关系和实现"><a href="#接口继承关系和实现" class="headerlink" title="接口继承关系和实现"></a>接口继承关系和实现</h2><p><img src="/2018/11/22/2018-11-22-java-collection/java-collection.jpg" alt="Collection"><br>集合类存放于Java.util 包中，主要有3 种：set(集）、list(列表包含Queue）和map(映射)。<br><a id="more"></a></p><ol><li>Collection：Collection 是集合List、Set、Queue 的最基本的接口。</li><li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li><li>Map：是映射表的基础接口</li></ol><p><img src="/2018/11/22/2018-11-22-java-collection/java-collection-class.jpg" alt="Collection Class"></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Java 的List 是非常常用的数据类型。List 是有序的Collection。Java List 一共三个实现类：分别是ArrayList、Vector 和LinkedList。<br><img src="/2018/11/22/2018-11-22-java-collection/collection-list.jpg" alt="Collection List"></p><h3 id="ArrayList-数组"><a href="#ArrayList-数组" class="headerlink" title="ArrayList(数组)"></a>ArrayList(数组)</h3><p>ArrayList 是最常用的List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><h3 id="Vector-数组、synchronized实现线程安全"><a href="#Vector-数组、synchronized实现线程安全" class="headerlink" title="Vector(数组、synchronized实现线程安全)"></a>Vector(数组、synchronized实现线程安全)</h3><p>Vector 与ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList 慢。</p><h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList(链表)"></a>LinkedList(链表)</h3><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object 的hashCode 方法和equals 方法。<br><img src="/2018/11/22/2018-11-22-java-collection/collection-set.jpg" alt="Collection Set"></p><h3 id="HashSet-Hash表"><a href="#HashSet-Hash表" class="headerlink" title="HashSet(Hash表)"></a>HashSet(Hash表)</h3><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为true ，HashSet 就视为同一个元素。如果equals 为false 就不是同一个元素。<br>哈希值相同equals 为false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图1 表示hashCode 值不相同的情况；图2 表示hashCode 值相同，但equals 不相同的情况。</p><p>HashSet 通过hashCode 值来确定元素在内存中的位置。一个hashCode 位置上可以存放多个元素。</p><h3 id="TreeSet-二叉树"><a href="#TreeSet-二叉树" class="headerlink" title="TreeSet(二叉树)"></a>TreeSet(二叉树)</h3><ol><li>TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li><li>Integer 和String 对象都可以进行默认的TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable 接口，并且覆写相应的compareTo()函数，才可以正常使用。</li><li>在覆写compare()函数时，要返回相应的值才能使TreeSet 按照一定的规则来排序</li><li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li></ol><h3 id="LinkHashSet-HashSet-LinkedHashMap）"><a href="#LinkHashSet-HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet(HashSet+LinkedHashMap）"></a>LinkHashSet(HashSet+LinkedHashMap）</h3><p>对于LinkedHashSet 而言， 它继承与HashSet 、又基于LinkedHashMap 来实现的。LinkedHashSet 底层使用LinkedHashMap 来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet 相同，因此LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap 来实现，在相关操作上与父类HashSet 的操作相同，直接调用父类HashSet 的方法即可。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/2018/11/22/2018-11-22-java-collection/collection-map.jpg" alt="Collection Map"></p><h3 id="HashMap-数组-链表-红黑树"><a href="#HashMap-数组-链表-红黑树" class="headerlink" title="HashMap(数组+链表+红黑树)"></a>HashMap(数组+链表+红黑树)</h3><p>HashMap 根据键的hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为null，允许多条记录的值为null。HashMap 非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。</p><h4 id="Java7实现"><a href="#Java7实现" class="headerlink" title="Java7实现"></a>Java7实现</h4><p><img src="/2018/11/22/2018-11-22-java-collection/hashmap-java7.jpg" alt="HashMap Java7"><br>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><ol><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li><li>loadFactor：负载因子，默认为 0.75。</li><li>threshold：扩容的阈值，等于 capacity * loadFactor</li></ol><h4 id="Java8实现"><a href="#Java8实现" class="headerlink" title="Java8实现"></a>Java8实现</h4><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="/2018/11/22/2018-11-22-java-collection/hashmap-java8.jpg" alt="HashMap Java8"></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="Segment段"><a href="#Segment段" class="headerlink" title="Segment段"></a>Segment段</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。</p><h4 id="线程安全-Segment-继承-ReentrantLock-加锁"><a href="#线程安全-Segment-继承-ReentrantLock-加锁" class="headerlink" title="线程安全(Segment 继承 ReentrantLock 加锁)"></a>线程安全(Segment 继承 ReentrantLock 加锁)</h4><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。<br><img src="/2018/11/22/2018-11-22-java-collection/collection-concurrenthashmap.jpg" alt="ConcurrentHashMap Java7"></p><h4 id="并行度-默认16"><a href="#并行度-默认16" class="headerlink" title="并行度(默认16)"></a>并行度(默认16)</h4><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h4 id="Java8-实现-引入了红黑树"><a href="#Java8-实现-引入了红黑树" class="headerlink" title="Java8 实现(引入了红黑树)"></a>Java8 实现(引入了红黑树)</h4><p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。<br><img src="/2018/11/22/2018-11-22-java-collection/concurrenthashmap-java8.jpg" alt="ConcurrentHashMap Java8"></p><h3 id="HashTable-线程安全"><a href="#HashTable-线程安全" class="headerlink" title="HashTable(线程安全)"></a>HashTable(线程安全)</h3><p>HashTable 是遗留类，很多映射的常用功能与HashMap 类似，不同的是它承自Dictionary 类，并且是线程安全的，任一时间只有一个线程能写HashTable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap 引入了分段锁。HashTable 不建议在新代码中使用，不需要线程安全的场合可以用HashMap 替换，需要线程安全的场合可以用ConcurrentHashMap 替换。</p><h3 id="TreeMap-可排序"><a href="#TreeMap-可排序" class="headerlink" title="TreeMap(可排序)"></a>TreeMap(可排序)</h3><p>TreeMap 实现SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用TreeMap。<br>在使用TreeMap 时，key 必须实现Comparable 接口或者在构造TreeMap 传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException 类型的异常。</p><h3 id="LinkHashMap-记录插入顺序"><a href="#LinkHashMap-记录插入顺序" class="headerlink" title="LinkHashMap(记录插入顺序)"></a>LinkHashMap(记录插入顺序)</h3><p>LinkedHashMap 是HashMap 的一个子类，保存了记录的插入顺序，在用Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;接口继承关系和实现&quot;&gt;&lt;a href=&quot;#接口继承关系和实现&quot; class=&quot;headerlink&quot; title=&quot;接口继承关系和实现&quot;&gt;&lt;/a&gt;接口继承关系和实现&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/11/22/2018-11-22-java-collection/java-collection.jpg&quot; alt=&quot;Collection&quot;&gt;&lt;br&gt;集合类存放于Java.util 包中，主要有3 种：set(集）、list(列表包含Queue）和map(映射)。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="集合" scheme="https://www.shado.com.cn/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="List" scheme="https://www.shado.com.cn/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://www.shado.com.cn/2018/10/22/2018-10-22-rabbitmq/"/>
    <id>https://www.shado.com.cn/2018/10/22/2018-10-22-rabbitmq/</id>
    <published>2018-10-22T12:18:28.000Z</published>
    <updated>2019-06-18T07:30:01.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。<br><a id="more"></a><br>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT等等。</li><li>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li><li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li><li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li></ol><h2 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h2><p><img src="/2018/10/22/2018-10-22-rabbitmq/rabbitmq-framework.jpg" alt="RabbitMQ"></p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li></ol><h3 id="Exchange（将消息路由给队列-）"><a href="#Exchange（将消息路由给队列-）" class="headerlink" title="Exchange（将消息路由给队列 ）"></a>Exchange（将消息路由给队列 ）</h3><ol start="2"><li>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li></ol><h3 id="Binding（消息队列和交换器之间的关联）"><a href="#Binding（消息队列和交换器之间的关联）" class="headerlink" title="Binding（消息队列和交换器之间的关联）"></a>Binding（消息队列和交换器之间的关联）</h3><ol start="3"><li>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li></ol><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ol start="5"><li>网络连接，比如一个TCP 连接。</li></ol><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ol start="6"><li>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP 连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li></ol><h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ol start="9"><li>表示消息队列服务器实体。</li></ol><h2 id="Exchange-将消息路由给队列"><a href="#Exchange-将消息路由给队列" class="headerlink" title="Exchange(将消息路由给队列)"></a>Exchange(将消息路由给队列)</h2><p>Exchange 分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h3 id="Direct-键（routing-key）分布："><a href="#Direct-键（routing-key）分布：" class="headerlink" title="Direct 键（routing key）分布："></a>Direct 键（routing key）分布：</h3><ol><li>Direct：消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。</li></ol><p><img src="/2018/10/22/2018-10-22-rabbitmq/rabbitmq-exchange.jpg" alt="RabbitMQ"></p><h3 id="Fanout（广播分发）"><a href="#Fanout（广播分发）" class="headerlink" title="Fanout（广播分发）"></a>Fanout（广播分发）</h3><ol start="2"><li>Fanout：每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</li></ol><p><img src="/2018/10/22/2018-10-22-rabbitmq/rabbitmq-fanout.jpg" alt="RabbitMQ"></p><h3 id="topic-交换器（模式匹配）"><a href="#topic-交换器（模式匹配）" class="headerlink" title="topic 交换器（模式匹配）"></a>topic 交换器（模式匹配）</h3><ol start="3"><li>topic 交换器：topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0 个或多个单词，匹配不多不少一个单词。</li></ol><p><img src="/2018/10/22/2018-10-22-rabbitmq/rabbitmq-topic.jpg" alt="RabbitMQ"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。&lt;br&gt;AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://www.shado.com.cn/categories/RabbitMQ/"/>
    
    
      <category term="MQ" scheme="https://www.shado.com.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>Java 常用类库</title>
    <link href="https://www.shado.com.cn/2018/08/11/2018-08-11-java-common-library/"/>
    <id>https://www.shado.com.cn/2018/08/11/2018-08-11-java-common-library/</id>
    <published>2018-08-11T02:28:44.000Z</published>
    <updated>2019-06-19T02:15:01.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录开发中经常用到的类库<br><a id="more"></a></p><h2 id="日志相关类库"><a href="#日志相关类库" class="headerlink" title="日志相关类库"></a>日志相关类库</h2><p>日志库是很常见的，因为你在每一个项目中都需要他们。打印日志是服务器端应用中最重要的事情，因为日志是你了解你的程序发生了什么的唯一途径。尽管JDK附带自己的日志库，但是还是有很多更好的选择可用，例如 Log4j 、 SLF4j 和 LogBack。</p><p>Java开发人员应该熟悉日志记录的利弊， 并且了解为什么SLF4J要比Log4J要好。</p><p>SLF4J</p><h2 id="JSON解析库"><a href="#JSON解析库" class="headerlink" title="JSON解析库"></a>JSON解析库</h2><p>在当今世界的web服务和物联网中(IoT)，JSON已经取代了XML，成为从客户端到服务器传送信息的首选协议。有一个好消息和一个坏消息。坏消息 是JDK没有提供JSON库。好消息是有许多优秀的第三方库可以用来解析和创建JSON消息，如 Jackson 和 Gson。</p><p>一个Java web开发人员应该熟悉Jackson 和 Gson这两种中的至少一种库。</p><p>Jackson</p><h2 id="单元测试库"><a href="#单元测试库" class="headerlink" title="单元测试库"></a>单元测试库</h2><p>单元测试技术的使用，是区分一个一般的开发者和好的开发者的重要指标。程序员经常有各种借口不写单元测试，但最常见的借口就是缺乏经验和知识。常见的单测框架有 JUnit , Mockito 和PowerMock 。</p><p>JUnit</p><h2 id="通用类库"><a href="#通用类库" class="headerlink" title="通用类库"></a>通用类库</h2><p>有几个很好的第三方通用库可供Java开发人员使用，例如 Apache Commons 和 Google Guava 。我会经常在我的代码中使用这些通用类库，因为这些类库都是经过无数开发者实践过的，无论是实用性还是在性能等方面都是最佳的。</p><p>Apache Commons 和 Google Guava</p><h2 id="Http-库"><a href="#Http-库" class="headerlink" title="Http 库"></a>Http 库</h2><p>我不是很喜欢JDK的一个重要原因就包括他们缺乏对HTTP的支持。虽然可以使用java.net包类，但是这和直接使用像 Apache HttpClient 和 HttpCore 等开源类库比起来麻烦太多了。</p><p>尽管JDK 9将开始HTTP 2.0，也对HTTP的支持做了优化，但是我还是强烈建议所有的Java开发人员熟悉流行的HTTP处理类库，例如HttpClient和HttpCore HTTP等库。</p><h2 id="XML解析库"><a href="#XML解析库" class="headerlink" title="XML解析库"></a>XML解析库</h2><p>市面上有很多XML解析的类库，如 Xerces , JAXB , JAXP , Dom4j , Xstream 等。 Xerces2是下一代高性能，完全兼容的XML解析工具。Xerces2定义了 Xerces Native Interface (XNI)规范，并提供了一个完整、兼容标准的 XNI 规范实现。该解析器是完全重新设计和实现的，更简单以及模块化。</p><h2 id="Excel读写库"><a href="#Excel读写库" class="headerlink" title="Excel读写库"></a>Excel读写库</h2><p>许多应用程序需要提供把数据导出到Excel的功能，如果你要做相同的Java应用程序,那么你需要 Apache POI API 。这是一个非常丰富的类库，你可以从Java程序读写XLS文件。</p><h2 id="字节码库"><a href="#字节码库" class="headerlink" title="字节码库"></a>字节码库</h2><p>如果你正在编写一个框架或者类库。有一些受欢迎的字节码库如 javassist 和 Cglib Nodep 可以供你选择，他们可以让你阅读和修改应用程序生成的字节码。</p><p>Javassist使得JAVA字节码操作非常简单。它是一个为编辑Java字节码而生的类库。 ASM 是另一个有用的字节码编辑库。</p><h2 id="数据库连接池库"><a href="#数据库连接池库" class="headerlink" title="数据库连接池库"></a>数据库连接池库</h2><p>如果你的Java应用程序与数据库交互不是使用数据库连接池库的话，那么你就大错特错了。因为在运行时创建数据库连接非常耗时并且会拖慢你的程序。所以墙裂建议使用，有些好用的连接池可供选择，如 Commons Pool 和 DBCP 和 Alibaba druid。</p><p>在web应用程序中，web服务器通常提供了这些功能。但是在java项目中需要把数据库连接池的类库导入到应用中。</p><h2 id="消息传递库"><a href="#消息传递库" class="headerlink" title="消息传递库"></a>消息传递库</h2><p>像日志和数据库连接池一样，消息传递也是很多实际的Java项目中必备的。Java提供了JMS Java消息服务，但这不是JDK的一部分,你需要单独的引入jms.jar。类似地，如果您准备使用第三方消息传递协议， Tibco RV 是个不错的选择。</p><h2 id="PDF处理库"><a href="#PDF处理库" class="headerlink" title="PDF处理库"></a>PDF处理库</h2><p>除了Excel和Word，PDF也是一种常用的文件格式。如果你的应用程序要支持PDF格式的文件处理，你可以使用 iText 和 Apache FOP 类库。两者都提供了非常有用的PDF处理功能。</p><h2 id="日期和时间库"><a href="#日期和时间库" class="headerlink" title="日期和时间库"></a>日期和时间库</h2><p>在Java之前，JDK的日期和时间库一直被人们所诟病，比如其非线程安全的、不可变的、容易出错等。很多开发人员会选择更好用的 JodaTime 类库。</p><p>但是在Java8推出之后，我们就可以彻底放弃JodaTime了，因为Java 8提供了其所有功能。但是，如果你的代码运行在一个低版本的JDK中，那么JodaTime还是值得使用的。</p><h2 id="集合类库"><a href="#集合类库" class="headerlink" title="集合类库"></a>集合类库</h2><p>虽然JDK有丰富的集合类，但还是有很多第三方类库可以提供更多更好的功能。如 Apache Commons Collections 、 Goldman Sachs collections 、 Google Collections 和 Trove 。Trove尤其有用，因为它提供所有标准Collections 类的更快的版本以及能够直接在原语（primitive）（例如包含int 键或值的Map 等）上操作的Collections 类的功能。</p><p>FastUtil是另一个类似的API，它继承了Java Collection Framework，提供了数种特定类型的容器，包括映射map、集合set、列表list、优先级队列（prority queue），实现了java.util包的标准接口（还提供了标准类所没有的双向迭代器），还提供了很大的（64位）的array、set、list，以及快速、实用的二进制或文本文件的I/O操作类。</p><h2 id="邮件API"><a href="#邮件API" class="headerlink" title="邮件API"></a>邮件API</h2><p>javax.mail 和 Apache Commons Email 提供了发送邮件的api。它们建立在JavaMail API的基础上，提供简化的用法。</p><h2 id="HTML解析库"><a href="#HTML解析库" class="headerlink" title="HTML解析库"></a>HTML解析库</h2><p>和XML与JSON类似，HTML是另外一种我们可能要打交道的传输格式。值得庆幸的是，我们有jsoup可以大大简化Java应用程序使用HTML。你不仅可以使用 JSoup 解析HTML还可以创建HTML文档。</p><h2 id="加密库"><a href="#加密库" class="headerlink" title="加密库"></a>加密库</h2><p>Apache Commons家族中的 Commons Codec 就提供了一些公共的编解码实现，比如Base64, Hex, MD5,Phonetic and URLs等等。</p><h2 id="嵌入式SQL数据库"><a href="#嵌入式SQL数据库" class="headerlink" title="嵌入式SQL数据库"></a>嵌入式SQL数据库</h2><p>我真的是非常喜欢像 H2 这种内存数据库，他可以嵌入到你的Java应用中。在你跑单测的时候如果你需要一个数据库，用来验证你的SQL的话，他是个很好的选择。顺便说一句,H2不是唯一嵌入式DB，你还有 Apache Derby 和 HSQL 可供选择。</p><h2 id="JDBC故障诊断库"><a href="#JDBC故障诊断库" class="headerlink" title="JDBC故障诊断库"></a>JDBC故障诊断库</h2><p>有不错的JDBC扩展库的存在使得调试变得很容易，例如P6spy，这是一个针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。 P6Spy 分发包包括P6Log，它是一个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。</p><h2 id="序列化库"><a href="#序列化库" class="headerlink" title="序列化库"></a>序列化库</h2><p>Google Protocol Buffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。</p><h2 id="网络库"><a href="#网络库" class="headerlink" title="网络库"></a>网络库</h2><p>一些有用的网络库主要有 Netty 的和 Apache MINA 。如果您正在编写一个应用程序，你需要做的底层网络任务，可以考虑使用这些库。</p><p>这都是每位Java开发人员应该熟悉的，并且十分有用的库。Java生态系统非常庞大的，你会发现有很多不同的类库可以做不同的事情。每个你想到的东西，都可能有一个库可以做到。</p><p><code>参考来源公众号:Hollis</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记录开发中经常用到的类库&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.shado.com.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring原理</title>
    <link href="https://www.shado.com.cn/2018/07/09/2018-07-09-spring-principle/"/>
    <id>https://www.shado.com.cn/2018/07/09/2018-07-09-spring-principle/</id>
    <published>2018-07-09T12:15:32.000Z</published>
    <updated>2019-06-19T02:14:41.883Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。<br><a id="more"></a></p><h2 id="Spring特点"><a href="#Spring特点" class="headerlink" title="Spring特点"></a>Spring特点</h2><h3 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h3><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><h3 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h3><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h3 id="框架集合"><a href="#框架集合" class="headerlink" title="框架集合"></a>框架集合</h3><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-feature.jpg" alt="Spring Feature"></p><h2 id="Spring核心组件"><a href="#Spring核心组件" class="headerlink" title="Spring核心组件"></a>Spring核心组件</h2><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-component.jpg" alt="Spring Component"></p><h2 id="Spring常用模块"><a href="#Spring常用模块" class="headerlink" title="Spring常用模块"></a>Spring常用模块</h2><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-module.jpg" alt="Spring Module"></p><h2 id="Spring主要包"><a href="#Spring主要包" class="headerlink" title="Spring主要包"></a>Spring主要包</h2><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-main-package.jpg" alt="Spring Package"></p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>bean 注入与装配的的方式有很多种，可以通过xml，get set 方式，构造函数或者注解等。简单易用的方式就是使用Spring 的注解了，Spring 提供了大量的注解方式。<br><img src="/2018/07/09/2018-07-09-spring-principle/spring-annotation.jpg" alt="Spring Annotation"></p><h2 id="Spring第三方结合"><a href="#Spring第三方结合" class="headerlink" title="Spring第三方结合"></a>Spring第三方结合</h2><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-integration.jpg" alt="Spring Integration"></p><h2 id="Spring-IOC原理"><a href="#Spring-IOC原理" class="headerlink" title="Spring IOC原理"></a>Spring IOC原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p><h3 id="Spring-容器高层视图"><a href="#Spring-容器高层视图" class="headerlink" title="Spring 容器高层视图"></a>Spring 容器高层视图</h3><p>Spring 启动时读取应用程序提供的Bean 配置信息，并在Spring 容器中生成一份相应的Bean 配置注册表，然后根据这张注册表实例化Bean，装配好Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。其中Bean 缓存池为HashMap 实现。<br><img src="/2018/07/09/2018-07-09-spring-principle/spring-component-2.jpg" alt="Spring Component"></p><h3 id="IOC容器实现"><a href="#IOC容器实现" class="headerlink" title="IOC容器实现"></a>IOC容器实现</h3><h4 id="BeanFactory-框架基础设施"><a href="#BeanFactory-框架基础设施" class="headerlink" title="BeanFactory-框架基础设施"></a>BeanFactory-框架基础设施</h4><p>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。<br><img src="/2018/07/09/2018-07-09-spring-principle/beanfactory.jpg" alt="BeanFactory"></p><h5 id="BeanDefinitionRegistry-注册表"><a href="#BeanDefinitionRegistry-注册表" class="headerlink" title="BeanDefinitionRegistry 注册表"></a>BeanDefinitionRegistry 注册表</h5><ol><li>Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法。</li></ol><h5 id="BeanFactory-顶层接口"><a href="#BeanFactory-顶层接口" class="headerlink" title="BeanFactory 顶层接口"></a>BeanFactory 顶层接口</h5><ol start="2"><li>位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：</li></ol><h5 id="ListableBeanFactory"><a href="#ListableBeanFactory" class="headerlink" title="ListableBeanFactory"></a>ListableBeanFactory</h5><ol start="3"><li>该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</li></ol><h5 id="HierarchicalBeanFactory父子级联"><a href="#HierarchicalBeanFactory父子级联" class="headerlink" title="HierarchicalBeanFactory父子级联"></a>HierarchicalBeanFactory父子级联</h5><ol start="4"><li>父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li></ol><h5 id="ConfigurableBeanFactory"><a href="#ConfigurableBeanFactory" class="headerlink" title="ConfigurableBeanFactory"></a>ConfigurableBeanFactory</h5><ol start="5"><li>是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li></ol><h5 id="AutowireCapableBeanFactory-自动装配"><a href="#AutowireCapableBeanFactory-自动装配" class="headerlink" title="AutowireCapableBeanFactory 自动装配"></a>AutowireCapableBeanFactory 自动装配</h5><ol start="6"><li>定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li></ol><h5 id="SingletonBeanRegistry-运行期间注册单例-Bean"><a href="#SingletonBeanRegistry-运行期间注册单例-Bean" class="headerlink" title="SingletonBeanRegistry 运行期间注册单例 Bean"></a>SingletonBeanRegistry 运行期间注册单例 Bean</h5><ol start="7"><li>定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用HashMap 实现的缓存器，单实例的 Bean 以beanName 为键保存在这个HashMap 中。</li></ol><h5 id="依赖日志框架"><a href="#依赖日志框架" class="headerlink" title="依赖日志框架"></a>依赖日志框架</h5><ol start="8"><li>在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。</li></ol><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>ApplicationContext 由 BeanFactory 派生而来， 提供了更多面向实际应用的功能。ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：<br><img src="/2018/07/09/2018-07-09-spring-principle/applicationcontext.jpg" alt="ApplicationContext"></p><ol><li>ClassPathXmlApplicationContext：默认从类路径加载配置文件</li><li>FileSystemXmlApplicationContext：默认从文件系统中装载配置文件</li><li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</li><li>MessageSource：为应用提供 i18n 国际化消息访问的功能；</li><li>ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</li><li>LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li><li>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。</li></ol><h4 id="WebApplication-体系架构"><a href="#WebApplication-体系架构" class="headerlink" title="WebApplication 体系架构"></a>WebApplication 体系架构</h4><p>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext 中可以获得ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext中，以便 Web 应用环境可以访问 Spring 应用上下文。<br><img src="/2018/07/09/2018-07-09-spring-principle/webapplicationcontext.jpg" alt="webapplicationcontext"></p><h3 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h3><p>Spring 3 中为Bean 定义了5 中作用域，分别为singleton（单例）、prototype（原型）、request、session 和global session，5 种作用域说明如下：</p><h4 id="singleton-单例模式-多线程下不安全"><a href="#singleton-单例模式-多线程下不安全" class="headerlink" title="singleton:单例模式(多线程下不安全)"></a>singleton:单例模式(多线程下不安全)</h4><ol><li>singleton：单例模式，Spring IoC 容器中只会存在一个共享的Bean 实例，无论有多少个Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域，也可以显示的将Bean 定义为singleton 模式，配置为：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"userDao"</span> <span class="attribute">class</span>=<span class="string">"com.ioc.UserDaoImpl"</span> <span class="attribute">scope</span>=<span class="string">"singleton"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="prototype-原型模式每次使用时创建"><a href="#prototype-原型模式每次使用时创建" class="headerlink" title="prototype:原型模式每次使用时创建"></a>prototype:原型模式每次使用时创建</h4><ol start="2"><li>prototype:原型模式，每次通过Spring 容器获取prototype 定义的bean 时，容器都将创建一个新的Bean 实例，每个Bean 实例都有自己的属性和状态，而singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。</li></ol><h4 id="Request-一次-request-一个实例"><a href="#Request-一次-request-一个实例" class="headerlink" title="Request: 一次 request 一个实例"></a>Request: 一次 request 一个实例</h4><ol start="3"><li>request：在一次Http 请求中，容器会返回该Bean 的同一实例。而对不同的Http 请求则会产生新的Bean，而且该bean 仅在当前Http Request 内有效,当前Http 请求结束，该bean实例也将会被销毁。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"loginAction"</span> <span class="attribute">class</span>=<span class="string">"com.cnblogs.Login"</span> <span class="attribute">scope</span>=<span class="string">"request"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><ol start="4"><li>session：在一次Http Session 中，容器会返回该Bean 的同一实例。而对不同的Session 请求则会创建新的实例，该bean 实例仅在当前Session 内有效。同Http 请求相同，每一次session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session 请求内有效，请求结束，则实例将被销毁。</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"userPreference"</span> <span class="attribute">class</span>=<span class="string">"com.ioc.UserPreference"</span> <span class="attribute">scope</span>=<span class="string">"session"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="global-Session"><a href="#global-Session" class="headerlink" title="global Session"></a>global Session</h4><ol start="5"><li>global Session：在一个全局的Http Session 中，容器会返回该Bean 的同一个实例，仅在使用portlet context 时有效。</li></ol><h3 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h3><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><ol><li>实例化一个Bean，也就是我们常说的new。</li></ol><h4 id="IOC-依赖注入"><a href="#IOC-依赖注入" class="headerlink" title="IOC 依赖注入"></a>IOC 依赖注入</h4><ol start="2"><li>按照Spring 上下文对实例化的Bean 进行配置，也就是IOC 注入。</li></ol><h4 id="setBeanName-实现"><a href="#setBeanName-实现" class="headerlink" title="setBeanName 实现"></a>setBeanName 实现</h4><ol start="3"><li>如果这个Bean 已经实现了BeanNameAware 接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring 配置文件中Bean 的id 值</li></ol><h4 id="BeanFactoryAware-实现"><a href="#BeanFactoryAware-实现" class="headerlink" title="BeanFactoryAware 实现"></a>BeanFactoryAware 实现</h4><ol start="4"><li>如果这个Bean 已经实现了BeanFactoryAware 接口，会调用它实现的setBeanFactory，setBeanFactory(BeanFactory)传递的是Spring 工厂自身（可以用这个方式来获取其它Bean，只需在Spring 配置文件中配置一个普通的Bean 就可以）。</li></ol><h4 id="ApplicationContextAware-实现"><a href="#ApplicationContextAware-实现" class="headerlink" title="ApplicationContextAware 实现"></a>ApplicationContextAware 实现</h4><ol start="5"><li>如果这个Bean已经实现了ApplicationContextAware 接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring 上下文（同样这个方式也可以实现步骤4 的内容，但比4 更好，因为ApplicationContext 是BeanFactory 的子接口，有更多的实现方法）</li></ol><h4 id="postProcessBeforeInitialization-接口实现-初始化预处理"><a href="#postProcessBeforeInitialization-接口实现-初始化预处理" class="headerlink" title="postProcessBeforeInitialization 接口实现-初始化预处理"></a>postProcessBeforeInitialization 接口实现-初始化预处理</h4><ol start="6"><li>如果这个Bean 关联了BeanPostProcessor 接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是Bean 内容的更改，并且由于这个是在Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。</li></ol><h4 id="init-method"><a href="#init-method" class="headerlink" title="init-method"></a>init-method</h4><ol start="7"><li><p>如果Bean 在Spring 配置文件中配置了init-method 属性会自动调用其配置的初始化方法。postProcessAfterInitialization</p></li><li><p>如果这个Bean 关联了BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。<br>注：以上工作完成以后就可以应用这个Bean 了，那这个Bean 是一个Singleton 的，所以一般情况下我们调用同一个id 的Bean 会是在内容地址相同的实例，当然在Spring 配置文件中也可以配置非Singleton。</p></li></ol><h4 id="Destroy-过期自动清理阶段"><a href="#Destroy-过期自动清理阶段" class="headerlink" title="Destroy 过期自动清理阶段"></a>Destroy 过期自动清理阶段</h4><ol start="9"><li>当Bean 不再需要时，会经过清理阶段，如果Bean 实现了DisposableBean 这个接口，会调用那个其实现的destroy()方法；</li></ol><h4 id="destroy-method-自配置清理"><a href="#destroy-method-自配置清理" class="headerlink" title="destroy-method 自配置清理"></a>destroy-method 自配置清理</h4><ol start="10"><li>最后，如果这个Bean 的Spring 配置中配置了destroy-method 属性，会自动调用其配置的销毁方法。</li></ol><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-bean-lifecycle.jpg" alt="spring-bean-lifecycle"></p><ol start="11"><li>bean 标签有两个重要的属性（init-method 和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">init-method</span>=<span class="string">"初始化方法"</span> <span class="attr">destroy-method</span>=<span class="string">"销毁方法"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Spring依赖注入的四种方式"><a href="#Spring依赖注入的四种方式" class="headerlink" title="Spring依赖注入的四种方式"></a>Spring依赖注入的四种方式</h3><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*带参数，方便利用构造器进行注入*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CatDaoImpl</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>. message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"CatDaoImpl"</span> <span class="attr">class</span>=<span class="string">"com.CatDaoImpl"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">" message "</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Id</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"id"</span> <span class="attr">class</span>=<span class="string">"com.id "</span>&gt;</span> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="静态工厂注入"><a href="#静态工厂注入" class="headerlink" title="静态工厂注入"></a>静态工厂注入</h4><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring 注入的形式获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title">getStaticFactoryDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StaticFacotryDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> &#123;</span></span><br><span class="line">  <span class="comment">// 注入对象</span></span><br><span class="line">  <span class="keyword">private</span> FactoryDao staticFactoryDao;</span><br><span class="line">  <span class="comment">// 注入对象的 set 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaticFactoryDao</span><span class="params">(FactoryDao staticFactoryDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.staticFactoryDao = staticFactoryDao;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--factory-method="getStaticFactoryDaoImpl" 指定调用哪个工厂方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springAction"</span> <span class="attr">class</span>=<span class="string">" SpringAction"</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用静态工厂的方法注入对象，对应下面的配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"staticFactoryDao"</span> <span class="attr">ref</span>=<span class="string">"staticFactoryDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处获取对象的方式是从工厂类中获取静态方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"staticFactoryDao"</span> <span class="attr">class</span>=<span class="string">"DaoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getStaticFactoryDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h4><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new 工厂类，再调用普通的实例方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FactoryDao <span class="title">getFactoryDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FactoryDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> FactoryDao factoryDao; <span class="comment">//注入对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryDao</span><span class="params">(FactoryDao factoryDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.factoryDao = factoryDao;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springAction"</span> <span class="attr">class</span>=<span class="string">"SpringAction"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"factoryDao"</span> <span class="attr">ref</span>=<span class="string">"factoryDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"daoFactory"</span> <span class="attr">class</span>=<span class="string">"com.DaoFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"factoryDao"</span> <span class="attr">factory-bean</span>=<span class="string">"daoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getFactoryDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5种自动装配方式"><a href="#5种自动装配方式" class="headerlink" title="5种自动装配方式"></a>5种自动装配方式</h3><p>Spring 装配包括手动装配和自动装配，手动装配是有基于xml 装配、构造方法、setter 方法等自动装配有五种自动装配的方式，可以用来指导Spring 容器用自动装配方式来进行依赖注入。  </p><ol><li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li><li>byName：通过参数名 自动装配，Spring 容器在配置文件中发现bean 的autowire 属性被设置成byname，之后容器试图匹配、装配和该bean 的属性具有相同名字的bean。</li><li>byType：通过参数类型自动装配，Spring 容器在配置文件中发现bean 的autowire 属性被设置成byType，之后容器试图匹配、装配和该bean 的属性具有相同类型的bean。如果有多个bean 符合条件，则抛出错误。</li><li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>autodetect：首先尝试使用constructor 来自动装配，如果无法工作，则使用byType 方式。</li></ol><h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。<br>使用”横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。<br>AOP 主要应用场景有：  </p><ol><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading 懒加载</li><li>Debugging 调试</li><li>logging, tracing, profiling and monitoring 记录跟踪 优化 校准</li><li>Performance optimization 性能优化</li><li>Persistence 持久化</li><li>Resource pooling 资源池</li><li>Synchronization 同步</li><li>Transactions 事务</li></ol><h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><ol><li>切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象  </li><li>横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。  </li><li>连接点（joinpoint）：被拦截到的点，因为Spring 只支持方法类型的连接点，所以在Spring  中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。  </li><li>切入点（pointcut）：对连接点进行拦截的定义  </li><li>通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。</li><li>目标对象：代理的目标对象</li><li>织入（weave）：将切面应用到目标对象并导致代理对象创建的过程</li><li>引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。</li></ol><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-aop.jpg" alt="spring-aop"></p><h3 id="AOP两种代理方式"><a href="#AOP两种代理方式" class="headerlink" title="AOP两种代理方式"></a>AOP两种代理方式</h3><p>Spring 提供了两种方式来生成代理对象: JDKProxy 和Cglib，具体使用哪种方式生成由AopProxyFactory 根据AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK 动态代理技术，否则使用Cglib 来生成代理。</p><h4 id="JDK动态接口代理"><a href="#JDK动态接口代理" class="headerlink" title="JDK动态接口代理"></a>JDK动态接口代理</h4><ol><li>JDK 动态代理主要涉及到java.lang.reflect 包中的两个类：Proxy 和InvocationHandler。InvocationHandler 是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。</li></ol><h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><ol start="2"><li>：CGLib 全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java 类与实现Java 接口，CGLib 封装了asm，可以再运行期动态生成新的class。和JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib 创建动态代理。</li></ol><h3 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut</span>(value=<span class="string">"execution(* com.yangxin.core.service.*.*.*(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">point</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span>(value=<span class="string">"point()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"transaction begin"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@AfterReturning</span>(value = <span class="string">"point()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"transaction commit"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"point()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"transaction begin"</span>);</span><br><span class="line">    joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"transaction commit"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-aop-2.jpg" alt="spring-aop"></p><h2 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h2><p>Spring 的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet 来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p><h3 id="MVC流程"><a href="#MVC流程" class="headerlink" title="MVC流程"></a>MVC流程</h3><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-mvc-process.jpg" alt="spring-mvc-process"></p><h4 id="Http请求到DispatcherServlet"><a href="#Http请求到DispatcherServlet" class="headerlink" title="Http请求到DispatcherServlet"></a>Http请求到DispatcherServlet</h4><p>(1) 客户端请求提交到DispatcherServlet。</p><h4 id="HandlerMapping寻找处理器"><a href="#HandlerMapping寻找处理器" class="headerlink" title="HandlerMapping寻找处理器"></a>HandlerMapping寻找处理器</h4><p>(2) 由DispatcherServlet 控制器查询一个或多个HandlerMapping，找到处理请求的Controller。</p><h4 id="调用处理器Controller"><a href="#调用处理器Controller" class="headerlink" title="调用处理器Controller"></a>调用处理器Controller</h4><p>(3) DispatcherServlet 将请求提交到Controller。</p><h4 id="Controller调用业务逻辑处理后，返回ModelAndView"><a href="#Controller调用业务逻辑处理后，返回ModelAndView" class="headerlink" title="Controller调用业务逻辑处理后，返回ModelAndView"></a>Controller调用业务逻辑处理后，返回ModelAndView</h4><p>(4)(5)调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回ModelAndView。</p><h4 id="DispatcherServlet查询ModelAndView"><a href="#DispatcherServlet查询ModelAndView" class="headerlink" title="DispatcherServlet查询ModelAndView"></a>DispatcherServlet查询ModelAndView</h4><p>(6)(7)处理视图映射并返回模型： DispatcherServlet 查询一个或多个ViewResoler 视图解析器，找到ModelAndView 指定的视图。</p><h4 id="ModelAndView反馈浏览器HTTP"><a href="#ModelAndView反馈浏览器HTTP" class="headerlink" title="ModelAndView反馈浏览器HTTP"></a>ModelAndView反馈浏览器HTTP</h4><p>(8) Http 响应：视图负责将结果显示到客户端。</p><h3 id="MVC常用注解"><a href="#MVC常用注解" class="headerlink" title="MVC常用注解"></a>MVC常用注解</h3><p><img src="/2018/07/09/2018-07-09-spring-principle/spring-mvc-annotation.jpg" alt="spring-mvc-annotation"></p><h2 id="Spring-Boot原理"><a href="#Spring-Boot原理" class="headerlink" title="Spring Boot原理"></a>Spring Boot原理</h2><p>Spring Boot 是由Pivotal 团队提供的全新框架，其设计目的是用来简化新Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid applicationdevelopment)成为领导者。其特点如下：</p><ol><li>创建独立的Spring应用程序</li><li>嵌入的Tomcat，无需部署WAR文件</li><li>简化Maven配置</li><li>自动配置Spring</li><li>提供生产就绪型功能，如指标，健康检查和外部配置</li><li>绝对没有代码生成和对XML没有要求配置</li></ol><h2 id="JPA原理"><a href="#JPA原理" class="headerlink" title="JPA原理"></a>JPA原理</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily )。</p><h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>紧密依赖于底层资源管理器（例如数据库连接 )，事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Connection conn = <span class="keyword">null</span>;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    conn = getDataSource().getConnection();</span><br><span class="line">    <span class="comment">// 将自动提交，true则数据库将会把每一次数据更新认定为一个事务并自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    <span class="comment">// A账号金额减少500</span></span><br><span class="line">    stmt.execute(<span class="string">"update t_account set amount = amount - 500 where account_id = 'A'"</span>);</span><br><span class="line">    <span class="comment">// B账户金额增加500</span></span><br><span class="line">    stmt.execute(<span class="string">"update t_account set amount = amount + 500 where account_id = 'B'"</span>);</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line">    <span class="comment">// 事务提交：转账的两步操作同时成功</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(SQLException sqle)&#123;</span><br><span class="line">    <span class="comment">// 发生异常，回滚操作</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">    <span class="comment">// 事务回滚：转账两步操作撤销</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java TransactionService) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（ Transaction Manager ）和一个或多个支持 XA 协议的资源管理器 ( ResourceManager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">transferAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  UserTransaction userTx = <span class="keyword">null</span>;</span><br><span class="line">  Connection connA = <span class="keyword">null</span>; Statement stmtA = <span class="keyword">null</span>;</span><br><span class="line">  Connection connB = <span class="keyword">null</span>; Statement stmtB = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 获得 Transaction 管理对象</span></span><br><span class="line">    userTx = (UserTransaction)getContext().lookup(<span class="string">"java:comp/UserTransaction"</span>);</span><br><span class="line">    connA = getDataSourceA().getConnection();<span class="comment">// 从数据库 A 中取得数据库连接</span></span><br><span class="line">    connB = getDataSourceB().getConnection();<span class="comment">// 从数据库 B 中取得数据库连接</span></span><br><span class="line">    userTx.begin(); <span class="comment">// 启动事务</span></span><br><span class="line">    stmtA = connA.createStatement();<span class="comment">// 将 A 账户中的金额减少 500</span></span><br><span class="line">    stmtA.execute(<span class="string">"update t_account set amount = amount - 500 where account_id = 'A'"</span>);</span><br><span class="line">    <span class="comment">// 将 B 账户中的金额增加 500</span></span><br><span class="line">    stmtB = connB.createStatement();</span><br><span class="line">    stmtB.execute(<span class="string">"update t_account set amount = amount + 500 where account_id =  'B'"</span>);</span><br><span class="line">    userTx.commit();<span class="comment">// 提交事务</span></span><br><span class="line">    <span class="comment">// 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新）</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(SQLException exception)&#123;</span><br><span class="line">      <span class="comment">// 发生异常，回滚在本事务中的操纵</span></span><br><span class="line">      userTx.rollback();<span class="comment">// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：第一阶段：准备阶段；第二阶段：提交阶段。<br><img src="/2018/07/09/2018-07-09-spring-principle/transaction.jpg" alt="transaction"></p><h5 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1 准备阶段"></a>1 准备阶段</h5><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo 和undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><h5 id="2-提交阶段"><a href="#2-提交阶段" class="headerlink" title="2 提交阶段"></a>2 提交阶段</h5><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。</p><h4 id="TCC方案"><a href="#TCC方案" class="headerlink" title="TCC方案"></a>TCC方案</h4><p>TCC的全程是：Try、Confirm、Cancel。</p><p>这个其实是用到了补偿的概念，分为了三个阶段：</p><p>1）Try阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留<br>2）Confirm阶段：这个阶段说的是在各个服务中执行实际的操作<br>3）Cancel阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作</p><p>给大家举个例子吧，比如说跨银行转账的时候，要涉及到两个银行的分布式事务，如果用TCC方案来实现，思路是这样的：</p><p>1）Try阶段：先把两个银行账户中的资金给它冻结住就不让操作了<br>2）Confirm阶段：执行实际的转账操作，A银行账户的资金扣减，B银行账户的资金增加<br>3）Cancel阶段：如果任何一个银行的操作执行失败，那么就需要回滚进行补偿，就是比如A银行账户如果已经扣减了，但是B银行账户资金增加失败了，那么就得把A银行账户资金给加回去</p><p>这种方案说实话几乎很少用人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用TCC，严格严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，在资金上出现问题</p><p>比较适合的场景：这个就是除非你是真的一致性要求太高，是你系统中核心之核心的场景，比如常见的就是资金类的场景，那你可以用TCC方案了，自己编写大量的业务逻辑，自己判断一个事务中的各个环节是否ok，不ok就执行补偿/回滚代码。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>国外的ebay搞出来的这么一套思想</p><p>这个大概意思是这样的</p><p>1）A系统在自己本地一个事务里操作同时，插入一条数据到消息表<br>2）接着A系统将这个消息发送到MQ中去<br>3）B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息<br>4）B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态<br>5）如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有没处理的消息，会再次发送到MQ中去，让B再次处理<br>6）这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止</p><p>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的？？？这个会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用</p><h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><p>这个的意思，就是干脆不要用本地的消息表了，直接基于MQ来实现事务。比如阿里的RocketMQ就支持消息事务。</p><p>大概的意思就是：<br>1）A系统先发送一个prepared消息到mq，如果这个prepared消息发送失败那么就直接取消操作别执行了<br>2）如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚消息<br>3）如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务<br>4）mq会自动定时轮询所有prepared消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认消息？那是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，别确认消息发送失败了。<br>5）这个方案里，要是系统B的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿</p><p>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的</p><h3 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h3><p>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指SqlSession 级别的缓存，当在同一个SqlSession 中进行相同的SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存1024 条SQL。二级缓存是指可以跨SqlSession 的缓存。是mapper 级别的缓存，对于mapper 级别的缓存不同的sqlsession 是可以共享的。</p><p><img src="/2018/07/09/2018-07-09-spring-principle/mybatis-cache.jpg" alt="Mybatis Cache"></p><h4 id="Mybatis的一级缓存原理-sqlsession-级别"><a href="#Mybatis的一级缓存原理-sqlsession-级别" class="headerlink" title="Mybatis的一级缓存原理(sqlsession 级别)"></a>Mybatis的一级缓存原理(sqlsession 级别)</h4><p>第一次发出一个查询sql，sql 查询结果写入sqlsession 的一级缓存中，缓存使用的数据结构是一个map。<br>key：MapperID+offset+limit+Sql+所有的入参<br>value：用户信息<br>同一个sqlsession 再次发出相同的sql，就从缓存中取出数据。如果两次中间出现commit 操作（修改、添加、删除），本sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。  </p><h4 id="二级缓存原理-mapper-基本"><a href="#二级缓存原理-mapper-基本" class="headerlink" title="二级缓存原理(mapper 基本)"></a>二级缓存原理(mapper 基本)</h4><p>二级缓存的范围是mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是map。mybatis 的二级缓存是通过CacheExecutor 实现的。CacheExecutor其实是Executor 的代理对象。所有的查询操作，在CacheExecutor 中都会先匹配缓存中是否存在，不存在则查询数据库。<br>key：MapperID+offset+limit+Sql+所有的入参<br>具体使用需要配置：  </p><ol><li>Mybatis 全局配置中启用二级缓存配置</li><li>在对应的Mapper.xml 中配置cache 节点</li><li>在对应的select 查询节点中添加useCache=true</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spring是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是Spring仍然可以和其他的框架无缝整合。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="https://www.shado.com.cn/categories/spring/"/>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="spring" scheme="https://www.shado.com.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java CPU 100%排查问题与解决</title>
    <link href="https://www.shado.com.cn/2018/06/07/2018-06-07-java-cpu-100-resolve/"/>
    <id>https://www.shado.com.cn/2018/06/07/2018-06-07-java-cpu-100-resolve/</id>
    <published>2018-06-07T02:28:44.000Z</published>
    <updated>2019-06-24T09:47:15.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记一次线上服务器Java程序CPU 100%排查问题与解决<br><a id="more"></a></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>首先用top命令查看当前占用CPU高的进程(PID)<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mingdong<span class="variable">@VM_45_31_centos</span> V2]<span class="variable">$ </span>top</span><br></pre></td></tr></table></figure></p><p>小写键盘的情况下，<code>Shift+P</code>键按照CPU占用由高到低排序<br>打开大写键盘的情况下，直接按<code>P</code>键<br><img src="/2018/06/07/2018-06-07-java-cpu-100-resolve/linux-top-cpu-sort.png" alt="top命令"></p><blockquote><p>top命令</p></blockquote><p>可以看到占用CPU最高的进程PID是30672<br>然后通过<code>top -Hp 30672</code>查看每个线程占用的CPU情况<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mingdong<span class="variable">@VM_45_31_centos</span> V2]<span class="variable">$ </span>top -Hp <span class="number">30672</span></span><br></pre></td></tr></table></figure></p><p>然后可以看到占用CPU最高的线程tid是30679<br>得到tid之后再将tid转化为16进制<code>30679</code>转化为16进制就是<code>0x77d7</code><br>用<code>jstack PID</code>查看java虚拟机的堆栈情况<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mingdong<span class="variable">@VM_45_31_centos</span> V2]<span class="variable">$ </span>jstack <span class="number">30672</span></span><br></pre></td></tr></table></figure></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Reference Handler"</span> #2 daemon <span class="attribute">prio</span>=10 <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8114000 <span class="attribute">nid</span>=0x77d8 <span class="keyword">in</span> Object.wait() [0x00007fe9df6a1000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">- locked &lt;0x00000000fc0067d0&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.<span class="builtin-name">run</span>(Reference.java:153)</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d810a000 <span class="attribute">nid</span>=0x77d7 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#0 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d801a800 <span class="attribute">nid</span>=0x77d2 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#1 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d801c800 <span class="attribute">nid</span>=0x77d3 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#2 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d801e000 <span class="attribute">nid</span>=0x77d4 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#3 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8020000 <span class="attribute">nid</span>=0x77d5 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Concurrent Mark-Sweep GC Thread"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8063000 <span class="attribute">nid</span>=0x77d6 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8162000 <span class="attribute">nid</span>=0x77e0 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 1281</span><br></pre></td></tr></table></figure><p>可以看到nid=0x77d7是GC所在的线程, 原因是Parallel GC线程频繁Full GC导致CPU跑到100%。</p><p>再review代码，发现是有一段代码中的WebSocket发生异常时未关闭，导致内存泄露，频繁Full GC，最终CPU跑得太高。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记一次线上服务器Java程序CPU 100%排查问题与解决&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.shado.com.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="linux" scheme="https://www.shado.com.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://www.shado.com.cn/2018/03/17/2018-03-17-java-virtual-machine/"/>
    <id>https://www.shado.com.cn/2018/03/17/2018-03-17-java-virtual-machine/</id>
    <published>2018-03-17T14:11:16.000Z</published>
    <updated>2019-06-18T07:44:33.704Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JVM是可运行Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。<br><a id="more"></a><br><img src="/2018/03/17/2018-03-17-java-virtual-machine/jvm.jpg" alt="jvm"></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>我们都知道Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过Java 虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：<br>① Java 源文件—-&gt;编译器—-&gt;字节码文件<br>② 字节码文件—-&gt;JVM—-&gt;机器码<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java 为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h3><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class 文件获取，这里既可以从ZIP 包中读取（比如从jar 包和war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP 文件转换成对应的Class 类）。</p><h3 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证(Verification)"></a>验证(Verification)</h3><p>这一阶段的主要目的是为了确保Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>实际上变量v 在准备阶段过后的初始值为0 而不是8080，将v 赋值为8080 的put static 指令是程序被编译后，存放于类构造器<client>方法之中。</client></p><p>但是注意如果声明为：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>在编译阶段会为v 生成ConstantValue 属性，在准备阶段虚拟机会根据ConstantValue 属性将v赋值为8080。</p><h3 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class 文件中的：</p><ol><li>CONSTANT_Class_info</li><li>CONSTANT_Field_info</li><li>CONSTANT_Method_info等类型的常量。</li></ol><h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java 虚拟机规范的Class 文件格式中。</p><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p><h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h3><h4 id="类构造器"><a href="#类构造器" class="headerlink" title="类构造器"></a>类构造器<client></client></h4><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></p><p>注意以下几种情况不会执行类初始化：</p><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触<br>发定义常量所在的类。</li><li>通过类名获取Class 对象，不会触发类的初始化。</li><li>通过Class.forName 加载指定类时，如果指定参数initialize 为false 时，也不会触发类初<br>始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过ClassLoader 默认的loadClass 方法，也不会触发初始化动作。</li></ol><h3 id="使用-Using"><a href="#使用-Using" class="headerlink" title="使用(Using)"></a>使用(Using)</h3><h3 id="卸载-Unloading"><a href="#卸载-Unloading" class="headerlink" title="卸载(Unloading)"></a>卸载(Unloading)</h3><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了3 种类加载器：</p><h4 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</p><h4 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs 系统变量指定路径中的类库。</p><h4 id="应用程序类加载器-Application-ClassLoader"><a href="#应用程序类加载器-Application-ClassLoader" class="headerlink" title="应用程序类加载器(Application ClassLoader)"></a>应用程序类加载器(Application ClassLoader)</h4><p>负责加载用户路径（classpath）上的类库。<br>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/bootstrap-classloader.jpg" alt="启动类加载器"></p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p><p>采用双亲委派的一个好处是比如加载位于rt.jar 包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object 对象。<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/delegation-model.jpg" alt="双亲委派"></p><h3 id="OSGI-动态模型系统"><a href="#OSGI-动态模型系统" class="headerlink" title="OSGI(动态模型系统)"></a>OSGI(动态模型系统)</h3><p>OSGi(Open Service Gateway Initiative)，是面向Java 的动态模型系统，是Java 动态化模块化系统的一系列规范。</p><h4 id="动态改变构造"><a href="#动态改变构造" class="headerlink" title="动态改变构造"></a>动态改变构造</h4><p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。</p><h4 id="模块化编程与热插拔"><a href="#模块化编程与热插拔" class="headerlink" title="模块化编程与热插拔"></a>模块化编程与热插拔</h4><p>OSGi 旨在为实现Java 程序的模块化编程提供基础条件，基于OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。</p><p>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="/2018/03/17/2018-03-17-java-virtual-machine/java-memory-model.jpg" alt="JVM内存模型"><br>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。</p><p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在HotspotVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p><p>线程共享区域随虚拟机的启动/关闭而创建/销毁。</p><p>直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4 引入的NIO 提供了基于Channel 与Buffer 的IO 方式, 它可以使用Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在Java堆和Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/java-memory-model-2.jpg" alt="JVM内存模型"></p><h3 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h3><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</p><p>正在执行java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是Native 方法，则为空。</p><p>这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError 情况的区域。</p><h3 id="虚拟机栈-线程私有"><a href="#虚拟机栈-线程私有" class="headerlink" title="虚拟机栈(线程私有)"></a>虚拟机栈(线程私有)</h3><p>是描述java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>栈帧(Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接</p><p>(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/stack-frame.jpg" alt="栈帧"></p><h3 id="本地方法区-线程私有"><a href="#本地方法区-线程私有" class="headerlink" title="本地方法区(线程私有)"></a>本地方法区(线程私有)</h3><p>本地方法区和Java Stack 作用类似, 区别是虚拟机栈为执行Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个VM 实现使用C-linkage 模型来支持Native 调用, 那么该栈将会是一个C 栈，但HotSpot VM直接就把本地方法栈和虚拟机栈合二为一。</p><h3 id="堆-Heap-线程共享-运行时数据区"><a href="#堆-Heap-线程共享-运行时数据区" class="headerlink" title="堆(Heap-线程共享)-运行时数据区"></a>堆(Heap-线程共享)-运行时数据区</h3><p>是被线程共享的一块内存区域，创建的对象和数组都保存在Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM 采用分代收集算法, 因此Java 堆从GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和To Survivor 区)和老年代。</p><h3 id="方法区-永久代-线程共享"><a href="#方法区-永久代-线程共享" class="headerlink" title="方法区/永久代(线程共享)"></a>方法区/永久代(线程共享)</h3><p>即我们常说的永久代(Permanent Generation), 用于存储被JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样HotSpot 的垃圾收集器就可以像管理Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。</p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><h2 id="JVM运行时内存"><a href="#JVM运行时内存" class="headerlink" title="JVM运行时内存"></a>JVM运行时内存</h2><p>Java 堆从GC 的角度还可以细分为: 新生代(Eden 区、From Survivor 区和To Survivor 区)和老年代。<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/heap.jpg" alt="堆"></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>是用来存放新生的对象。一般占据堆的1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。</p><h4 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h4><p>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden 区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</p><h4 id="SurvivorFrom"><a href="#SurvivorFrom" class="headerlink" title="SurvivorFrom"></a>SurvivorFrom</h4><p>上一次GC 的幸存者，作为这一次GC 的被扫描者</p><h4 id="SurvivorTo"><a href="#SurvivorTo" class="headerlink" title="SurvivorTo"></a>SurvivorTo</h4><p>保留了一次MinorGC 过程中的幸存者。</p><h4 id="MinorGC的过程-复制-gt-清空-gt-互换"><a href="#MinorGC的过程-复制-gt-清空-gt-互换" class="headerlink" title="MinorGC的过程(复制-&gt;清空-&gt;互换)"></a>MinorGC的过程(复制-&gt;清空-&gt;互换)</h4><p>MinorGC 采用复制算法。  因为新生代存活率低，适合复制算法</p><p>(1)eden、survivorFrom复制到SurvivorTo，年龄+1<br>首先，把Eden 和SurvivorFrom区域中存活的对象复制到SurvivorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果SurvivorTo 不够位置了就放到老年区)  </p><p>(2)清空eden、SurvivorFrom<br>然后，清空Eden 和SurvivorFrom 中的对象；  </p><p>(3)SurvivorTo 􀪼 SurvivorFrom互换<br>最后，SurvivorTo 和SurvivorFrom 互换，原SurvivorTo 成为下一次GC 时的SurvivorFrom。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>主要存放应用程序中生命周期长的内存对象。</p><p>老年代的对象比较稳定，所以MajorGC 不会频繁执行。在进行MajorGC 前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC 进行垃圾回收腾出空间。</p><p>MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>指内存的永久保存区域，主要存放Class 和Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class 的增多而胀满，最终抛出OOM异常。</p><h4 id="Java8与元数据"><a href="#Java8与元数据" class="headerlink" title="Java8与元数据"></a>Java8与元数据</h4><p>在Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 nativememory, 字符串池和类的静态变量放入java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p><h2 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h2><p><img src="/2018/03/17/2018-03-17-java-virtual-machine/gc.jpg" alt="GC"></p><h3 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以被回收。每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1。任何引用计数为0的对象实例可以被当作垃圾收集。<br><strong>优点：</strong><br>执行效率高，程序执行受影响较小</p><p><strong>缺点：</strong><br>无法检测出循环引用，导致内存泄露</p><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。<br>要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。<br><strong>可以作为GC Root的对象</strong></p><ol><li>虚拟机栈中引用的对象（栈帧中的本地变量表)</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中JNI(Native方法)的引用对象</li><li>活跃线程的引用对象</li></ol><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除算法-Mark-Sweep"><a href="#标记清除算法-Mark-Sweep" class="headerlink" title="标记清除算法(Mark-Sweep)"></a>标记清除算法(Mark-Sweep)</h4><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/mark-sweep.jpg" alt="Mark-Sweep"><br>从图中我们就可以发现，该算法 <strong>最大的问题</strong> 是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/copying.jpg" alt="Copying"><br><strong>优点：</strong></p><ol><li>解决碎片化问题</li><li>顺序分配内存，简单高效</li><li>使用于对象存活率低的场景</li></ol><p><strong>缺点：</strong></p><ol><li>可用内存被压缩为原来的一般</li><li>存活对象多的情况下效率低</li></ol><p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p><h4 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h4><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/mark-compact.jpg" alt="Mark-Compact"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集法是目前大部分JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><h5 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h5><p>Minor GC<br>目前大部分JVM的GC 对于新生代都采取Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1 来划分新生代。一般将新生代划分为一块较大的Eden 空间和两个较小的Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor 空间中。<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/young-generation-copying.jpg" alt="Mark-Compact"></p><h5 id="老年代与标记整理算法"><a href="#老年代与标记整理算法" class="headerlink" title="老年代与标记整理算法"></a>老年代与标记整理算法</h5><p>MajorGC/Full GC<br>而老年代因为每次只回收少量对象，因而采用Mark-Compact 算法。</p><ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class 类，<br>常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li><li>对象的内存分配主要在新生代的Eden Space 和Survivor Space 的From Space(Survivor 目<br>前存放对象的那一块)，少数情况会直接分配到老生代。</li><li>当新生代的Eden Space 和From Space 空间不足时就会发生一次GC，进行GC 后，Eden<br>Space 和From Space 区的存活对象会被挪到To Space，然后将Eden Space 和From<br>Space 进行清理。</li><li>如果To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li><li>在进行GC 后，使用的便是Eden Space 和To Space 了，如此反复循环。</li><li>当对象在Survivor 区躲过一次GC 后，其年龄就会+1。默认情况下年龄到达15 的对象会被<br>移到老生代中。</li></ol><p><strong>触发Full GC的条件</strong></p><ol><li>老年代空间不足</li><li>永久代空间不足(JDK1.8前,1.8后永久代换成了元空间MetaSpace)</li><li>调用System.gc()</li><li>CMS GC时出现promotion failed, concurrent mode failure</li><li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li><li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li></ol><h2 id="Java四种引用类型"><a href="#Java四种引用类型" class="headerlink" title="Java四种引用类型"></a>Java四种引用类型</h2><h3 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h3><p>在Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java 内存泄漏的主要原因之一。通过将对象设置为null来弱化引用，使其可被回收。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();  <span class="comment">// Strong Reference</span></span><br><span class="line">obj = <span class="keyword">null</span>;                 <span class="comment">// help gc</span></span><br></pre></td></tr></table></figure></p><h3 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h3><p>软引用需要用SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。<br>可以用来实现高速缓存。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"abc"</span>);       <span class="comment">// Strong Reference</span></span><br><span class="line">SoftReference&lt;<span class="keyword">String</span>&gt; softRef = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="built_in">str</span>);   <span class="comment">// Soft Reference</span></span><br></pre></td></tr></table></figure></p><h3 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h3><p>弱引用需要用WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制扫描到弱引用对象，不管JVM 的内存空间是否足够，总会回收该对象占用的内存。<br>适用于偶尔被使用且不影响垃圾收集的对象。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"abc"</span>);       <span class="comment">// Strong Reference</span></span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="built_in">str</span>);   <span class="comment">// Weak Reference</span></span><br></pre></td></tr></table></figure></p><h3 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference)"></a>虚引用(Phantom Reference)</h3><p>虚引用需要PhantomReference 类来实现，任何适合都可能被垃圾收集器回收，它不能单独使用，必须和引用队列(ReferenceQueue)联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态，起哨兵作用。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> str = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">"abc"</span>);       <span class="comment">// Strong Reference</span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>();</span><br><span class="line">PhantomReference&lt;<span class="keyword">String</span>&gt; ref = <span class="keyword">new</span> <span class="type">PhantomReference</span>&lt;&gt;(str,queue);   <span class="comment">// Phantom Reference</span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">引用类型</th><th style="text-align:center">被垃圾回收时间</th><th style="text-align:center">用途</th><th style="text-align:center">生存时间</th></tr></thead><tbody><tr><td style="text-align:center">强引用</td><td style="text-align:center">从来不会</td><td style="text-align:center">对象的一般状态</td><td style="text-align:center">JVM停止运行时终止</td></tr><tr><td style="text-align:center">软引用</td><td style="text-align:center">内存不足时</td><td style="text-align:center">对象缓存</td><td style="text-align:center">内存不足时终止</td></tr><tr><td style="text-align:center">弱引用</td><td style="text-align:center">垃圾回收时</td><td style="text-align:center">对象缓存</td><td style="text-align:center">gc运行后终止</td></tr><tr><td style="text-align:center">虚引用</td><td style="text-align:center">Unknown</td><td style="text-align:center">标记、哨兵</td><td style="text-align:center">Unknown</td></tr></tbody></table><h2 id="GC分代收集算法VS分区收集算法"><a href="#GC分代收集算法VS分区收集算法" class="headerlink" title="GC分代收集算法VS分区收集算法"></a>GC分代收集算法VS分区收集算法</h2><h3 id="分代收集算法-1"><a href="#分代收集算法-1" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的GC 算法</p><h4 id="在新生代-复制算法"><a href="#在新生代-复制算法" class="headerlink" title="在新生代-复制算法"></a>在新生代-复制算法</h4><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。</p><h4 id="在老年代-标记整理算法"><a href="#在老年代-标记整理算法" class="headerlink" title="在老年代-标记整理算法"></a>在老年代-标记整理算法</h4><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。</p><h3 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h3><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次GC 所产生的停顿。</p><h2 id="GC垃圾收集器"><a href="#GC垃圾收集器" class="headerlink" title="GC垃圾收集器"></a>GC垃圾收集器</h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中Sun HotSpot 虚拟机的垃圾收集器如下：<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/gc-collector.jpg" alt="GC-Collector"></p><h3 id="Serial收集器-单线程、复制算法-XX-UseSerialGC"><a href="#Serial收集器-单线程、复制算法-XX-UseSerialGC" class="headerlink" title="Serial收集器(单线程、复制算法 -XX:+UseSerialGC)"></a>Serial收集器(单线程、复制算法 -XX:+UseSerialGC)</h3><p>Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。<br>Serial 是一个单线程的收集器，它不但只会使用一个CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。<br>Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，收集时间一般在几十毫秒左右，对于限定单个CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java 虚拟机运行在<strong>Client 模式下默认的新生代垃圾收集器</strong>。</p><h3 id="ParNew收集器-Serial-多线程-XX-UseParNewGC"><a href="#ParNew收集器-Serial-多线程-XX-UseParNewGC" class="headerlink" title="ParNew收集器(Serial+多线程 -XX:+UseParNewGC)"></a>ParNew收集器(Serial+多线程 -XX:+UseParNewGC)</h3><p>ParNew 垃圾收集器其实是Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。<br>ParNew 收集器默认开启和CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】<br>ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在<strong>Server 模式下新生代的默认垃圾收集器</strong>。</p><h3 id="Parallel-Scavenge收集器-多线程复制算法、高效-XX-UseParallelGC"><a href="#Parallel-Scavenge收集器-多线程复制算法、高效-XX-UseParallelGC" class="headerlink" title="Parallel Scavenge收集器(多线程复制算法、高效 -XX:+UseParallelGC)"></a>Parallel Scavenge收集器(多线程复制算法、高效 -XX:+UseParallelGC)</h3><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略(-XX:+UseAdaptiveSizePolicy)也是ParallelScavenge 收集器与ParNew 收集器的一个重要区别。Parallel Scavenge是java虚拟机运行在<strong>Server 模式下年轻代的默认垃圾收集器</strong>。</p><h3 id="Serial-Old收集器-单线程标记整理算法-XX-UseSerialOldGC"><a href="#Serial-Old收集器-单线程标记整理算法-XX-UseSerialOldGC" class="headerlink" title="Serial Old收集器(单线程标记整理算法 -XX:+UseSerialOldGC)"></a>Serial Old收集器(单线程标记整理算法 -XX:+UseSerialOldGC)</h3><p>Serial Old 是Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client 默认的java 虚拟机<strong>默认的年老代垃圾收集器。</strong></p><h3 id="Parallel-Old收集器-多线程标记整理算法-XX-UseParallelOldGC"><a href="#Parallel-Old收集器-多线程标记整理算法-XX-UseParallelOldGC" class="headerlink" title="Parallel Old收集器(多线程标记整理算法 -XX:+UseParallelOldGC)"></a>Parallel Old收集器(多线程标记整理算法 -XX:+UseParallelOldGC)</h3><p>Parallel Old 收集器是Parallel Scavenge 的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。<br>在JDK1.6 之前，新生代使用ParallelScavenge 收集器只能搭配年老代的Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old 收集器的搭配策略。</p><h3 id="CMS收集器-多线程标记清除算法"><a href="#CMS收集器-多线程标记清除算法" class="headerlink" title="CMS收集器(多线程标记清除算法)"></a>CMS收集器(多线程标记清除算法)</h3><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。<br>最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。<br>CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下阶段：<br><img src="/2018/03/17/2018-03-17-java-virtual-machine/cms-collector.jpg" alt="CMS-Collector"></p><h4 id="初始标记（CMS-initial-mark-Stop-The-World"><a href="#初始标记（CMS-initial-mark-Stop-The-World" class="headerlink" title="初始标记（CMS initial mark)(Stop The World)"></a>初始标记（CMS initial mark)(Stop The World)</h4><p>暂停所有工作线程</p><h4 id="并发标记（CMS-concurrent-mark）"><a href="#并发标记（CMS-concurrent-mark）" class="headerlink" title="并发标记（CMS concurrent mark）"></a>并发标记（CMS concurrent mark）</h4><p>并发追溯标记，程序不会停顿</p><h4 id="并发预清理（CMS-concurrent-preclean"><a href="#并发预清理（CMS-concurrent-preclean" class="headerlink" title="并发预清理（CMS-concurrent-preclean)"></a>并发预清理（CMS-concurrent-preclean)</h4><p>查找执行并发标记阶段从年轻代晋升到老年代的对象</p><h4 id="重新标记（CMS-remark-Stop-The-World"><a href="#重新标记（CMS-remark-Stop-The-World" class="headerlink" title="重新标记（CMS remark)(Stop The World)"></a>重新标记（CMS remark)(Stop The World)</h4><p>暂停虚拟机，扫描CMS堆中的剩余对象</p><h4 id="并发清除（CMS-concurrent-sweep"><a href="#并发清除（CMS-concurrent-sweep" class="headerlink" title="并发清除（CMS concurrent sweep)"></a>并发清除（CMS concurrent sweep)</h4><p>清理垃圾对象，和用户线程一起工作，程序不会停顿</p><h4 id="并发重置（CMS-concurrent-reset"><a href="#并发重置（CMS-concurrent-reset" class="headerlink" title="并发重置（CMS-concurrent-reset)"></a>并发重置（CMS-concurrent-reset)</h4><p>重置CMS收集器的数据结构</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>Garbage First 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，可用于年轻代、老年代，G1 收集器优点是：  </p><ol><li>并行和并发</li><li>分代收集</li><li>基于标记-整理算法，不产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ol><p>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1 收集器可以在有限时间获得最高的垃圾收集效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;JVM是可运行Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://www.shado.com.cn/categories/jvm/"/>
    
    
      <category term="JVM" scheme="https://www.shado.com.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next主题配置</title>
    <link href="https://www.shado.com.cn/2018/02/22/2018-02-22-hexo-next-setting/"/>
    <id>https://www.shado.com.cn/2018/02/22/2018-02-22-hexo-next-setting/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2019-06-18T08:22:03.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-搜索功能"><a href="#1-搜索功能" class="headerlink" title="1. 搜索功能"></a>1. 搜索功能</h2><h3 id="1-1-在Hexo根目录下执行-npm-install-hexo-generator-searchdb-–save"><a href="#1-1-在Hexo根目录下执行-npm-install-hexo-generator-searchdb-–save" class="headerlink" title="1.1. 在Hexo根目录下执行 npm install hexo-generator-searchdb –save"></a>1.1. 在Hexo根目录下执行 npm install hexo-generator-searchdb –save</h3><h3 id="1-2-blog下的-config-yml文件编辑"><a href="#1-2-blog下的-config-yml文件编辑" class="headerlink" title="1.2. blog下的_config.yml文件编辑"></a>1.2. blog下的_config.yml文件编辑</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="1-3-blog-themes-next下的-config-yml文件编辑"><a href="#1-3-blog-themes-next下的-config-yml文件编辑" class="headerlink" title="1.3. /blog/themes/next下的_config.yml文件编辑"></a>1.3. /blog/themes/next下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2-RSS订阅"><a href="#2-RSS订阅" class="headerlink" title="2. RSS订阅"></a>2. RSS订阅</h2><h3 id="2-1-在Hexo根目录下执行-npm-install-hexo-generator-feed-–save"><a href="#2-1-在Hexo根目录下执行-npm-install-hexo-generator-feed-–save" class="headerlink" title="2.1. 在Hexo根目录下执行 npm install hexo-generator-feed –save"></a>2.1. 在Hexo根目录下执行 npm install hexo-generator-feed –save</h3><h3 id="2-2-blog下的-config-yml文件编辑"><a href="#2-2-blog下的-config-yml文件编辑" class="headerlink" title="2.2. blog下的_config.yml文件编辑"></a>2.2. blog下的_config.yml文件编辑</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># RSS订阅</span></span><br><span class="line"><span class="symbol">plugin:</span></span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line"><span class="meta"># RSS</span></span><br><span class="line"><span class="symbol">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom</span><br><span class="line"><span class="symbol">  path:</span> atom.xml</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="2-3-blog-themes-next下的-config-yml文件编辑"><a href="#2-3-blog-themes-next下的-config-yml文件编辑" class="headerlink" title="2.3. /blog/themes/next下的_config.yml文件编辑"></a>2.3. /blog/themes/next下的_config.yml文件编辑</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rss:</span> /atom.xml</span><br></pre></td></tr></table></figure><h2 id="发布到Github"><a href="#发布到Github" class="headerlink" title="发布到Github"></a>发布到Github</h2><h3 id="在Hexo根目录下执行-npm-install-–save-hexo-deployer-git"><a href="#在Hexo根目录下执行-npm-install-–save-hexo-deployer-git" class="headerlink" title="在Hexo根目录下执行 npm install –save hexo-deployer-git"></a>在Hexo根目录下执行 npm install –save hexo-deployer-git</h3><h3 id="自动关联域名-创建-Hexo根目录-source-CNAME-内容为域名，如：www-mingdong-online"><a href="#自动关联域名-创建-Hexo根目录-source-CNAME-内容为域名，如：www-mingdong-online" class="headerlink" title="自动关联域名 创建../Hexo根目录/source/CNAME 内容为域名，如：www.mingdong.online"></a>自动关联域名 创建../Hexo根目录/source/CNAME 内容为域名，如：<code>www.mingdong.online</code></h3><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><h2 id="文章字数统计和阅读时间统计"><a href="#文章字数统计和阅读时间统计" class="headerlink" title="文章字数统计和阅读时间统计"></a>文章字数统计和阅读时间统计</h2><h3 id="https-github-com-theme-next-hexo-symbols-count-time"><a href="#https-github-com-theme-next-hexo-symbols-count-time" class="headerlink" title="https://github.com/theme-next/hexo-symbols-count-time"></a><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a></h3><h3 id="在Hexo根目录下执行-npm-install-hexo-symbols-count-time-–save"><a href="#在Hexo根目录下执行-npm-install-hexo-symbols-count-time-–save" class="headerlink" title="在Hexo根目录下执行 npm install hexo-symbols-count-time –save"></a>在Hexo根目录下执行 npm install hexo-symbols-count-time –save</h3><h3 id="blog下的-config-yml文件编辑"><a href="#blog下的-config-yml文件编辑" class="headerlink" title="blog下的_config.yml文件编辑"></a>blog下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="博客中插入图片"><a href="#博客中插入图片" class="headerlink" title="博客中插入图片"></a>博客中插入图片</h2><h3 id="在Hexo根目录下执行-npm-install-hexo-asset-image-–save"><a href="#在Hexo根目录下执行-npm-install-hexo-asset-image-–save" class="headerlink" title="在Hexo根目录下执行 npm install hexo-asset-image –save"></a>在Hexo根目录下执行 npm install hexo-asset-image –save</h3><h3 id="blog下的-config-yml文件编辑-1"><a href="#blog下的-config-yml文件编辑-1" class="headerlink" title="blog下的_config.yml文件编辑"></a>blog下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><h3 id="https-github-com-EYHN-hexo-helper-live2d-blob-master-README-md"><a href="#https-github-com-EYHN-hexo-helper-live2d-blob-master-README-md" class="headerlink" title="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md"></a><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md</a></h3><h3 id="安装live2d-在Hexo根目录下执行-npm-install-–save-hexo-helper-live2d"><a href="#安装live2d-在Hexo根目录下执行-npm-install-–save-hexo-helper-live2d" class="headerlink" title="安装live2d 在Hexo根目录下执行 npm install –save hexo-helper-live2d"></a>安装live2d 在Hexo根目录下执行 npm install –save hexo-helper-live2d</h3><h3 id="安装模块包-在Hexo根目录下执行-npm-install-packagename-如-npm-install-live2d-widget-model-wanko"><a href="#安装模块包-在Hexo根目录下执行-npm-install-packagename-如-npm-install-live2d-widget-model-wanko" class="headerlink" title="安装模块包 在Hexo根目录下执行 npm install {packagename} 如:npm install live2d-widget-model-wanko"></a>安装模块包 在Hexo根目录下执行 npm install {packagename} 如:npm install live2d-widget-model-wanko</h3><h3 id="blog下的-config-yml文件编辑-2"><a href="#blog下的-config-yml文件编辑-2" class="headerlink" title="blog下的_config.yml文件编辑"></a>blog下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br></pre></td></tr></table></figure><h2 id="aplayer"><a href="#aplayer" class="headerlink" title="aplayer"></a>aplayer</h2><h3 id="https-github-com-MoePlayer-hexo-tag-aplayer"><a href="#https-github-com-MoePlayer-hexo-tag-aplayer" class="headerlink" title="https://github.com/MoePlayer/hexo-tag-aplayer"></a><a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">https://github.com/MoePlayer/hexo-tag-aplayer</a></h3><h3 id="在Hexo根目录下执行-npm-install-–save-hexo-tag-aplayer"><a href="#在Hexo根目录下执行-npm-install-–save-hexo-tag-aplayer" class="headerlink" title="在Hexo根目录下执行 npm install –save hexo-tag-aplayer"></a>在Hexo根目录下执行 npm install –save hexo-tag-aplayer</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id><a href="#" class="headerlink" title></a><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found ([picture_url,)");</script></h4><ul><li>title : 曲目标题</li><li>author: 曲目作者</li><li>url: 音乐文件 URL 地址</li><li>picture_url: (可选) 音乐对应的图片地址</li><li>narrow: （可选）播放器袖珍风格</li><li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li><li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li><li>lrc:xxx: （可选）歌词文件 URL 地址<br>当开启 Hexo 的 文章资源文件夹<code>post_asset_folder: true</code> 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用：</li></ul><p><code><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found (picture.jpg)");</script></code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="博客" scheme="https://www.shado.com.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://www.shado.com.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Next" scheme="https://www.shado.com.cn/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>MySQL加强</title>
    <link href="https://www.shado.com.cn/2017/10/22/2017-10-22-mysql-plus/"/>
    <id>https://www.shado.com.cn/2017/10/22/2017-10-22-mysql-plus/</id>
    <published>2017-10-22T14:13:23.000Z</published>
    <updated>2019-06-14T02:36:25.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>海量数据全表扫描慢，快速查询数据</p><h2 id="什么信息能成为索引"><a href="#什么信息能成为索引" class="headerlink" title="什么信息能成为索引"></a>什么信息能成为索引</h2><p>主键、唯一键</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><h3 id="B-Tree-MySQL"><a href="#B-Tree-MySQL" class="headerlink" title="B+-Tree(MySQL)"></a>B+-Tree(MySQL)</h3><ol><li>有m个子树的节点包含有m个元素（B-Tree中是m-1）</li><li>所有叶子节点之间都有一个链指针指向下一个节点。</li><li>根节点和分支节点中不保存数据，只用于索引，所有数据都保存在叶子节点中。</li><li>所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。</li></ol><p><strong>优点：</strong></p><ol><li>磁盘读写代价更低</li><li>查询效率更加稳定</li><li>更有利于对数据库的扫描<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3>效率高</li></ol><p><strong>缺点</strong></p><ol><li>Hash索引比较的是Hash算法后的Hash值</li><li>只能做等值确定，仅仅能满足”=”，”IN”，不能使用范围查询</li><li>无法用于数据排序操作</li><li>不能利用部分索引键查询</li><li>不能避免表扫描</li><li>大量Hash值相等的情况性能可能更低</li></ol><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>Oracle数据库使用</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="密集索引"><a href="#密集索引" class="headerlink" title="密集索引"></a>密集索引</h3><p>密集索引文件中的每一个索引码值都对应一个索引值，决定表的排列顺序</p><h3 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h3><p>稀疏索引文件只为索引码的某些值建立索引项，叶子结点仅键位信息及其主键，定位到叶子结点还要进一步才能定位到信息</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>稀疏索引</p><p>索引和数据分开存储<br>索引: <em>.MYI<br>数据: </em>.MYD</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>密集索引</p><p>若一个主键被定义，该主键则作为密集索引<br>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引<br>若不满足以上条件，InnoDB内存会生成一个隐藏主键（密集索引）<br>非主键索引存储相关键位和其对应的主键值，包含两次查找</p><p>索引和数据共同存储: *.ibd</p><h2 id="索引的问题"><a href="#索引的问题" class="headerlink" title="索引的问题"></a>索引的问题</h2><h3 id="如何定位并优化慢查询Sql"><a href="#如何定位并优化慢查询Sql" class="headerlink" title="如何定位并优化慢查询Sql"></a>如何定位并优化慢查询Sql</h3><h4 id="根据慢日志定位慢查询sql"><a href="#根据慢日志定位慢查询sql" class="headerlink" title="根据慢日志定位慢查询sql"></a>根据慢日志定位慢查询sql</h4><p>show variable like ‘%quer%’;    // 查看慢查询日志是否开启<br>show status like ‘%slow_queries%’;  // 查询慢sql语句次数<br>set global slow_query_log = on; // 打开慢查询日志<br>set global long_query_time = 1; // 设置列入慢查询的超时时间，1秒</p><h4 id="使用explain等工具分析Sql"><a href="#使用explain等工具分析Sql" class="headerlink" title="使用explain等工具分析Sql"></a>使用explain等工具分析Sql</h4><p>explain +  select …</p><ol><li>type index&gt;all 表示全表扫描，需要优化sql</li><li>extra  Using filesort:外部文件索引排序，不是通过构建的索引，远慢于索引, Using temporary，对查询结果排序时使用临时表，常见于order by，group by，这两个需要优化<h4 id="修改sql或者让sql走索引"><a href="#修改sql或者让sql走索引" class="headerlink" title="修改sql或者让sql走索引"></a>修改sql或者让sql走索引</h4>1.添加PRIMARY KEY（主键索引）<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD PRIMARY KEY ( <code>column</code> )<br>2.添加UNIQUE(唯一索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD UNIQUE (<br><code>column</code><br>)<br>3.添加INDEX(普通索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column</code> )<br>4.添加FULLTEXT(全文索引)<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD FULLTEXT ( <code>column</code>)<br>5.添加多列索引<br>mysql&gt;ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code> )</li></ol><h3 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h3><ol><li>最左前缀匹配原则，mysql会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like)就停止匹配，比如a=3 and b=4 c&gt;5 and d=6 如果简历(a,b,c,d)顺序的索引,d是用不到索引的，如果简历(a,b,d,c)索引则都可以用到，a,b,d的顺序可以任意调整。</li><li><strong>=和in可以乱序</strong>，比如a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ol><h4 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h4><p>结合MySQL的B+Tree结构，最左的索引在根节点，之后的索引都是非根节点，直接查找非根节点不通过根节点无法直接到达叶子结点，只能全表扫描。<br>通过B+Tree的结构索引查找，只能从根节点往子节点最后查找到叶子结点。</p><h3 id="索引越多越好吗"><a href="#索引越多越好吗" class="headerlink" title="索引越多越好吗"></a>索引越多越好吗</h3><ol><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，更多的索引需要更多维护成本</li><li>更多的索引需要更多的空间</li></ol><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><ol><li><p>条件中用or，即使其中有条件带索引，也不会使用索引查询（这就是查询尽量不要用or的原因，用in吧）<br>注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p></li><li><p>对于多列索引，不是使用的第一部分，则不会使用索引</p></li><li><p>like查询是以%开头</p></li><li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</p></li><li><p>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</p></li></ol><h1 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h1><h2 id="MyISAM与InnoDB关于锁方面的区别"><a href="#MyISAM与InnoDB关于锁方面的区别" class="headerlink" title="MyISAM与InnoDB关于锁方面的区别"></a>MyISAM与InnoDB关于锁方面的区别</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ol><li>按锁的粒度划分，可分为表级锁、行级锁、页级锁</li><li>按锁级别划分，可分为共享锁、排他锁</li><li>按加锁方式划分，可分为自动锁、显示锁</li><li>按操作划分，可分为DML锁（增删改）、DDL锁（表结构改变，ALTER）</li><li>按使用方式划分，可分为乐观锁、悲观锁<h3 id="MyISAM默认用的是表级锁，不支持行级锁"><a href="#MyISAM默认用的是表级锁，不支持行级锁" class="headerlink" title="MyISAM默认用的是表级锁，不支持行级锁"></a>MyISAM默认用的是表级锁，不支持行级锁</h3>锁住整张表</li></ol><p>读锁：共享锁<br>lock tables <code>table_name</code> read;</p><p>写锁：排他锁</p><h3 id="InnoDB默认用的是行级锁，也支持表级锁"><a href="#InnoDB默认用的是行级锁，也支持表级锁" class="headerlink" title="InnoDB默认用的是行级锁，也支持表级锁"></a>InnoDB默认用的是行级锁，也支持表级锁</h3><p>默认支持事务，二段锁，加锁解锁，事务自动提交锁</p><p>不走索引的查询会锁住整张表，也就是表级锁<br>没有用到索引是表级锁，用到索引是行级锁</p><h2 id="MyISAM适合的场景"><a href="#MyISAM适合的场景" class="headerlink" title="MyISAM适合的场景"></a>MyISAM适合的场景</h2><p>频繁执行全表count语句，保存了一个表的行数<br>对数据进行增删改的频率不高，查询非常频繁<br>没有事务</p><h2 id="InnoDB适合的场景"><a href="#InnoDB适合的场景" class="headerlink" title="InnoDB适合的场景"></a>InnoDB适合的场景</h2><p>数据增删改查都相当频繁<br>可靠性要求比较高，要求支持事务</p><h1 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h1><p>⑴ 原子性（Atomicity）<br>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p>⑵ 一致性（Consistency）<br>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p><p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>⑶ 隔离性（Isolation）<br>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p><p>⑷ 持久性（Durability）<br>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><h1 id="MySQL事务的隔离级别"><a href="#MySQL事务的隔离级别" class="headerlink" title="MySQL事务的隔离级别"></a>MySQL事务的隔离级别</h1><h2 id="事务并发访问引起的问题"><a href="#事务并发访问引起的问题" class="headerlink" title="事务并发访问引起的问题"></a>事务并发访问引起的问题</h2><p>更新丢失–mysql所有事务可以避免</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>　　脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p><p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update account <span class="builtin-name">set</span> <span class="attribute">money</span>=money+100 where <span class="attribute">name</span>=’B’;  (此时A通知B)</span><br><span class="line"></span><br><span class="line">update account <span class="builtin-name">set</span> <span class="attribute">money</span>=money - 100 where <span class="attribute">name</span>=’A’;</span><br></pre></td></tr></table></figure></p><p>　　当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><p>　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p><p>　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>　　幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><p>　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><h2 id="MySQL的四种隔离级别"><a href="#MySQL的四种隔离级别" class="headerlink" title="MySQL的四种隔离级别"></a>MySQL的四种隔离级别</h2><h3 id="Read-Uncommitted-读未提交"><a href="#Read-Uncommitted-读未提交" class="headerlink" title="Read Uncommitted (读未提交)"></a>Read Uncommitted (读未提交)</h3><h3 id="Read-Committed-读已提交"><a href="#Read-Committed-读已提交" class="headerlink" title="Read Committed (读已提交)"></a>Read Committed (读已提交)</h3><h3 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read (可重复读)"></a>Repeatable Read (可重复读)</h3><h3 id="Serializable-串行化"><a href="#Serializable-串行化" class="headerlink" title="Serializable (串行化)"></a>Serializable (串行化)</h3><p>　　① <code>Read Uncommitted (读未提交)</code>：最低级别，任何情况都无法保证。</p><p>　　② <code>Read Committed (读已提交)</code>：可避免脏读的发生。</p><p>　　③ <code>Repeatable Read (可重复读)</code>：可避免脏读、不可重复读的发生。</p><p>　　④ <code>Serializable (串行化)</code>：可避免脏读、不可重复读、幻读的发生。</p><p>　　以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p><p>　　在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p><p>　　在MySQL数据库中查看当前事务的隔离级别：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="symbol">@tx_isolation</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>　　在MySQL数据库中设置事务的隔离 级别：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">set</span>  [glogal | <span class="keyword">session</span>]  <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名称;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> tx_isolation=’隔离级别名称;’</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @@tx_isolation;  // 查看mysql事务隔离级别</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommited;  // 设置mysql事务隔离级别</span><br></pre></td></tr></table></figure></p><h1 id="关键语法"><a href="#关键语法" class="headerlink" title="关键语法"></a>关键语法</h1><p>GROUP BY<br>HAVING<br>COUT<br>SUM<br>MAX<br>MIN<br>AVG</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="https://www.shado.com.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://www.shado.com.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存</title>
    <link href="https://www.shado.com.cn/2017/08/06/2017-08-06-cache-redis/"/>
    <id>https://www.shado.com.cn/2017/08/06/2017-08-06-cache-redis/</id>
    <published>2017-08-06T11:35:23.000Z</published>
    <updated>2019-06-06T07:50:31.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为啥在项目里要用缓存呢？"><a href="#为啥在项目里要用缓存呢？" class="headerlink" title="为啥在项目里要用缓存呢？"></a>为啥在项目里要用缓存呢？</h1><p>用缓存，主要是俩用途，高性能和高并发</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作mysql，半天查出来一个结果，耗时600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p><p>缓存啊，折腾600ms查出来的结果，扔缓存里，一个key对应一个value，下次再有人查，别走mysql折腾600ms了。直接从缓存里，通过一个key查出来一个value，2ms搞定。性能提升300倍。</p><p>这就是所谓的高性能。</p><p>就是把你一些复杂操作耗时查出来的结果，如果确定后面不咋变了，然后但是马上还有很多读请求，那么直接结果放缓存，后面直接读缓存就好了。</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>mysql这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql单机支撑到2000qps也开始容易报警了。</p><p>所以要是你有个系统，高峰期一秒钟过来的请求有1万，那一个mysql单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放mysql。缓存功能简单，说白了就是key-value式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发so easy。单机承载并发量是mysql单机的几十倍。</p><h1 id="用了缓存之后会有啥不良的后果"><a href="#用了缓存之后会有啥不良的后果" class="headerlink" title="用了缓存之后会有啥不良的后果"></a>用了缓存之后会有啥不良的后果</h1><p>1）缓存与数据库双写不一致<br>2）缓存雪崩<br>3）缓存穿透<br>4）缓存并发竞争</p><h1 id="redis和memcached有啥区别"><a href="#redis和memcached有啥区别" class="headerlink" title="redis和memcached有啥区别"></a>redis和memcached有啥区别</h1><p>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</p><p>集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持cluster模式的，redis官方就是支持redis cluster集群模式的，比memcached来说要更好</p><h1 id="redis单线程为什么会是高性能的"><a href="#redis单线程为什么会是高性能的" class="headerlink" title="redis单线程为什么会是高性能的"></a>redis单线程为什么会是高性能的</h1><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器，file event handler。这个文件事件处理器是单线程的，redis才叫做单线程的模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p><p>1）纯内存操作<br>2）核心是基于非阻塞的IO多路复用机制<br>3）单线程反而避免了多线程的频繁上下文切换问题<br>上下文切换会导致CPU在寄存器和运行队列之间来回奔波，CPU寄存器需要保存和加载, 系统调度器的代码需要执行。</p><h1 id="redis的数据类型"><a href="#redis的数据类型" class="headerlink" title="redis的数据类型"></a>redis的数据类型</h1><p>String<br>Hash<br>List<br>Set<br>Sorted set<br>pub/sub<br>Transactions</p><h1 id="redis的过期策略"><a href="#redis的过期策略" class="headerlink" title="redis的过期策略"></a>redis的过期策略</h1><h2 id="设置过期时间的删除方式"><a href="#设置过期时间的删除方式" class="headerlink" title="设置过期时间的删除方式"></a>设置过期时间的删除方式</h2><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果定期删除漏掉了很多过期key，然后也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽。内存淘汰机制可以防止上述情况的发生。</p><p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧</p><p>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</p><p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊</p><p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）</p><p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</p><p>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</p><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>利用已有的jdk数据结构实现一个java版的LRU<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LRUCache&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap&lt;K</span>, <span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> int <span class="type">CACHE_SIZE</span>;</span><br><span class="line">    <span class="comment">// 这里就是传递进来最多能缓存多少数据</span></span><br><span class="line">    public <span class="type">LRUCache</span>(int cacheSize) &#123;</span><br><span class="line">        <span class="keyword">super</span>((int) <span class="type">Math</span>.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75</span>f, <span class="literal">true</span>); <span class="comment">// 这块就是设置一个hashmap的初始大小，同时最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾</span></span><br><span class="line">        <span class="type">CACHE_SIZE</span> = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> boolean removeEldestEntry(<span class="type">Map</span>.<span class="type">Entry</span> eldest) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="type">CACHE_SIZE</span>; <span class="comment">// 这个意思就是说当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="redis高并发"><a href="#redis高并发" class="headerlink" title="redis高并发"></a>redis高并发</h1><p>主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。并且支持水平扩展，QPS高了只要加机器就可以</p><p>redis高并发的同时，还需要容纳大量的数据：一主多从，每个实例都容纳了完整的数据，比如redis主就10G的内存量，其实你就最对只能容纳10g的数据量。如果你的缓存要容纳的数据量很大，达到了几十g，甚至几百g，或者是几t，那你就需要redis集群，而且用redis集群之后，可以提供可能每秒几十万的读写并发。</p><h1 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h1><p>如果你做主从架构部署，其实就是加上哨兵就可以了，就可以实现，任何一个实例宕机，自动会进行主备切换。</p><h1 id="redis缓存一致性"><a href="#redis缓存一致性" class="headerlink" title="redis缓存一致性"></a>redis缓存一致性</h1><h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><h1 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h1><h1 id="redis-哨兵模式-Sentinel"><a href="#redis-哨兵模式-Sentinel" class="headerlink" title="redis 哨兵模式(Sentinel)"></a>redis 哨兵模式(Sentinel)</h1><p>解决主从同步Master宕机后的主从切换问题：<br>监控：检查主从服务器是否运行正常<br>提醒：通过api向管理员或者其他应用程序发送故障通知<br>自动故障迁移：主从切换</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃<br>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL被打死<br>事后：redis持久化，快速恢复缓存数据</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>黑客发送缓存和数据库里都不存在的数据，然后每次都会到数据库中查询，性能消耗很大。比如数据的id都是从1开始的，黑客的恶意请求id都是负数，请求到缓存中查不到，接着到数据库中查询，还是查不到，下次进行相同的请求也是会到数据库中查询。</p><p><strong>解决方案：</strong></p><ol><li>对id先进行校验，不符合规则的id直接返回</li><li>将黑客的查询id也放入缓存中，key为id,value为空。</li></ol><h1 id="缓存与数据的双写一致性"><a href="#缓存与数据的双写一致性" class="headerlink" title="缓存与数据的双写一致性"></a>缓存与数据的双写一致性</h1><p>不管是先写库，再删除缓存；还是先删缓存，再写库，都有可能出现数据不一致的情况</p><p>　　因为写和读是并发的，没法保证顺序，如果删了缓存，还没有来得及写库，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。如果先写了库，再删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 如果是redis集群，或者主从模式，写主读从，由于redis复制存在一定的时间延迟，也有可能导致数据不一致。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p><strong>双删加超时</strong></p><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。这样最差的情况是在超时时间内存在不一致，当然这种情况极其少见，可能的原因就是服务宕机。此种情况可以满足绝大多数需求。 当然这种策略要考虑redis和数据库主从同步的耗时，所以在第二次删除前最好休眠一定时间，比如500毫秒，这样毫无疑问又增加了写请求的耗时</p><h1 id="redis并发竞争问题"><a href="#redis并发竞争问题" class="headerlink" title="redis并发竞争问题"></a>redis并发竞争问题</h1><p>线上非常常见的一个问题，就是多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了。或者是多客户端同时获取一个key，修改值之后再写回去，只要顺序错了，数据就错了。</p><p>setnx</p><p>而且redis自己就有天然解决这个问题的CAS类的乐观锁方案</p><p>分布式锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="https://www.shado.com.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>hashCode and equals</title>
    <link href="https://www.shado.com.cn/2017/05/06/2017-05-06-hashCode-and-equals/"/>
    <id>https://www.shado.com.cn/2017/05/06/2017-05-06-hashCode-and-equals/</id>
    <published>2017-05-06T07:08:18.000Z</published>
    <updated>2019-06-18T03:20:17.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>hashCode()方法和equals()方法的区别和联系很多人觉得很简单，但是要回答的时候却答得差强人意。正确的回答应该是先介绍hashCode()和equals()方法的作用是什么，然后才说他的区别，说了区别之后再说使用的时候需要注意到的地方。如果你在了解一些其他人不知道的那就更好了！下边我们就开始介绍</p><h2 id="hashCode-和equals-是什么"><a href="#hashCode-和equals-是什么" class="headerlink" title="hashCode()和equals()是什么"></a>hashCode()和equals()是什么</h2><p>hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。</p><h2 id="hashCode-和equals-的区别"><a href="#hashCode-和equals-的区别" class="headerlink" title="hashCode()和equals()的区别"></a>hashCode()和equals()的区别</h2><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hashCode()效率高，但并不是完全可靠的，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>equals()是完全可靠的，但是重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的，equals()性能较差。</p></li><li><p>hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的，hashCode()性能较好。</p></li></ol><h2 id="hashCode-和equals-使用的注意事项"><a href="#hashCode-和equals-使用的注意事项" class="headerlink" title="hashCode()和equals()使用的注意事项"></a>hashCode()和equals()使用的注意事项</h2><ol><li><p>对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p></li><li><p>这种大量的并且快速的对象对比一般使用的hash容器中，比如HashSet,HashMap,HashTable等等，比如HashSet里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equals()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。</p></li><li><p>然而hashCode()和equals()一样都是基本类Object里的方法，而和equals()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值，比如下面：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num * name.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>由于标识这个类的是他的内部的变量num和name,所以我们就根据他们返回一个hash值，作为这个类的唯一hash值。</p><p>所以如果我们的对象要想放进hashSet，并且发挥hashSet的特性（即不包含一样的对象），则我们就要重写我们类的hashCode()和equals()方法了。像String,Integer等这种类内部都已经重写了这两个方法。</p><p>当然如果我们只是平时想对比两个对象是否一致，则只重写一个equals()，然后利用equals()去对比也行的。</p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><h3 id="阿里巴巴规定"><a href="#阿里巴巴规定" class="headerlink" title="阿里巴巴规定"></a>阿里巴巴规定</h3><h4 id="【强制】关于hashCode和equals的处理，遵循如下规则："><a href="#【强制】关于hashCode和equals的处理，遵循如下规则：" class="headerlink" title="【强制】关于hashCode和equals的处理，遵循如下规则："></a>【强制】关于hashCode和equals的处理，遵循如下规则：</h4><blockquote><p>1） 只要重写equals，就必须重写hashCode。<br>2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。<br>3） 如果自定义对象作为Map的键，那么必须重写hashCode和equals。<br> <strong>说明：</strong> String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。  </p></blockquote><h3 id="什么时候需要重写"><a href="#什么时候需要重写" class="headerlink" title="什么时候需要重写"></a>什么时候需要重写</h3><p>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode。</p><h3 id="为什么要重载hashCode"><a href="#为什么要重载hashCode" class="headerlink" title="为什么要重载hashCode"></a>为什么要重载hashCode</h3><p>如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。</p><p>这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。</p><h3 id="为什么equals-相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等"><a href="#为什么equals-相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等" class="headerlink" title="为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等"></a>为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等</h3><ol><li><p>因为是按照hashCode来访问小内存块，所以hashCode必须相等。</p></li><li><p>HashMap获取一个对象是比较key的hashCode相等和equals为true。</p></li></ol><p>之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equals为false。</p><h3 id="为什么需要hashCode"><a href="#为什么需要hashCode" class="headerlink" title="为什么需要hashCode"></a>为什么需要hashCode</h3><ol><li><p>通过hashCode可以很快的查到小内存块。</p></li><li><p>通过hashCode比较比equals方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="源码" scheme="https://www.shado.com.cn/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="https://www.shado.com.cn/2017/04/25/2017-04-25-mysql/"/>
    <id>https://www.shado.com.cn/2017/04/25/2017-04-25-mysql/</id>
    <published>2017-04-24T16:00:00.000Z</published>
    <updated>2019-05-21T03:26:05.052Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="Windows启动MySQL服务"><a href="#Windows启动MySQL服务" class="headerlink" title="Windows启动MySQL服务"></a>Windows启动MySQL服务</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启动MySQL</span></span><br><span class="line">    net <span class="built_in">start</span> mysql</span><br><span class="line"><span class="comment">-- 创建Windows服务</span></span><br><span class="line">    sc <span class="built_in">create</span> mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)</span><br></pre></td></tr></table></figure><h2 id="连接与断开服务器"><a href="#连接与断开服务器" class="headerlink" title="连接与断开服务器"></a>连接与断开服务器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span> <span class="comment">-- 显示哪些线程正在运行</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="comment">-- 显示系统变量信息</span></span><br></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前数据库</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>();</span><br><span class="line"><span class="comment">-- 显示当前时间、用户名、数据库版本</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">now</span>(), <span class="keyword">user</span>(), <span class="keyword">version</span>();</span><br><span class="line"><span class="comment">-- 创建库</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span>[ <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name</span><br><span class="line">        <span class="keyword">COLLATE</span> collation_name</span><br><span class="line"><span class="comment">-- 查看已有库</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>[ <span class="keyword">LIKE</span> <span class="string">'PATTERN'</span>]</span><br><span class="line"><span class="comment">-- 查看当前库信息</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名</span><br><span class="line"><span class="comment">-- 修改库的选项信息</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> 库名 选项信息</span><br><span class="line"><span class="comment">-- 删除库</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">DATABASE</span>[ <span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure><h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line">    <span class="keyword">CREATE</span> [<span class="keyword">TEMPORARY</span>] <span class="keyword">TABLE</span>[ <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        <span class="keyword">TEMPORARY</span> 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [<span class="keyword">NOT</span> <span class="literal">NULL</span> | <span class="literal">NULL</span>] [<span class="keyword">DEFAULT</span> default_value] [AUTO_INCREMENT] [<span class="keyword">UNIQUE</span> [<span class="keyword">KEY</span>] | [PRIMARY] <span class="keyword">KEY</span>] [<span class="keyword">COMMENT</span> <span class="string">'string'</span>]</span><br><span class="line"><span class="comment">-- 表选项</span></span><br><span class="line">    <span class="comment">-- 字符集</span></span><br><span class="line">        <span class="keyword">CHARSET</span> = charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    <span class="comment">-- 存储引擎</span></span><br><span class="line">        <span class="keyword">ENGINE</span> = engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：<span class="keyword">InnoDB</span> MyISAM <span class="keyword">Memory</span>/<span class="keyword">Heap</span> BDB <span class="keyword">Merge</span> Example CSV MaxDB <span class="keyword">Archive</span></span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        <span class="keyword">InnoDB</span>表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        <span class="keyword">SHOW</span> <span class="keyword">ENGINES</span> <span class="comment">-- 显示存储引擎的状态信息</span></span><br><span class="line">        <span class="keyword">SHOW</span> <span class="keyword">ENGINE</span> 引擎名 &#123;<span class="keyword">LOGS</span>|<span class="keyword">STATUS</span>&#125; <span class="comment">-- 显示存储引擎的日志或状态信息</span></span><br><span class="line">    <span class="comment">-- 自增起始数</span></span><br><span class="line">        AUTO_INCREMENT = 行数</span><br><span class="line">    <span class="comment">-- 数据文件目录</span></span><br><span class="line">        <span class="keyword">DATA</span> <span class="keyword">DIRECTORY</span> = <span class="string">'目录'</span></span><br><span class="line">    <span class="comment">-- 索引文件目录</span></span><br><span class="line">        <span class="keyword">INDEX</span> <span class="keyword">DIRECTORY</span> = <span class="string">'目录'</span></span><br><span class="line">    <span class="comment">-- 表注释</span></span><br><span class="line">        <span class="keyword">COMMENT</span> = <span class="string">'string'</span></span><br><span class="line">    <span class="comment">-- 分区选项</span></span><br><span class="line">        <span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... (详细见手册)</span><br><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLES</span>[ <span class="keyword">LIKE</span> <span class="string">'pattern'</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLES</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="comment">-- 查看表机构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 （信息更详细）</span><br><span class="line">    <span class="keyword">DESC</span> 表名 / <span class="keyword">DESCRIBE</span> 表名 / <span class="keyword">EXPLAIN</span> 表名 / <span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">LIKE</span> <span class="string">'PATTERN'</span>]</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> [<span class="keyword">FROM</span> db_name] [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]</span><br><span class="line"><span class="comment">-- 修改表</span></span><br><span class="line">    <span class="comment">-- 修改表本身的选项</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 表的选项</span><br><span class="line">        eg: <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ENGINE</span>=MYISAM;</span><br><span class="line">    <span class="comment">-- 对表进行重命名</span></span><br><span class="line">        <span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 新表名</span><br><span class="line">        <span class="keyword">RENAME</span> <span class="keyword">TABLE</span> 原表名 <span class="keyword">TO</span> 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        <span class="comment">-- RENAME可以交换两个表名</span></span><br><span class="line">    <span class="comment">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span></span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 操作名</span><br><span class="line">        <span class="comment">-- 操作名</span></span><br><span class="line">            <span class="keyword">ADD</span>[ <span class="keyword">COLUMN</span>] 字段定义       <span class="comment">-- 增加字段</span></span><br><span class="line">                <span class="keyword">AFTER</span> 字段名          <span class="comment">-- 表示增加在该字段名后面</span></span><br><span class="line">                <span class="keyword">FIRST</span>               <span class="comment">-- 表示增加在第一个</span></span><br><span class="line">            <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(字段名)   <span class="comment">-- 创建主键</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [索引名] (字段名)<span class="comment">-- 创建唯一索引</span></span><br><span class="line">            <span class="keyword">ADD</span> <span class="keyword">INDEX</span> [索引名] (字段名) <span class="comment">-- 创建普通索引</span></span><br><span class="line">            <span class="keyword">DROP</span>[ <span class="keyword">COLUMN</span>] 字段名      <span class="comment">-- 删除字段</span></span><br><span class="line">            <span class="keyword">MODIFY</span>[ <span class="keyword">COLUMN</span>] 字段名 字段属性     <span class="comment">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span></span><br><span class="line">            <span class="keyword">CHANGE</span>[ <span class="keyword">COLUMN</span>] 原字段名 新字段名 字段属性      <span class="comment">-- 支持对字段名修改</span></span><br><span class="line">            <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>    <span class="comment">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="comment">-- 删除索引</span></span><br><span class="line">            <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> 外键    <span class="comment">-- 删除外键</span></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">TABLE</span>[ <span class="keyword">IF</span> <span class="keyword">EXISTS</span>] 表名 ...</span><br><span class="line"><span class="comment">-- 清空表数据</span></span><br><span class="line">    <span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] 表名</span><br><span class="line"><span class="comment">-- 复制表结构</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">LIKE</span> 要复制的表名</span><br><span class="line"><span class="comment">-- 复制表结构和数据</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 [<span class="keyword">AS</span>] <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 要复制的表名</span><br><span class="line"><span class="comment">-- 检查表是否有错误</span></span><br><span class="line">    <span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">option</span>] ...</span><br><span class="line"><span class="comment">-- 优化表</span></span><br><span class="line">    <span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br><span class="line"><span class="comment">-- 修复表</span></span><br><span class="line">    <span class="keyword">REPAIR</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">QUICK</span>] [<span class="keyword">EXTENDED</span>] [USE_FRM]</span><br><span class="line"><span class="comment">-- 分析表</span></span><br><span class="line">    <span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增</span></span><br><span class="line">    <span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 [(字段列表)] <span class="keyword">VALUES</span> (值列表)[, (值列表), ...]</span><br><span class="line">        <span class="comment">-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span></span><br><span class="line">        <span class="comment">-- 可同时插入多条数据记录！</span></span><br><span class="line">        <span class="keyword">REPLACE</span> 与 <span class="keyword">INSERT</span> 完全一样，可互换。</span><br><span class="line">    <span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] 表名 <span class="keyword">SET</span> 字段名=值[, 字段名=值, ...]</span><br><span class="line"><span class="comment">-- 查</span></span><br><span class="line">    <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名[ 其他子句]</span><br><span class="line">        <span class="comment">-- 可来自多个表的多个字段</span></span><br><span class="line">        <span class="comment">-- 其他子句可以不使用</span></span><br><span class="line">        <span class="comment">-- 字段列表可以用*代替，表示所有字段</span></span><br><span class="line"><span class="comment">-- 删</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line"><span class="comment">-- 改</span></span><br><span class="line">    <span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名=新值[, 字段名=新值] [更新条件]</span><br></pre></td></tr></table></figure><h2 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL、数据库、表、字段均可设置编码</span></span><br><span class="line"><span class="comment">-- 数据编码与客户端编码不需一致</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'character_set_%'</span>   <span class="comment">-- 查看所有字符集编码项</span></span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line"><span class="keyword">SET</span> 变量名 = 变量值</span><br><span class="line">    <span class="keyword">SET</span> character_set_client = gbk;</span><br><span class="line">    <span class="keyword">SET</span> character_set_results = gbk;</span><br><span class="line">    <span class="keyword">SET</span> character_set_connection = gbk;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> GBK;  <span class="comment">-- 相当于完成以上三个设置</span></span><br><span class="line"><span class="comment">-- 校对集</span></span><br><span class="line">    校对集用以排序</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]/<span class="keyword">SHOW</span> <span class="keyword">CHARSET</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]   查看所有字符集</span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>]     查看所有校对集</span><br><span class="line">    <span class="keyword">CHARSET</span> 字符集编码     设置字符集编码</span><br><span class="line">    <span class="keyword">COLLATE</span> 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure><h2 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 数值类型</span><br><span class="line"></span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     <span class="number">1</span>字节    <span class="number">-128</span> ~ <span class="number">127</span>      无符号位：<span class="number">0</span> ~ <span class="number">255</span></span><br><span class="line">    smallint    <span class="number">2</span>字节    <span class="number">-32768</span> ~ <span class="number">32767</span></span><br><span class="line">    mediumint   <span class="number">3</span>字节    <span class="number">-8388608</span> ~ <span class="number">8388607</span></span><br><span class="line">    <span class="built_in">int</span>         <span class="number">4</span>字节</span><br><span class="line">    bigint      <span class="number">8</span>字节</span><br><span class="line">    <span class="built_in">int</span>(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以<span class="number">0</span>补填，zerofill 属性修改</span><br><span class="line">        例：<span class="built_in">int</span>(<span class="number">5</span>)   插入一个数<span class="string">'123'</span>，补填后为<span class="string">'00123'</span></span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - <span class="number">1</span>表示bool值真，<span class="number">0</span>表示bool值假。MySQL没有布尔类型，通过整型<span class="number">0</span>和<span class="number">1</span>表示。常用tinyint(<span class="number">1</span>)表示布尔型。</span><br><span class="line"></span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    <span class="built_in">float</span>(单精度)     <span class="number">4</span>字节</span><br><span class="line">    <span class="keyword">double</span>(双精度)    <span class="number">8</span>字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填<span class="number">0.</span></span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        <span class="built_in">float</span>(M, D)     <span class="keyword">double</span>(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line"></span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每<span class="number">9</span>位数字保存为<span class="number">4</span>个字节。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 字符串类型</span><br><span class="line"></span><br><span class="line">-- a. <span class="built_in">char</span>, varchar ----------</span><br><span class="line">    <span class="built_in">char</span>    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    <span class="built_in">char</span>,最多<span class="number">255</span>个字符，与编码无关。</span><br><span class="line">    varchar,最多<span class="number">65535</span>字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过<span class="number">65535</span>个字节。</span><br><span class="line">        utf8 最大为<span class="number">21844</span>个字符，gbk 最大为<span class="number">32766</span>个字符，latin1 最大为<span class="number">65532</span>个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于<span class="number">255</span>个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是<span class="number">65532</span>字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是<span class="number">64432</span><span class="number">-1</span><span class="number">-2</span>=<span class="number">65532</span>字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 <span class="built_in">int</span>, c2 <span class="built_in">char</span>(<span class="number">30</span>), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(<span class="number">65535</span><span class="number">-1</span><span class="number">-2</span><span class="number">-4</span><span class="number">-30</span>*<span class="number">3</span>)/<span class="number">3</span></span><br><span class="line"></span><br><span class="line">-- b. blob, <span class="built_in">text</span> ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    <span class="built_in">text</span> 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, <span class="built_in">text</span>, mediumtext, longtext</span><br><span class="line">    <span class="built_in">text</span> 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    <span class="built_in">text</span> 类型在定义时，不可给<span class="keyword">default</span>值</span><br><span class="line"></span><br><span class="line">-- c. <span class="built_in">binary</span>, varbinary ----------</span><br><span class="line">    类似于<span class="built_in">char</span>和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    <span class="built_in">char</span>, varchar, <span class="built_in">text</span> 对应 <span class="built_in">binary</span>, varbinary, blob.</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    <span class="number">8</span>字节    日期及时间     <span class="number">1000</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> 到 <span class="number">9999</span><span class="number">-12</span><span class="number">-31</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">    date        <span class="number">3</span>字节    日期         <span class="number">1000</span><span class="number">-01</span><span class="number">-01</span> 到 <span class="number">9999</span><span class="number">-12</span><span class="number">-31</span></span><br><span class="line">    timestamp   <span class="number">4</span>字节    时间戳        <span class="number">19700101000000</span> 到 <span class="number">2038</span><span class="number">-01</span><span class="number">-19</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07</span></span><br><span class="line">    time        <span class="number">3</span>字节    时间         <span class="number">-838</span>:<span class="number">59</span>:<span class="number">59</span> 到 <span class="number">838</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line">    <span class="built_in">year</span>        <span class="number">1</span>字节    年份         <span class="number">1901</span> - <span class="number">2155</span></span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line"><span class="built_in">year</span>        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 枚举和集合</span><br><span class="line"></span><br><span class="line">-- 枚举(<span class="keyword">enum</span>) ----------</span><br><span class="line"><span class="keyword">enum</span>(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为<span class="number">65535.</span></span><br><span class="line">    枚举值在保存时，以<span class="number">2</span>个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从<span class="number">1</span>开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 集合（<span class="built_in">set</span>） ----------</span><br><span class="line"><span class="built_in">set</span>(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender <span class="built_in">set</span>(<span class="string">'男'</span>, <span class="string">'女'</span>, <span class="string">'无'</span>) );</span><br><span class="line">    insert into tab values (<span class="string">'男, 女'</span>);</span><br><span class="line">    最多可以有<span class="number">64</span>个不同的成员。以bigint存储，共<span class="number">8</span>个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure><h2 id="选择类型"><a href="#选择类型" class="headerlink" title="选择类型"></a>选择类型</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- PHP角度</span><br><span class="line"><span class="number">1.</span> 功能满足</span><br><span class="line"><span class="number">2.</span> 存储空间尽量小，处理效率更高</span><br><span class="line"><span class="number">3.</span> 考虑兼容问题</span><br><span class="line"></span><br><span class="line">-- IP存储 ----------</span><br><span class="line"><span class="number">1.</span> 只需存储，可用字符串</span><br><span class="line"><span class="number">2.</span> 如果需计算，查找等，可存储为<span class="number">4</span>个字节的无符号int，即unsigned</span><br><span class="line">    <span class="number">1</span>) PHP函数转换</span><br><span class="line">        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。</span><br><span class="line">        利用sprintf函数格式化字符串</span><br><span class="line">        sprintf(<span class="string">"%u"</span>, ip2long('<span class="number">192.168</span><span class="number">.3</span><span class="number">.134</span>'));</span><br><span class="line">        然后用long2ip将整型转回IP字符串</span><br><span class="line">    <span class="number">2</span>) MySQL函数转换(无符号整型，UNSIGNED)</span><br><span class="line">        INET_ATON('<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>') 将IP转为整型</span><br><span class="line">        INET_NTOA(<span class="number">2130706433</span>) 将整型转为IP</span><br></pre></td></tr></table></figure><h2 id="列属性（列约束）"><a href="#列属性（列约束）" class="headerlink" title="列属性（列约束）"></a>列属性（列约束）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( <span class="keyword">id</span> <span class="built_in">int</span>, stu <span class="built_in">varchar</span>(<span class="number">10</span>), primary <span class="keyword">key</span> (<span class="keyword">id</span>));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( <span class="keyword">id</span> <span class="built_in">int</span>, stu <span class="built_in">varchar</span>(<span class="number">10</span>), age <span class="built_in">int</span>, primary <span class="keyword">key</span> (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'val'</span>);</span><br><span class="line">        <span class="comment">-- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span></span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="keyword">default</span>, <span class="string">'val'</span>);    <span class="comment">-- 此时表示强制使用默认值。</span></span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> tab ( add_time <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> );</span><br><span class="line">        <span class="comment">-- 表示将当前时间的时间戳设为默认值。</span></span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 <span class="keyword">alter</span> <span class="keyword">table</span> tbl auto_increment = x;</span><br><span class="line">6. <span class="keyword">COMMENT</span> 注释</span><br><span class="line">    例：<span class="keyword">create</span> <span class="keyword">table</span> tab ( <span class="keyword">id</span> <span class="built_in">int</span> ) <span class="keyword">comment</span> <span class="string">'注释内容'</span>;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="string">`t1_t2_fk`</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (t1_id) <span class="keyword">references</span> t2(<span class="keyword">id</span>);</span><br><span class="line">        <span class="comment">-- 将表t1的t1_id外键关联到表t2的id字段。</span></span><br><span class="line">        <span class="comment">-- 每个外键都有一个名字，可以通过 constraint 指定</span></span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on <span class="keyword">update</span> 或 <span class="keyword">on</span> <span class="keyword">delete</span>：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">cascade</span>，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">set</span> <span class="literal">null</span>，设置为<span class="literal">null</span>。主表数据被更新（主键值更新），从表的外键被设置为<span class="literal">null</span>。主表记录被删除，从表相关记录外键被设置成<span class="literal">null</span>。但注意，要求该外键列，没有<span class="keyword">not</span> <span class="literal">null</span>属性约束。</span><br><span class="line">    <span class="number">3.</span> restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被<span class="keyword">InnoDB</span>存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure><h2 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">- Normal Format, NF</span></span><br><span class="line"><span class="ruby">    - 每个表保存一个实体信息</span></span><br><span class="line"><span class="ruby">    - 每个具有一个ID字段作为主键</span></span><br><span class="line"><span class="ruby">    - ID主键 + 原子表</span></span><br><span class="line"><span class="ruby">-- <span class="number">1</span>NF, 第一范式</span></span><br><span class="line"><span class="ruby">    字段不能再分，就满足第一范式。</span></span><br><span class="line"><span class="ruby">-- <span class="number">2</span>NF, 第二范式</span></span><br><span class="line"><span class="ruby">    满足第一范式的前提下，不能出现部分依赖。</span></span><br><span class="line"><span class="ruby">    消除符合主键就可以避免部分依赖。增加单列关键字。</span></span><br><span class="line"><span class="ruby">-- <span class="number">3</span>NF, 第三范式</span></span><br><span class="line"><span class="ruby">    满足第二范式的前提下，不能出现传递依赖。</span></span><br><span class="line"><span class="ruby">    某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span></span><br><span class="line"><span class="ruby">    将一个实体信息的数据放在一个表内实现。</span></span><br></pre></td></tr></table></figure><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL|DISTINCT] select_expr <span class="keyword">FROM</span> -&gt; WHERE -&gt;<span class="built_in"> GROUP </span>BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * <span class="keyword">from</span> tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() <span class="keyword">from</span> tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 <span class="keyword">from</span> tb;</span><br><span class="line">b. <span class="keyword">FROM</span> 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * <span class="keyword">FROM</span> tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- <span class="keyword">from</span>子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * <span class="keyword">FROM</span> tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * <span class="keyword">FROM</span> table1 USE INDEX (key1,key2) WHERE <span class="attribute">key1</span>=1 <span class="keyword">AND</span> <span class="attribute">key2</span>=2 <span class="keyword">AND</span> <span class="attribute">key3</span>=3;</span><br><span class="line">        SELECT * <span class="keyword">FROM</span> table1 IGNORE INDEX (key3) WHERE <span class="attribute">key1</span>=1 <span class="keyword">AND</span> <span class="attribute">key2</span>=2 <span class="keyword">AND</span> <span class="attribute">key3</span>=3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从<span class="keyword">from</span>获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            <span class="keyword">in</span> (<span class="keyword">not</span>) <span class="literal">null</span>, (<span class="keyword">not</span>) like, (<span class="keyword">not</span>) <span class="keyword">in</span>, (<span class="keyword">not</span>) between <span class="keyword">and</span>, is (<span class="keyword">not</span>), <span class="keyword">and</span>, <span class="keyword">or</span>, <span class="keyword">not</span>, xor</span><br><span class="line">            is/is <span class="keyword">not</span> 加上ture/<span class="literal">false</span>/unknown，检验某个值的真假</span><br><span class="line">            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于<span class="literal">null</span>比较</span><br><span class="line">d.<span class="built_in"> GROUP </span>BY 子句, 分组子句</span><br><span class="line">   <span class="built_in"> GROUP </span>BY 字段/别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合<span class="built_in"> GROUP </span>BY 使用：</span><br><span class="line">    count 返回不同的非<span class="literal">NULL</span>值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非<span class="literal">NULL</span>值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]<span class="built_in">..</span>.</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将多个<span class="keyword">select</span>查询的结果组合成一个结果集合。</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">UNION</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...</span><br><span class="line">默认 <span class="keyword">DISTINCT</span> 方式，即所有返回的行都是唯一的</span><br><span class="line">建议，对每个<span class="keyword">SELECT</span>查询加上小括号包裹。</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序时，需加上 <span class="keyword">LIMIT</span> 进行结合。</span><br><span class="line">需要各<span class="keyword">select</span>查询的字段数量一样。</span><br><span class="line">每个<span class="keyword">select</span>查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条<span class="keyword">select</span>语句为准。</span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    - 子查询需用括号包裹。</span><br><span class="line"><span class="comment">-- from型</span></span><br><span class="line">    <span class="keyword">from</span>后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - <span class="keyword">from</span>型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * <span class="keyword">from</span> (select * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="built_in">id</span>&gt;<span class="number">0</span>) <span class="keyword">as</span> subfrom <span class="keyword">where</span> <span class="built_in">id</span>&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- where型</span></span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - <span class="keyword">where</span>子查询内的表，不能直接用以更新。</span><br><span class="line">    select * <span class="keyword">from</span> tb <span class="keyword">where</span> money = (select max(money) <span class="keyword">from</span> tb);</span><br><span class="line">    <span class="comment">-- 列子查询</span></span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 <span class="keyword">in</span> 或 <span class="keyword">not</span> <span class="keyword">in</span> 完成查询</span><br><span class="line">        exists 和 <span class="keyword">not</span> exists 条件</span><br><span class="line">            如果子查询返回数据，则返回<span class="number">1</span>或<span class="number">0</span>。常用于判断条件。</span><br><span class="line">            select column1 <span class="keyword">from</span> t1 <span class="keyword">where</span> exists (select * <span class="keyword">from</span> t2);</span><br><span class="line">    <span class="comment">-- 行子查询</span></span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * <span class="keyword">from</span> t1 <span class="keyword">where</span> (<span class="built_in">id</span>, gender) <span class="keyword">in</span> (select <span class="built_in">id</span>, gender <span class="keyword">from</span> t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    <span class="comment">-- 特殊运算符</span></span><br><span class="line">    != all()    相当于 <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">    = <span class="keyword">some</span>()    相当于 <span class="keyword">in</span>。any 是 <span class="keyword">some</span> 的别名</span><br><span class="line">    != <span class="keyword">some</span>()   不等同于 <span class="keyword">not</span> <span class="keyword">in</span>，不等于其中某一个。</span><br><span class="line">    all, <span class="keyword">some</span> 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure><h2 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner <span class="keyword">join</span>)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    <span class="keyword">on</span> 表示连接条件。其条件表达式与<span class="keyword">where</span>类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用<span class="keyword">where</span>表示连接条件。</span><br><span class="line">    还有 <span class="keyword">using</span>, 但需字段名相同。 <span class="keyword">using</span>(字段名)</span><br><span class="line">    -- 交叉连接 cross <span class="keyword">join</span></span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> tb1 cross <span class="keyword">join</span> tb2;</span><br><span class="line">-- 外连接(outer <span class="keyword">join</span>)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left <span class="keyword">join</span></span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为<span class="literal">null</span>填充</span><br><span class="line">    -- 右外连接 right <span class="keyword">join</span></span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为<span class="literal">null</span>填充</span><br><span class="line">-- 自然连接(natural <span class="keyword">join</span>)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了<span class="keyword">using</span>，会自动查找相同字段名。</span><br><span class="line">    natural <span class="keyword">join</span></span><br><span class="line">    natural left <span class="keyword">join</span></span><br><span class="line">    natural right <span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex <span class="keyword">from</span> info, extra_info <span class="keyword">where</span> info.stu_num = extra_info.stu_id;</span><br></pre></td></tr></table></figure><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> <span class="keyword">outfile</span> 文件地址 [控制格式] <span class="keyword">from</span> 表名;   <span class="comment">-- 导出表数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> [<span class="keyword">local</span>] <span class="keyword">infile</span> 文件地址 [<span class="keyword">replace</span>|<span class="keyword">ignore</span>] <span class="keyword">into</span> <span class="keyword">table</span> 表名 [控制格式]; <span class="comment">-- 导入数据</span></span><br><span class="line">    生成的数据默认的分隔符是制表符</span><br><span class="line">    local未指定，则数据文件必须在服务器上</span><br><span class="line">    <span class="keyword">replace</span> 和 <span class="keyword">ignore</span> 关键词控制对现有的唯一键记录的重复的处理</span><br><span class="line"><span class="comment">-- 控制格式</span></span><br><span class="line"><span class="keyword">fields</span>  控制字段格式</span><br><span class="line">默认：<span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">''</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">''</span> <span class="keyword">escaped</span> <span class="keyword">by</span> <span class="string">'\'</span></span><br><span class="line"><span class="string">    terminated by '</span><span class="keyword">string</span><span class="string">'  -- 终止</span></span><br><span class="line"><span class="string">    enclosed by '</span><span class="built_in">char</span><span class="string">'      -- 包裹</span></span><br><span class="line"><span class="string">    escaped by '</span><span class="built_in">char</span><span class="string">'       -- 转义</span></span><br><span class="line"><span class="string">    -- 示例：</span></span><br><span class="line"><span class="string">        SELECT a,b,a+b INTO OUTFILE '</span>/tmp/result.text<span class="string">'</span></span><br><span class="line"><span class="string">        FIELDS TERMINATED BY '</span>,<span class="string">' OPTIONALLY ENCLOSED BY '</span><span class="string">"'</span></span><br><span class="line"><span class="string">        LINES TERMINATED BY '</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="string">        FROM test_table;</span></span><br><span class="line"><span class="string">lines   控制行格式</span></span><br><span class="line"><span class="string">默认：lines terminated by '</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="string">    terminated by 'string'  -- 终止</span></span><br></pre></td></tr></table></figure><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>语句获得的数据可以用<span class="keyword">insert</span>插入。</span><br><span class="line">可以省略对列的指定，要求 <span class="keyword">values</span> () 括号内，提供给了按照列顺序出现的所有字段的值。</span><br><span class="line">    或者使用<span class="keyword">set</span>语法。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">SET</span> <span class="keyword">field</span>=<span class="keyword">value</span>,...；</span><br><span class="line">可以一次性使用多个值，采用(), (), ();的形式。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span> (), (), ();</span><br><span class="line">可以在列值指定时，使用表达式。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span> (field_value, <span class="number">10</span>+<span class="number">10</span>, <span class="keyword">now</span>());</span><br><span class="line">可以使用一个特殊值 DEFAULT，表示该列使用默认值。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span> (field_value, <span class="keyword">DEFAULT</span>);</span><br><span class="line">可以通过一个查询的结果，作为需要插入的值。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">SELECT</span> ...;</span><br><span class="line">可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_name <span class="keyword">VALUES</span>/<span class="keyword">SET</span>/<span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> 字段=值, …;</span><br></pre></td></tr></table></figure><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name [<span class="keyword">WHERE</span> where_definition] [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...] [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br><span class="line">按照条件删除。<span class="keyword">where</span></span><br><span class="line">指定删除的最多记录数。<span class="keyword">limit</span></span><br><span class="line">可以通过排序条件删除。<span class="keyword">order</span> <span class="keyword">by</span> + <span class="keyword">limit</span></span><br><span class="line">支持多表删除，使用类似连接语法。</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 需要删除数据多表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">using</span> 表连接操作 条件。</span><br></pre></td></tr></table></figure><h2 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line"><span class="number">1</span>，<span class="keyword">truncate</span> 是删除表再创建，<span class="keyword">delete</span> 是逐条删除</span><br><span class="line"><span class="number">2</span>，<span class="keyword">truncate</span> 重置auto_increment的值。而<span class="keyword">delete</span>不会</span><br><span class="line"><span class="number">3</span>，<span class="keyword">truncate</span> 不知道删除了几条，而<span class="keyword">delete</span>知道。</span><br><span class="line"><span class="number">4</span>，当被用于带分区的表时，<span class="keyword">truncate</span> 会保留分区</span><br></pre></td></tr></table></figure><h2 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h2><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">备份，将数据的结构与表内数据保存起来。</span></span><br><span class="line"><span class="comment">利用</span> <span class="comment">mysqldump</span> <span class="comment">指令完成。</span></span><br><span class="line"><span class="comment"></span><span class="literal">-</span><span class="literal">-</span> <span class="comment">导出</span></span><br><span class="line"><span class="comment">mysqldump</span> <span class="title">[</span><span class="comment">options</span><span class="title">]</span> <span class="comment">db_name</span> <span class="title">[</span><span class="comment">tables</span><span class="title">]</span></span><br><span class="line"><span class="comment">mysqldump</span> <span class="title">[</span><span class="comment">options</span><span class="title">]</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">database</span> <span class="comment">DB1</span> <span class="title">[</span><span class="comment">DB2</span> <span class="comment">DB3</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="title">]</span></span><br><span class="line"><span class="comment">mysqldump</span> <span class="title">[</span><span class="comment">options</span><span class="title">]</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">all</span><span class="literal">-</span><span class="literal">-</span><span class="comment">database</span></span><br><span class="line"><span class="comment">1</span><span class="string">.</span> <span class="comment">导出一张表</span></span><br><span class="line"><span class="comment">　　mysqldump</span> <span class="literal">-</span><span class="comment">u用户名</span> <span class="literal">-</span><span class="comment">p密码</span> <span class="comment">库名</span> <span class="comment">表名</span> &gt; <span class="comment">文件名(D:/a</span><span class="string">.</span><span class="comment">sql)</span></span><br><span class="line"><span class="comment">2</span><span class="string">.</span> <span class="comment">导出多张表</span></span><br><span class="line"><span class="comment">　　mysqldump</span> <span class="literal">-</span><span class="comment">u用户名</span> <span class="literal">-</span><span class="comment">p密码</span> <span class="comment">库名</span> <span class="comment">表1</span> <span class="comment">表2</span> <span class="comment">表3</span> &gt; <span class="comment">文件名(D:/a</span><span class="string">.</span><span class="comment">sql)</span></span><br><span class="line"><span class="comment">3</span><span class="string">.</span> <span class="comment">导出所有表</span></span><br><span class="line"><span class="comment">　　mysqldump</span> <span class="literal">-</span><span class="comment">u用户名</span> <span class="literal">-</span><span class="comment">p密码</span> <span class="comment">库名</span> &gt; <span class="comment">文件名(D:/a</span><span class="string">.</span><span class="comment">sql)</span></span><br><span class="line"><span class="comment">4</span><span class="string">.</span> <span class="comment">导出一个库</span></span><br><span class="line"><span class="comment">　　mysqldump</span> <span class="literal">-</span><span class="comment">u用户名</span> <span class="literal">-</span><span class="comment">p密码</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">lock</span><span class="literal">-</span><span class="comment">all</span><span class="literal">-</span><span class="comment">tables</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">database</span> <span class="comment">库名</span> &gt; <span class="comment">文件名(D:/a</span><span class="string">.</span><span class="comment">sql)</span></span><br><span class="line"><span class="comment">可以</span><span class="literal">-</span><span class="comment">w携带WHERE条件</span></span><br><span class="line"><span class="comment"></span><span class="literal">-</span><span class="literal">-</span> <span class="comment">导入</span></span><br><span class="line"><span class="comment">1</span><span class="string">.</span> <span class="comment">在登录mysql的情况下：</span></span><br><span class="line"><span class="comment">　　source</span>  <span class="comment">备份文件</span></span><br><span class="line"><span class="comment">2</span><span class="string">.</span> <span class="comment">在不登录的情况下</span></span><br><span class="line"><span class="comment">　　mysql</span> <span class="literal">-</span><span class="comment">u用户名</span> <span class="literal">-</span><span class="comment">p密码</span> <span class="comment">库名</span> &lt; <span class="comment">备份文件</span></span><br></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;] <span class="keyword">VIEW</span> view_name [(column_list)] <span class="keyword">AS</span> select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用<span class="keyword">select</span>语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于<span class="keyword">SELECT</span>语句检索的列数</span><br><span class="line"><span class="comment">-- 查看结构</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name</span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">VIEW</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] view_name ...</span><br><span class="line"><span class="comment">-- 修改视图结构</span></span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name [(column_list)] <span class="keyword">AS</span> select_statement</span><br><span class="line"><span class="comment">-- 视图作用</span></span><br><span class="line">    <span class="number">1.</span> 简化业务逻辑</span><br><span class="line">    <span class="number">2.</span> 对客户端隐藏真实的表结构</span><br><span class="line"><span class="comment">-- 视图算法(ALGORITHM)</span></span><br><span class="line">    <span class="keyword">MERGE</span>       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure><h2 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据晚自习方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line"><span class="comment">-- 事务开启</span></span><br><span class="line">    <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>; 或者 <span class="keyword">BEGIN</span>;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line"><span class="comment">-- 事务提交</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 事务回滚</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line"><span class="comment">-- 事务的特性</span></span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line"><span class="comment">-- 事务的实现</span></span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line"><span class="comment">-- 事务的原理</span></span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要<span class="keyword">commit</span>提交持久化数据操作。</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">    <span class="number">1.</span> 数据定义语言（<span class="keyword">DDL</span>）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    <span class="number">2.</span> 事务不能被嵌套</span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line">    <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 设置一个事务保存点</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 回滚到保存点</span></span><br><span class="line">    <span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称 <span class="comment">-- 删除保存点</span></span><br><span class="line"><span class="comment">-- InnoDB自动提交特性设置</span></span><br><span class="line">    <span class="keyword">SET</span> autocommit = <span class="number">0</span>|<span class="number">1</span>;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要<span class="keyword">commit</span>提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>不同的是，</span><br><span class="line">        <span class="keyword">SET</span> autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure><h2 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line"><span class="comment">-- 锁定</span></span><br><span class="line">    <span class="keyword">LOCK</span> <span class="keyword">TABLES</span> tbl_name [<span class="keyword">AS</span> <span class="keyword">alias</span>]</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">    <span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span></span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event <span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 <span class="keyword">before</span> 或 <span class="keyword">after</span>，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        <span class="keyword">INSERT</span>：将新行插入表时激活触发程序</span><br><span class="line">        <span class="keyword">UPDATE</span>：更改某一行时激活触发程序</span><br><span class="line">        <span class="keyword">DELETE</span>：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与<span class="keyword">TEMPORARY</span>表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name</span><br><span class="line">可以使用<span class="keyword">old</span>和<span class="keyword">new</span>代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是<span class="keyword">old</span>，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">    <span class="number">1.</span> 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line"><span class="comment">-- 字符连接函数</span></span><br><span class="line"><span class="keyword">concat</span>(str1,str2,...])</span><br><span class="line"><span class="keyword">concat_ws</span>(separator,str1,str2,...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分支语句</span></span><br><span class="line"><span class="keyword">if</span> 条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改最外层语句结束符</span></span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     <span class="comment">-- 修改回原来的分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 语句块包裹</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    语句块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 特殊的执行</span></span><br><span class="line"><span class="number">1.</span> 只要添加记录，就会触发程序。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">Insert</span> <span class="keyword">into</span> <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 <span class="keyword">before</span> <span class="keyword">insert</span>, <span class="keyword">after</span> <span class="keyword">insert</span>;</span><br><span class="line">    如果有重复记录并更新，会触发 before <span class="keyword">insert</span>, <span class="keyword">before</span> <span class="keyword">update</span>, <span class="keyword">after</span> <span class="keyword">update</span>;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before <span class="keyword">insert</span>, <span class="keyword">before</span> <span class="keyword">update</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">Replace</span> 语法 如果有记录，则执行 <span class="keyword">before</span> <span class="keyword">insert</span>, <span class="keyword">before</span> <span class="keyword">delete</span>, <span class="keyword">after</span> <span class="keyword">delete</span>, <span class="keyword">after</span> <span class="keyword">insert</span></span><br></pre></td></tr></table></figure><h2 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--// 局部变量 ----------</span></span><br><span class="line"><span class="comment">-- 变量声明</span></span><br><span class="line">    <span class="keyword">declare</span> var_name[,...] <span class="keyword">type</span> [<span class="keyword">default</span> <span class="keyword">value</span>]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个<span class="keyword">default</span>子句。值可以被指定为一个表达式，不需要为一个常数。如果没有<span class="keyword">default</span>子句，初始值为<span class="literal">null</span>。</span><br><span class="line"><span class="comment">-- 赋值</span></span><br><span class="line">    使用 <span class="keyword">set</span> 和 <span class="keyword">select</span> <span class="keyword">into</span> 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 全局变量 ----------</span></span><br><span class="line"><span class="comment">-- 定义、赋值</span></span><br><span class="line"><span class="keyword">set</span> 语句可以定义并为变量赋值。</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">var</span> = <span class="keyword">value</span>;</span><br><span class="line">也可以使用<span class="keyword">select</span> <span class="keyword">into</span>语句为变量初始化并赋值。这样要求<span class="keyword">select</span>语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过<span class="keyword">select</span>执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（<span class="keyword">set</span>语句可以使用= 和 :=）。</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">var</span>:=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> @v1:=<span class="keyword">id</span>, @v2=<span class="keyword">name</span> <span class="keyword">from</span> t1 <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tbl_name <span class="keyword">where</span> @<span class="keyword">var</span>:=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">into</span> 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| <span class="keyword">select</span> <span class="keyword">max</span>(height) <span class="keyword">into</span> @max_height <span class="keyword">from</span> tb;</span><br><span class="line"><span class="comment">-- 自定义变量名</span></span><br><span class="line">为了避免<span class="keyword">select</span>语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@<span class="keyword">var</span>=<span class="number">10</span>;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 控制结构 ----------</span></span><br><span class="line"><span class="comment">-- if语句</span></span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="comment">-- case语句</span></span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- while循环</span></span><br><span class="line">[begin_label:] <span class="keyword">while</span> search_condition <span class="keyword">do</span></span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span> [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    <span class="comment">-- 退出循环</span></span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--// 内置函数 ----------</span></span><br><span class="line"><span class="comment">-- 数值函数</span></span><br><span class="line">abs(x)          <span class="comment">-- 绝对值 abs(-10.9) = 10</span></span><br><span class="line">format(x, d)    <span class="comment">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span></span><br><span class="line">ceil(x)         <span class="comment">-- 向上取整 ceil(10.1) = 11</span></span><br><span class="line">floor(x)        <span class="comment">-- 向下取整 floor (10.1) = 10</span></span><br><span class="line">round(x)        <span class="comment">-- 四舍五入去整</span></span><br><span class="line">mod(m, n)       <span class="comment">-- m%n m mod n 求余 10%3=1</span></span><br><span class="line">pi()            <span class="comment">-- 获得圆周率</span></span><br><span class="line">pow(m, n)       <span class="comment">-- m^n</span></span><br><span class="line">sqrt(x)         <span class="comment">-- 算术平方根</span></span><br><span class="line">rand()          <span class="comment">-- 随机数</span></span><br><span class="line"><span class="keyword">truncate</span>(x, d)  <span class="comment">-- 截取d位小数</span></span><br><span class="line"><span class="comment">-- 时间日期函数</span></span><br><span class="line"><span class="keyword">now</span>(), <span class="keyword">current_timestamp</span>();     <span class="comment">-- 当前日期时间</span></span><br><span class="line">current_date();                 <span class="comment">-- 当前日期</span></span><br><span class="line">current_time();                 <span class="comment">-- 当前时间</span></span><br><span class="line">date('yyyy-mm-dd hh:ii:ss');    <span class="comment">-- 获取日期部分</span></span><br><span class="line">time('yyyy-mm-dd hh:ii:ss');    <span class="comment">-- 获取时间部分</span></span><br><span class="line">date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); <span class="comment">-- 格式化时间</span></span><br><span class="line">unix_timestamp();               <span class="comment">-- 获得unix时间戳</span></span><br><span class="line">from_unixtime();                <span class="comment">-- 从时间戳获得时间</span></span><br><span class="line"><span class="comment">-- 字符串函数</span></span><br><span class="line">length(string)          <span class="comment">-- string长度，字节</span></span><br><span class="line">char_length(string)     <span class="comment">-- string的字符个数</span></span><br><span class="line">substring(str, position [,length])      <span class="comment">-- 从str的position开始,取length个字符</span></span><br><span class="line"><span class="keyword">replace</span>(<span class="keyword">str</span> ,search_str ,replace_str)   <span class="comment">-- 在str中用replace_str替换search_str</span></span><br><span class="line"><span class="keyword">instr</span>(<span class="keyword">string</span> ,<span class="keyword">substring</span>)    <span class="comment">-- 返回substring首次在string中出现的位置</span></span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">string</span> [,...])   <span class="comment">-- 连接字串</span></span><br><span class="line"><span class="keyword">charset</span>(<span class="keyword">str</span>)            <span class="comment">-- 返回字串字符集</span></span><br><span class="line"><span class="keyword">lcase</span>(<span class="keyword">string</span>)           <span class="comment">-- 转换成小写</span></span><br><span class="line"><span class="keyword">left</span>(<span class="keyword">string</span>, <span class="keyword">length</span>)    <span class="comment">-- 从string2中的左边起取length个字符</span></span><br><span class="line"><span class="keyword">load_file</span>(file_name)    <span class="comment">-- 从文件读取内容</span></span><br><span class="line"><span class="keyword">locate</span>(<span class="keyword">substring</span>, <span class="keyword">string</span> [,start_position]) <span class="comment">-- 同instr,但可指定开始位置</span></span><br><span class="line"><span class="keyword">lpad</span>(<span class="keyword">string</span>, <span class="keyword">length</span>, <span class="keyword">pad</span>)   <span class="comment">-- 重复用pad加在string开头,直到字串长度为length</span></span><br><span class="line"><span class="keyword">ltrim</span>(<span class="keyword">string</span>)           <span class="comment">-- 去除前端空格</span></span><br><span class="line"><span class="keyword">repeat</span>(<span class="keyword">string</span>, <span class="keyword">count</span>)   <span class="comment">-- 重复count次</span></span><br><span class="line">rpad(<span class="keyword">string</span>, <span class="keyword">length</span>, <span class="keyword">pad</span>)   <span class="comment">--在str后用pad补充,直到长度为length</span></span><br><span class="line"><span class="keyword">rtrim</span>(<span class="keyword">string</span>)           <span class="comment">-- 去除后端空格</span></span><br><span class="line"><span class="keyword">strcmp</span>(string1 ,string2)    <span class="comment">-- 逐字符比较两字串大小</span></span><br><span class="line"><span class="comment">-- 流程函数</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> [condition] <span class="keyword">then</span> <span class="keyword">result</span> [<span class="keyword">when</span> [condition] <span class="keyword">then</span> <span class="keyword">result</span> ...] [<span class="keyword">else</span> <span class="keyword">result</span>] <span class="keyword">end</span>   多分支</span><br><span class="line"><span class="keyword">if</span>(expr1,expr2,expr3)  双分支。</span><br><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="keyword">count</span>()</span><br><span class="line"><span class="keyword">sum</span>();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line"><span class="comment">-- 其他常用函数</span></span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line"></span><br><span class="line"><span class="comment">--// 存储函数，自定义函数 ----------</span></span><br><span class="line"><span class="comment">-- 新建</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name (参数列表) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由<span class="string">"参数名"</span>和<span class="string">"参数类型"</span>组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 <span class="keyword">return</span> 返回值语句。</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] function_name;</span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'partten'</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name;</span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line">    <span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> function_name 函数选项</span><br><span class="line"></span><br><span class="line"><span class="comment">--// 存储过程，自定义功能 ----------</span></span><br><span class="line"><span class="comment">-- 定义</span></span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的<span class="keyword">sql</span>组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过<span class="keyword">call</span>执行。</span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line"><span class="keyword">IN</span>，表示输入型</span><br><span class="line"><span class="keyword">OUT</span>，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储过程 */</span> <span class="comment">------------------</span></span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：<span class="keyword">CALL</span> 过程名</span><br><span class="line"><span class="comment">-- 注意</span></span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line"><span class="comment">-- 参数</span></span><br><span class="line"><span class="keyword">IN</span>|<span class="keyword">OUT</span>|INOUT 参数名 数据类型</span><br><span class="line"><span class="keyword">IN</span>      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line"><span class="keyword">OUT</span>     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 过程名 (参数列表)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- root密码重置</span></span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] /usr/local/mysql/bin/safe_mysqld <span class="comment">--skip-grant-tables &amp;</span></span><br><span class="line">    [Windows] mysqld <span class="comment">--skip-grant-tables</span></span><br><span class="line">3. <span class="keyword">use</span> mysql;</span><br><span class="line">4. <span class="keyword">UPDATE</span> <span class="string">`user`</span> <span class="keyword">SET</span> <span class="keyword">PASSWORD</span>=<span class="keyword">PASSWORD</span>(<span class="string">"密码"</span>) <span class="keyword">WHERE</span> <span class="string">`user`</span> = <span class="string">"root"</span>;</span><br><span class="line">5. <span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"><span class="comment">-- 增加用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">PASSWORD</span>] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局<span class="keyword">CREATE</span> <span class="keyword">USER</span>权限，或拥有<span class="keyword">INSERT</span>权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 <span class="string">'user_name'</span>@<span class="string">'192.168.1.1'</span></span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略<span class="keyword">PASSWORD</span>关键词。要把密码指定为由<span class="keyword">PASSWORD</span>()函数返回的混编值，需包含关键字<span class="keyword">PASSWORD</span></span><br><span class="line"><span class="comment">-- 重命名用户</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> old_user <span class="keyword">TO</span> new_user</span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">'密码'</span>)  <span class="comment">-- 为当前用户设置密码</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> 用户名 = <span class="keyword">PASSWORD</span>(<span class="string">'密码'</span>) <span class="comment">-- 为指定用户设置密码</span></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> 用户名</span><br><span class="line"><span class="comment">-- 分配权限/添加用户</span></span><br><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户名 [<span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">PASSWORD</span>] <span class="string">'password'</span>]</span><br><span class="line">    - <span class="keyword">all</span> <span class="keyword">privileges</span> 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> <span class="string">`pms`</span>.* <span class="keyword">TO</span> <span class="string">'pms'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'pms0817'</span>;</span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> 用户名</span><br><span class="line">    <span class="comment">-- 查看当前用户权限</span></span><br><span class="line">    <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span>; 或 <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>; 或 <span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> <span class="keyword">CURRENT_USER</span>();</span><br><span class="line"><span class="comment">-- 撤消权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 表名 <span class="keyword">FROM</span> 用户名</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span>, <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> <span class="keyword">FROM</span> 用户名   <span class="comment">-- 撤销所有权限</span></span><br><span class="line"><span class="comment">-- 权限层级</span></span><br><span class="line"><span class="comment">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span></span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.*和 <span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.*和<span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    <span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.tbl_name和<span class="keyword">REVOKE</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用<span class="keyword">REVOKE</span>时，您必须指定与被授权列相同的列。</span><br><span class="line"><span class="comment">-- 权限列表</span></span><br><span class="line"><span class="keyword">ALL</span> [<span class="keyword">PRIVILEGES</span>]    <span class="comment">-- 设置除GRANT OPTION之外的所有简单权限</span></span><br><span class="line"><span class="keyword">ALTER</span>   <span class="comment">-- 允许使用ALTER TABLE</span></span><br><span class="line"><span class="keyword">ALTER</span> ROUTINE   <span class="comment">-- 更改或取消已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span>  <span class="comment">-- 允许使用CREATE TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> ROUTINE  <span class="comment">-- 创建已存储的子程序</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLES</span>     <span class="comment">-- 允许使用CREATE TEMPORARY TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span>     <span class="comment">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span>     <span class="comment">-- 允许使用CREATE VIEW</span></span><br><span class="line"><span class="keyword">DELETE</span>  <span class="comment">-- 允许使用DELETE</span></span><br><span class="line"><span class="keyword">DROP</span>    <span class="comment">-- 允许使用DROP TABLE</span></span><br><span class="line"><span class="keyword">EXECUTE</span>     <span class="comment">-- 允许用户运行已存储的子程序</span></span><br><span class="line"><span class="keyword">FILE</span>    <span class="comment">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span></span><br><span class="line"><span class="keyword">INDEX</span>   <span class="comment">-- 允许使用CREATE INDEX和DROP INDEX</span></span><br><span class="line"><span class="keyword">INSERT</span>  <span class="comment">-- 允许使用INSERT</span></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span>     <span class="comment">-- 允许对您拥有SELECT权限的表使用LOCK TABLES</span></span><br><span class="line">PROCESS     <span class="comment">-- 允许使用SHOW FULL PROCESSLIST</span></span><br><span class="line"><span class="keyword">REFERENCES</span>  <span class="comment">-- 未被实施</span></span><br><span class="line">RELOAD  <span class="comment">-- 允许使用FLUSH</span></span><br><span class="line"><span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span>  <span class="comment">-- 允许用户询问从属服务器或主服务器的地址</span></span><br><span class="line"><span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>   <span class="comment">-- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="comment">-- 允许使用SELECT</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>  <span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VIEW</span>   <span class="comment">-- 允许使用SHOW CREATE VIEW</span></span><br><span class="line"><span class="keyword">SHUTDOWN</span>    <span class="comment">-- 允许使用mysqladmin shutdown</span></span><br><span class="line">SUPER   <span class="comment">-- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span></span><br><span class="line"><span class="keyword">UPDATE</span>  <span class="comment">-- 允许使用UPDATE</span></span><br><span class="line"><span class="keyword">USAGE</span>   <span class="comment">-- “无权限”的同义词</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">OPTION</span>    <span class="comment">-- 允许授予权限</span></span><br></pre></td></tr></table></figure><h2 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分析和存储表的关键字分布</span></span><br><span class="line"><span class="keyword">ANALYZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> 表名 ...</span><br><span class="line"><span class="comment">-- 检查一个或多个表是否有错误</span></span><br><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [<span class="keyword">option</span>] ...</span><br><span class="line"><span class="keyword">option</span> = &#123;<span class="keyword">QUICK</span> | <span class="keyword">FAST</span> | <span class="keyword">MEDIUM</span> | <span class="keyword">EXTENDED</span> | <span class="keyword">CHANGED</span>&#125;</span><br><span class="line"><span class="comment">-- 整理数据文件的碎片</span></span><br><span class="line"><span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line"><span class="number">2.</span> 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line"><span class="number">3.</span> 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 <span class="comment">/* 注释内容 */</span></span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line"><span class="number">4.</span> 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 '</span><br><span class="line"><span class="number">5.</span> CMD命令行内的语句结束符可以为 <span class="string">";"</span>, <span class="string">"G"</span>, <span class="string">"g"</span>，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line"><span class="number">6.</span> SQL对大小写不敏感</span><br><span class="line"><span class="number">7.</span> 清除已有语句：c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://www.shado.com.cn/tags/mysql/"/>
    
      <category term="sql" scheme="https://www.shado.com.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师之路</title>
    <link href="https://www.shado.com.cn/2017/04/20/2017-04-20-to-be-java-coder/"/>
    <id>https://www.shado.com.cn/2017/04/20/2017-04-20-to-be-java-coder/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java工程师之路"><a href="#Java工程师之路" class="headerlink" title="Java工程师之路"></a>Java工程师之路</h1><p><img src="https://img.shields.io/badge/version-v2.0.0-green.svg" alt> <img src="https://img.shields.io/badge/author-Hollis-yellow.svg" alt> <img src="https://img.shields.io/badge/license-GPL-blue.svg" alt></p><h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><ol><li><p>面向对象、面向过程</p></li><li><p>面向对象的三大基本特征和五大基本原则</p></li></ol><h4 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h4><ol><li><p>Java如何实现的平台无关</p></li><li><p>JVM还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</p></li></ol><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><ol><li><p>值传递、引用传递</p></li><li><p>为什么说Java中只有值传递</p></li></ol><h4 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h4><ol><li><p>什么是多态、方法重写与重载</p></li><li><p>Java的继承与实现</p></li><li><p>构造函数与默认构造函数</p></li><li><p>类变量、成员变量和局部变量</p></li><li><p>成员变量和方法作用域</p></li></ol><h3 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ol><li><p>7种基本数据类型：整型、浮点型、布尔型、字符型</p></li><li><p>整型中byte、short、int、long的取值范围</p></li><li><p>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</p></li></ol><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><ol><li><p>什么是包装类型、什么是基本类型、什么是自动拆装箱</p></li><li><p>Integer的缓存机制</p></li></ol><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ol><li><p>字符串的不可变性</p></li><li><p>JDK 6和JDK 7中substring的原理及区别、</p></li><li><p>replaceFirst、replaceAll、replace区别、</p></li><li><p>String对“+”的重载、字符串拼接的几种方式和区别</p></li><li><p>String.valueOf和Integer.toString的区别、</p></li><li><p>switch对String的支持</p></li><li><p>字符串池、常量池（运行时常量池、Class常量池）、intern</p></li></ol><h4 id="熟悉Java中各种关键字"><a href="#熟悉Java中各种关键字" class="headerlink" title="熟悉Java中各种关键字"></a>熟悉Java中各种关键字</h4><ol><li>transient、instanceof、volatile、synchronized、final、static、const 原理及用法。</li></ol><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><ol><li><p>常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、</p></li><li><p>Set和List区别？Set如何保证元素不重复？</p></li><li><p>Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因</p></li><li><p>Collection和Collections区别</p></li><li><p>Arrays.asList获得的List使用时需要注意什么</p></li><li><p>Enumeration和Iterator区别</p></li><li><p>fail-fast 和 fail-safe</p></li><li><p>CopyOnWriteArrayList、ConcurrentSkipListMap</p></li></ol><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ol><li><p>枚举的用法、枚举的实现、枚举与单例、Enum类</p></li><li><p>Java枚举如何比较</p></li><li><p>switch对枚举的支持</p></li><li><p>枚举的序列化如何实现</p></li><li><p>枚举的线程安全性问题</p></li></ol><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><ol><li><p>字符流、字节流、输入流、输出流、</p></li><li><p>同步、异步、阻塞、非阻塞、Linux 5种IO模型</p></li><li><p>BIO、NIO和AIO的区别、三种IO的用法与原理、netty</p></li></ol><h4 id="Java反射与javassist"><a href="#Java反射与javassist" class="headerlink" title="Java反射与javassist"></a>Java反射与javassist</h4><ol><li><p>反射与工厂模式、 反射有什么作用</p></li><li><p>Class类</p></li><li><p><code>java.lang.reflect.*</code></p></li></ol><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ol><li><p>静态代理、动态代理</p></li><li><p>动态代理和反射的关系</p></li><li><p>动态代理的几种实现方式</p></li><li><p>AOP</p></li></ol><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ol><li>什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</li></ol><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ol><li><p>元注解、自定义注解、Java中常用注解使用、注解与反射的结合</p></li><li><p>Spring常用注解</p></li></ol><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><ol><li>什么是Java消息服务、JMS消息传送模型</li></ol><h4 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h4><ol><li><code>java.lang.management.*</code>、 <code>javax.management.*</code></li></ol><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ol><li><p>泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法</p></li><li><p>限定通配符和非限定通配符、上下界限定符extends 和 super</p></li><li><p>List<object>和原始类型List之间的区别?</object></p></li><li><p>List&lt;?&gt;和List<object>之间的区别是什么?</object></p></li></ol><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ol><li>junit、mock、mockito、内存数据库（h2）</li></ol><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ol><li><code>java.lang.util.regex.*</code></li></ol><h4 id="常用的Java工具库"><a href="#常用的Java工具库" class="headerlink" title="常用的Java工具库"></a>常用的Java工具库</h4><ol><li><code>commons.lang</code>, <code>commons.*...</code> <code>guava-libraries</code> <code>netty</code></li></ol><h4 id="API-amp-SPI"><a href="#API-amp-SPI" class="headerlink" title="API&amp;SPI"></a>API&amp;SPI</h4><ol><li><p>API、API和SPI的关系和区别</p></li><li><p>如何定义SPI、SPI的实现原理</p></li></ol><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ol><li><p>异常类型、正确处理异常、自定义异常</p></li><li><p>Error和Exception</p></li><li><p>异常链、try-with-resources</p></li><li><p>finally和return的执行顺序</p></li></ol><h4 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h4><ol><li><p>时区、冬令时和夏令时、时间戳、Java中时间API</p></li><li><p>格林威治时间、CET,UTC,GMT,CST几种常见时间的含义和关系</p></li><li><p>SimpleDateFormat的线程安全性问题</p></li><li><p>Java 8中的时间处理</p></li><li><p>如何在东八区的计算机上获取美国时间</p></li></ol><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><ol><li><p>Unicode、有了Unicode为啥还需要UTF-8</p></li><li><p>GBK、GB2312、GB18030之间的区别</p></li><li><p>UTF8、UTF16、UTF32区别</p></li><li><p>URL编解码、Big Endian和Little Endian</p></li><li><p>如何解决乱码问题</p></li></ol><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><ol><li><p>Java中语法糖原理、解语法糖</p></li><li><p>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda表达式、</p></li></ol><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><ol><li>String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</li></ol><h3 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h3><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><ol><li><p>什么是并发</p></li><li><p>什么是并行</p></li><li><p>并发与并行的区别</p></li></ol><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ol><li><p>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程</p></li><li><p>线程与进程的区别</p></li></ol><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ol><li><p>自己设计线程池、submit() 和 execute()、线程池原理</p></li><li><p>为什么不允许使用Executors创建线程池</p></li></ol><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ol><li>死锁、死锁如何排查、线程安全和内存模型的关系</li></ol><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ol><li><p>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、</p></li><li><p>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p></li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ol><li><p>死锁的原因</p></li><li><p>死锁的解决办法</p></li></ol><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ol><li><p>synchronized是如何实现的？</p></li><li><p>synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例</p></li><li><p>synchronized和原子性、可见性和有序性之间的关系</p></li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol><li><p>happens-before、内存屏障、编译器指令重排和CPU指令重排</p></li><li><p>volatile的实现原理</p></li><li><p>volatile和原子性、可见性和有序性之间的关系</p></li><li><p>有了symchronized为什么还需要volatile</p></li></ol><h4 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep 和 wait"></a>sleep 和 wait</h4><h4 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait 和 notify"></a>wait 和 notify</h4><h4 id="notify-和-notifyAll"><a href="#notify-和-notifyAll" class="headerlink" title="notify 和 notifyAll"></a>notify 和 notifyAll</h4><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h4 id="写一个死锁的程序"><a href="#写一个死锁的程序" class="headerlink" title="写一个死锁的程序"></a>写一个死锁的程序</h4><h4 id="写代码来解决生产者消费者问题"><a href="#写代码来解决生产者消费者问题" class="headerlink" title="写代码来解决生产者消费者问题"></a>写代码来解决生产者消费者问题</h4><h3 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h3><h4 id="阅读源代码，并学会使用"><a href="#阅读源代码，并学会使用" class="headerlink" title="阅读源代码，并学会使用"></a>阅读源代码，并学会使用</h4><ol><li>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors</li></ol><h2 id="二、底层篇"><a href="#二、底层篇" class="headerlink" title="二、底层篇"></a>二、底层篇</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><ol><li><p>class文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、</p></li><li><p>堆和栈区别</p></li><li><p>Java中的对象一定在堆上分配吗？</p></li></ol><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><ol><li><p>计算机内存模型、缓存一致性、MESI协议</p></li><li><p>可见性、原子性、顺序性、happens-before、</p></li><li><p>内存屏障、synchronized、volatile、final、锁</p></li></ol><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ol><li><p>GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</p></li><li><p>GC参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）</p></li></ol><h4 id="JVM参数及调优"><a href="#JVM参数及调优" class="headerlink" title="JVM参数及调优"></a>JVM参数及调优</h4><ol><li><p>-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、</p></li><li><p>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold</p></li></ol><h4 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h4><ol><li>oop-klass、对象头</li></ol><h4 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h4><ol><li>即时编译器、编译优化</li></ol><h4 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h4><ol><li><p>jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler</p></li><li><p>Arthas</p></li></ol><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ol><li>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</li></ol><h3 id="编译与反编译"><a href="#编译与反编译" class="headerlink" title="编译与反编译"></a>编译与反编译</h3><ol><li><p>什么是编译（前端编译、后端编译）、什么是反编译</p></li><li><p>JIT、JIT优化（逃逸分析、栈上分配、标量替换、锁优化）</p></li><li><p>编译工具：javac</p></li><li><p>反编译工具：javap 、jad 、CRF</p></li></ol><h2 id="三、-进阶篇"><a href="#三、-进阶篇" class="headerlink" title="三、 进阶篇"></a>三、 进阶篇</h2><h3 id="Java底层知识"><a href="#Java底层知识" class="headerlink" title="Java底层知识"></a>Java底层知识</h3><h4 id="字节码、class文件格式"><a href="#字节码、class文件格式" class="headerlink" title="字节码、class文件格式"></a>字节码、class文件格式</h4><h4 id="CPU缓存，L1，L2，L3和伪共享"><a href="#CPU缓存，L1，L2，L3和伪共享" class="headerlink" title="CPU缓存，L1，L2，L3和伪共享"></a>CPU缓存，L1，L2，L3和伪共享</h4><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ol><li>用位运算实现加、减、乘、除、取余</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ol><li><p>设计模式的六大原则：</p></li><li><p>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）</p></li><li><p>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）</p></li></ol><h4 id="了解23种设计模式"><a href="#了解23种设计模式" class="headerlink" title="了解23种设计模式"></a>了解23种设计模式</h4><ol><li><p>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p></li><li><p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p></li><li><p>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p></li></ol><h4 id="会使用常用设计模式"><a href="#会使用常用设计模式" class="headerlink" title="会使用常用设计模式"></a>会使用常用设计模式</h4><ol><li><p>单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁</p></li><li><p>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会</p></li></ol><h4 id="不用synchronized和lock，实现线程安全的单例模式"><a href="#不用synchronized和lock，实现线程安全的单例模式" class="headerlink" title="不用synchronized和lock，实现线程安全的单例模式"></a>不用synchronized和lock，实现线程安全的单例模式</h4><h4 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h4><h4 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h4><h4 id="nio和reactor设计模式"><a href="#nio和reactor设计模式" class="headerlink" title="nio和reactor设计模式"></a>nio和reactor设计模式</h4><h3 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h3><h4 id="tcp、udp、http、https等常用协议"><a href="#tcp、udp、http、https等常用协议" class="headerlink" title="tcp、udp、http、https等常用协议"></a>tcp、udp、http、https等常用协议</h4><ol><li>三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包</li></ol><h4 id="http-1-0-http-1-1-http-2之间的区别"><a href="#http-1-0-http-1-1-http-2之间的区别" class="headerlink" title="http/1.0 http/1.1 http/2之间的区别"></a>http/1.0 http/1.1 http/2之间的区别</h4><ol><li><p>http中 get和post区别</p></li><li><p>常见的web请求返回的状态码</p></li><li><p>404、302、301、500分别代表什么</p></li></ol><h4 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h4><h4 id="Java-RMI，Socket，HttpClient"><a href="#Java-RMI，Socket，HttpClient" class="headerlink" title="Java RMI，Socket，HttpClient"></a>Java RMI，Socket，HttpClient</h4><h4 id="cookie-与-session"><a href="#cookie-与-session" class="headerlink" title="cookie 与 session"></a>cookie 与 session</h4><ol><li>cookie被禁用，如何实现session</li></ol><h4 id="用Java写一个简单的静态文件的HTTP服务器"><a href="#用Java写一个简单的静态文件的HTTP服务器" class="headerlink" title="用Java写一个简单的静态文件的HTTP服务器"></a>用Java写一个简单的静态文件的HTTP服务器</h4><h4 id="了解nginx和apache服务器的特性并搭建一个对应的服务器"><a href="#了解nginx和apache服务器的特性并搭建一个对应的服务器" class="headerlink" title="了解nginx和apache服务器的特性并搭建一个对应的服务器"></a>了解nginx和apache服务器的特性并搭建一个对应的服务器</h4><h4 id="用Java实现FTP、SMTP协议"><a href="#用Java实现FTP、SMTP协议" class="headerlink" title="用Java实现FTP、SMTP协议"></a>用Java实现FTP、SMTP协议</h4><h4 id="进程间通讯的方式"><a href="#进程间通讯的方式" class="headerlink" title="进程间通讯的方式"></a>进程间通讯的方式</h4><h4 id="什么是CDN？如果实现？"><a href="#什么是CDN？如果实现？" class="headerlink" title="什么是CDN？如果实现？"></a>什么是CDN？如果实现？</h4><h4 id="DNS？"><a href="#DNS？" class="headerlink" title="DNS？"></a>DNS？</h4><ol><li><p>什么是DNS 、记录类型:A记录、CNAME记录、AAAA记录等</p></li><li><p>域名解析、根域名服务器</p></li><li><p>DNS污染、DNS劫持、公共DNS：114 DNS、Google DNS、OpenDNS</p></li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ol><li><p>正向代理、反向代理</p></li><li><p>反向代理服务器</p></li></ol><h3 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h3><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><ol><li><p>生命周期</p></li><li><p>线程安全问题</p></li><li><p>filter和listener</p></li><li><p>web.xml中常用配置及作用</p></li></ol><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><ol><li><p>什么是OR Mapping</p></li><li><p>Hibernate的缓存机制</p></li><li><p>Hibernate的懒加载</p></li><li><p>Hibernate/Ibatis/MyBatis之间的区别</p></li></ol><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ol><li><p>Bean的初始化</p></li><li><p>AOP原理</p></li><li><p>实现Spring的IOC</p></li><li><p>spring四种依赖注入方式</p></li></ol><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><ol><li><p>什么是MVC</p></li><li><p>Spring mvc与Struts mvc的区别</p></li></ol><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><ol><li><p>Spring Boot 2.0、起步依赖、自动配置、</p></li><li><p>Spring Boot的starter原理，自己实现一个starter</p></li></ol><h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ol><li><p>服务发现与注册：Eureka、Zookeeper、Consul</p></li><li><p>负载均衡：Feign、Spring Cloud Loadbalance</p></li><li><p>服务配置：Spring Cloud Config</p></li><li><p>服务限流与熔断：Hystrix</p></li><li><p>服务链路追踪：Dapper</p></li><li><p>服务网关、安全、消息</p></li></ol><h3 id="应用服务器知识"><a href="#应用服务器知识" class="headerlink" title="应用服务器知识"></a>应用服务器知识</h3><h4 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h4><h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h4><h4 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h4><h4 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h4><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="git-amp-svn"><a href="#git-amp-svn" class="headerlink" title="git &amp; svn"></a>git &amp; svn</h4><h4 id="maven-amp-gradle"><a href="#maven-amp-gradle" class="headerlink" title="maven &amp; gradle"></a>maven &amp; gradle</h4><h4 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h4><ol><li><p>常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat、aceJump</p></li><li><p>Lombok plugin、.ignore、Mybatis plugin</p></li></ol><h2 id="四、-高级篇"><a href="#四、-高级篇" class="headerlink" title="四、 高级篇"></a>四、 高级篇</h2><h3 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h3><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h4><ol><li>lambda表达式、Stream API、时间API</li></ol><h4 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h4><ol><li>Jigsaw、Jshell、Reactive Streams</li></ol><h4 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h4><ol><li>局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制</li></ol><h4 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h4><ol><li>ZGC、Epsilon、增强var、</li></ol><h4 id="Spring-5"><a href="#Spring-5" class="headerlink" title="Spring 5"></a>Spring 5</h4><ol><li>响应式编程</li></ol><h4 id="Spring-Boot-2-0"><a href="#Spring-Boot-2-0" class="headerlink" title="Spring Boot 2.0"></a>Spring Boot 2.0</h4><h3 id="http-2"><a href="#http-2" class="headerlink" title="http/2"></a>http/2</h3><h3 id="http-3-1"><a href="#http-3-1" class="headerlink" title="http/3"></a>http/3</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</li></ol><h3 id="线上问题分析"><a href="#线上问题分析" class="headerlink" title="线上问题分析"></a>线上问题分析</h3><h4 id="dump获取"><a href="#dump获取" class="headerlink" title="dump获取"></a>dump获取</h4><ol><li>线程Dump、内存Dump、gc情况</li></ol><h4 id="dump分析"><a href="#dump分析" class="headerlink" title="dump分析"></a>dump分析</h4><ol><li>分析死锁、分析内存泄露</li></ol><h4 id="dump分析及获取工具"><a href="#dump分析及获取工具" class="headerlink" title="dump分析及获取工具"></a>dump分析及获取工具</h4><ol><li>jstack、jstat、jmap、jhat、Arthas</li></ol><h4 id="自己编写各种outofmemory，stackoverflow程序"><a href="#自己编写各种outofmemory，stackoverflow程序" class="headerlink" title="自己编写各种outofmemory，stackoverflow程序"></a>自己编写各种outofmemory，stackoverflow程序</h4><ol><li>HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow</li></ol><h4 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h4><ol><li><p>jvm相关、class/classloader相关、monitor/watch/trace相关、</p></li><li><p>options、管道、后台异步任务</p></li><li><p>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/advanced-use.html</a></p></li></ol><h4 id="常见问题解决思路"><a href="#常见问题解决思路" class="headerlink" title="常见问题解决思路"></a>常见问题解决思路</h4><ol><li>内存溢出、线程死锁、类加载冲突</li></ol><h4 id="使用工具尝试解决以下问题，并写下总结"><a href="#使用工具尝试解决以下问题，并写下总结" class="headerlink" title="使用工具尝试解决以下问题，并写下总结"></a>使用工具尝试解决以下问题，并写下总结</h4><ol><li><p>当一个Java程序响应很慢时如何查找问题、</p></li><li><p>当一个Java程序频繁FullGC时如何解决问题、</p></li><li><p>如何查看垃圾回收日志、</p></li><li><p>当一个Java应用发生OutOfMemory时该如何解决、</p></li><li><p>如何判断是否出现死锁、</p></li><li><p>如何判断是否存在内存泄露</p></li><li><p>使用Arthas快速排查Spring Boot应用404/401问题</p></li><li><p>使用Arthas排查线上应用日志打满问题</p></li><li><p>利用Arthas排查Spring Boot应用NoSuchMethodError</p></li></ol><h3 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h3><h4 id="编译与反编译-1"><a href="#编译与反编译-1" class="headerlink" title="编译与反编译"></a>编译与反编译</h4><h4 id="Java代码的编译与反编译"><a href="#Java代码的编译与反编译" class="headerlink" title="Java代码的编译与反编译"></a>Java代码的编译与反编译</h4><h4 id="Java的反编译工具"><a href="#Java的反编译工具" class="headerlink" title="Java的反编译工具"></a>Java的反编译工具</h4><ol><li>javap 、jad 、CRF</li></ol><h4 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h4><h4 id="词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化"><a href="#词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化" class="headerlink" title="词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化"></a>词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化</h4><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><h4 id="Linux的常用命令"><a href="#Linux的常用命令" class="headerlink" title="Linux的常用命令"></a>Linux的常用命令</h4><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><ol><li>生产者消费者问题、哲学家就餐问题、读者写者问题</li></ol><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><h4 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h4><h4 id="虚拟内存与主存"><a href="#虚拟内存与主存" class="headerlink" title="虚拟内存与主存"></a>虚拟内存与主存</h4><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><h4 id="换页算法"><a href="#换页算法" class="headerlink" title="换页算法"></a>换页算法</h4><h3 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h3><h4 id="MySql-执行引擎"><a href="#MySql-执行引擎" class="headerlink" title="MySql 执行引擎"></a>MySql 执行引擎</h4><h4 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h4><ol><li>如何查看执行计划，如何根据执行计划进行SQL优化</li></ol><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ol><li><p>Hash索引、B树索引（B+树、和B树、R树）</p></li><li><p>普通索引、唯一索引</p></li><li><p>覆盖索引、最左前缀原则、索引下推</p></li></ol><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h4 id="数据库事务和隔离级别"><a href="#数据库事务和隔离级别" class="headerlink" title="数据库事务和隔离级别"></a>数据库事务和隔离级别</h4><ol><li>事务的隔离级别、事务能不能实现锁的功能</li></ol><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><ol><li>行锁、表锁、使用数据库锁实现乐观锁、</li></ol><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ol><li>内连接，左连接，右连接</li></ol><h4 id="数据库主备搭建"><a href="#数据库主备搭建" class="headerlink" title="数据库主备搭建"></a>数据库主备搭建</h4><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><h4 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h4><h4 id="内存数据库"><a href="#内存数据库" class="headerlink" title="内存数据库"></a>内存数据库</h4><ol><li>h2</li></ol><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><h4 id="常用的nosql数据库"><a href="#常用的nosql数据库" class="headerlink" title="常用的nosql数据库"></a>常用的nosql数据库</h4><ol><li>redis、memcached</li></ol><h4 id="分别使用数据库锁、NoSql实现分布式锁"><a href="#分别使用数据库锁、NoSql实现分布式锁" class="headerlink" title="分别使用数据库锁、NoSql实现分布式锁"></a>分别使用数据库锁、NoSql实现分布式锁</h4><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><h3 id="数据结构与算法知识"><a href="#数据结构与算法知识" class="headerlink" title="数据结构与算法知识"></a>数据结构与算法知识</h3><h4 id="简单的数据结构"><a href="#简单的数据结构" class="headerlink" title="简单的数据结构"></a>简单的数据结构</h4><ol><li><p>栈、队列、链表、数组、哈希表、</p></li><li><p>栈和队列的相同和不同之处</p></li><li><p>栈通常采用的两种存储结构</p></li></ol><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><ol><li>二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ol><li>大根堆、小根堆</li></ol><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ol><li>有向图、无向图、拓扑</li></ol><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ol><li><p>稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序</p></li><li><p>不稳定的排序：选择排序、希尔排序、Clover排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序</p></li><li><p>各种排序算法和时间复杂度</p></li></ol><h4 id="深度优先和广度优先搜索"><a href="#深度优先和广度优先搜索" class="headerlink" title="深度优先和广度优先搜索"></a>深度优先和广度优先搜索</h4><h4 id="全排列、贪心算法、KMP算法、hash算法"><a href="#全排列、贪心算法、KMP算法、hash算法" class="headerlink" title="全排列、贪心算法、KMP算法、hash算法"></a>全排列、贪心算法、KMP算法、hash算法</h4><h4 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h4><ol><li>分治，hash映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce等。</li></ol><h4 id="两个栈实现队列，和两个队列实现栈"><a href="#两个栈实现队列，和两个队列实现栈" class="headerlink" title="两个栈实现队列，和两个队列实现栈"></a>两个栈实现队列，和两个队列实现栈</h4><h3 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h3><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><ol><li>基本概念、常见用法</li></ol><h4 id="Solr，Lucene，ElasticSearch"><a href="#Solr，Lucene，ElasticSearch" class="headerlink" title="Solr，Lucene，ElasticSearch"></a>Solr，Lucene，ElasticSearch</h4><ol><li>在linux上部署solr，solrcloud，，新增、删除、查询索引</li></ol><h4 id="Storm，流式计算，了解Spark，S4"><a href="#Storm，流式计算，了解Spark，S4" class="headerlink" title="Storm，流式计算，了解Spark，S4"></a>Storm，流式计算，了解Spark，S4</h4><ol><li>在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。</li></ol><h4 id="Hadoop，离线计算"><a href="#Hadoop，离线计算" class="headerlink" title="Hadoop，离线计算"></a>Hadoop，离线计算</h4><ol><li>HDFS、MapReduce</li></ol><h4 id="分布式日志收集flume，kafka，logstash"><a href="#分布式日志收集flume，kafka，logstash" class="headerlink" title="分布式日志收集flume，kafka，logstash"></a>分布式日志收集flume，kafka，logstash</h4><h4 id="数据挖掘，mahout"><a href="#数据挖掘，mahout" class="headerlink" title="数据挖掘，mahout"></a>数据挖掘，mahout</h4><h3 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ol><li>XSS的防御</li></ol><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><ol><li>SQL注入、XML注入、CRLF注入</li></ol><h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><ol><li><p>对称加密、非对称加密、哈希算法、加盐哈希算法</p></li><li><p>MD5，SHA1、DES、AES、RSA、DSA</p></li><li><p>彩虹表</p></li></ol><h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><ol><li><p>DOS攻击、DDOS攻击</p></li><li><p>memcached为什么可以导致DDos攻击、什么是反射型DDoS</p></li><li><p>如何通过Hash碰撞进行DOS攻击</p></li></ol><h4 id="SSL、TLS，HTTPS"><a href="#SSL、TLS，HTTPS" class="headerlink" title="SSL、TLS，HTTPS"></a>SSL、TLS，HTTPS</h4><h4 id="用openssl签一个证书部署到apache或nginx"><a href="#用openssl签一个证书部署到apache或nginx" class="headerlink" title="用openssl签一个证书部署到apache或nginx"></a>用openssl签一个证书部署到apache或nginx</h4><h2 id="五、架构篇"><a href="#五、架构篇" class="headerlink" title="五、架构篇"></a>五、架构篇</h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ol><li>数据一致性、服务治理、服务降级</li></ol><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ol><li>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC</li></ol><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><ol><li><p>服务注册、服务发现，服务治理</p></li><li><p><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a></p></li></ol><h4 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h4><ol><li>怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase</li></ol><h4 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h4><ol><li>mfs、fastdfs</li></ol><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><ol><li>缓存一致性、缓存命中率、缓存冗余</li></ol><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><ol><li>Hystrix、Sentinal</li></ol><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li><p>共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法</p></li><li><p>2PC、3PC</p></li></ol><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ol><li>SOA、康威定律</li></ol><h4 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h4><ol><li>sidecar</li></ol><h4 id="Docker-amp-Kubernets"><a href="#Docker-amp-Kubernets" class="headerlink" title="Docker &amp; Kubernets"></a>Docker &amp; Kubernets</h4><h4 id="Spring-Boot-1"><a href="#Spring-Boot-1" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><h4 id="Spring-Cloud-1"><a href="#Spring-Cloud-1" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><h4 id="分库分表-1"><a href="#分库分表-1" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="CDN技术"><a href="#CDN技术" class="headerlink" title="CDN技术"></a>CDN技术</h4><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ol><li>ActiveMQ</li></ol><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="监控什么"><a href="#监控什么" class="headerlink" title="监控什么"></a>监控什么</h4><ol><li>CPU、内存、磁盘I/O、网络I/O等</li></ol><h4 id="监控手段"><a href="#监控手段" class="headerlink" title="监控手段"></a>监控手段</h4><ol><li>进程监控、语义监控、机器资源监控、数据波动</li></ol><h4 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h4><ol><li>日志、埋点</li></ol><h4 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h4><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ol><li><p>tomcat负载均衡、Nginx负载均衡</p></li><li><p>四层负载均衡、七层负载均衡</p></li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ol><li>DNS原理、DNS的设计</li></ol><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol><li>数据一致性</li></ol><h2 id="六、-扩展篇"><a href="#六、-扩展篇" class="headerlink" title="六、 扩展篇"></a>六、 扩展篇</h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><ol><li>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</li></ol><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ol><li>Solr、Lucene、Nutch、Elasticsearch</li></ol><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ol><li>Shiro</li></ol><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><ol><li>哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名</li></ol><h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><ol><li>挖矿、共识机制、闪电网络、侧链、热点问题、分叉</li></ol><h4 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h4><h4 id="超级账本"><a href="#超级账本" class="headerlink" title="超级账本"></a>超级账本</h4><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><ol><li>数学基础、机器学习、人工神经网络、深度学习、应用场景。</li></ol><h4 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h4><ol><li>TensorFlow、DeepLearning4J</li></ol><h3 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h3><h3 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h3><h3 id="AR-amp-VR"><a href="#AR-amp-VR" class="headerlink" title="AR &amp; VR"></a>AR &amp; VR</h3><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><ol><li>Groovy、Python、Go、NodeJs、Swift、Rust</li></ol><h2 id="六、-推荐书籍"><a href="#六、-推荐书籍" class="headerlink" title="六、 推荐书籍"></a>六、 推荐书籍</h2><ol><li>《深入理解Java虚拟机》</li><li>《Effective Java》</li><li>《深入分析Java Web技术内幕》</li><li>《大型网站技术架构》</li><li>《代码整洁之道》</li><li>《架构整洁之道》</li><li>《Head First设计模式》</li><li>《maven实战》</li><li>《区块链原理、设计与应用》</li><li>《Java并发编程实战》</li><li>《鸟哥的Linux私房菜》</li><li>《从Paxos到Zookeeper》</li><li>《架构即未来》</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://www.shado.com.cn/2017/04/15/2017-04-15-spring-introduction/"/>
    <id>https://www.shado.com.cn/2017/04/15/2017-04-15-spring-introduction/</id>
    <published>2017-04-14T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>为什么要使用Spring？</p><p>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p><ul><li>DI（Dependency Injection，依赖注入）</li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul><h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>每一个类实现了Bean的规范才可以由Spring来接管，那么Bean的规范是什么呢？</p><ul><li>必须是个公有(public)类</li><li>有无参构造函数</li><li>用公共方法暴露内部成员属性(getter,setter)</li></ul><p>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</p><h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI-依赖注入"></a>DI-依赖注入</h3><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p><h3 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP-面向切面编程"></a>AOP-面向切面编程</h3><p>就以日志系统为例。在执行某个操作前后都需要输出日志，如果手工加代码，那简直太可怕了。而且等代码庞大起来，也是非常难维护的一种情况。这里就需要面向切面来编程</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="关于Bean"><a href="#关于Bean" class="headerlink" title="关于Bean"></a>关于Bean</h3><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。我们对图进行详细描述：</p><ol><li>Spring对bean进行实例化；</li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</li><li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ol><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p><ul><li>单例（Singleton）：在整个应用中，只创建bean的一个实例。</li><li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li><li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li></ul><p>在代码里看起来是这样的：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Scope</span>(<span class="type">ConfigurableBeanFactory</span>.<span class="type">SCOPE_PROTOTYPE</span>)</span><br><span class="line">public class <span class="type">MyIsBean</span><span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure></p><p>XML版本：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"BEANID"</span></span><br><span class="line">  <span class="built_in">class</span> = <span class="string">"net.itxm.beans"</span></span><br><span class="line">  scope=<span class="string">"prototype"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p><p>在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><p>有时候，可能会发现，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。</p><h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><p>以下是声明Bean的注解：</p><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层使用</li><li>@Repository 在数据访问层使用</li><li>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用</li><li>在这里，可以指定bean的id名：Component(“yourBeanName”)</li><li>同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</li></ul><h3 id="关于依赖注入"><a href="#关于依赖注入" class="headerlink" title="关于依赖注入"></a>关于依赖注入</h3><h4 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h4><p><strong>@Autowired Spring提供的注解</strong></p><p>不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。</p><p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。</p><p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。</p><p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。</p><p><code>@Inject</code>注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持<code>@Inject</code>和<code>@Autowired</code>。尽管<code>@Inject</code>和<code>@Autowired</code>之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p><p><code>@Autowired</code> 是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和<code>@Autowired</code> 相近：</p><p><code>@Inject</code> 是JSR-330提供的注解<br><code>@Resource</code> 是JSR-250提供的注解</p><h4 id="条件化的Bean"><a href="#条件化的Bean" class="headerlink" title="条件化的Bean"></a>条件化的Bean</h4><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。</p><p>在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。</p><p>通过ConditionContext，我们可以做到如下几点：</p><ul><li>借助getRegistry()返回的BeanDefinitionRegistry检查bean定义；</li><li>借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性；</li><li>借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么；</li><li>读取并探查getResourceLoader()返回的ResourceLoader所加载的资源；</li><li>借助getClassLoader()返回的ClassLoader加载并检查类是否存在。</li></ul><h4 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h4><p><strong>标示首选的bean</strong></p><p>在声明bean的时候，通过将其中一个可选的bean设置为首选（primary）bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其他可选的bean。实际上，你所声明就是“最喜欢”的bean。</p><p><strong>限定自动装配的bean</strong></p><p>设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义性的选项中。它只能标示一个优先的可选方案。当首选bean的数量超过一个时，我们并没有其他的方法进一步缩小可选范围。</p><p>与之相反，Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小选择范围。</p><p><code>@Qualifier</code>注解是使用限定符的主要方式。它可以与<code>@Autowired</code>和<code>@Inject</code>协同使用，在注入的时候指定想要注入进去的是哪个bean。例如，我们想要确保要将IceCream注入到setDessert()之中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是使用限定符的最简单的例子。为<code>@Qualifier</code>注解所设置的参数就是想要注入的bean的ID。所有使用<code>@Component</code>注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。因此，<code>@Qualifier(“iceCream”)</code>指向的是组件扫描时所创建的bean，并且这个bean是IceCream类的实例。</p><p>实际上，还有一点需要补充一下。更准确地讲，<code>@Qualifier(“iceCream”)</code>所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话，所有的bean都会给定一个默认的限定符，这个限定符与bean的ID相同。因此，框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean，它是IceCream类在组件扫描的时候创建的。</p><p>基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCream类，将其重命名为Gelato的话，那此时会发生什么情况呢？如果这样的话，bean的ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符。自动装配会失败。</p><p>这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失效。</p><h4 id="SpringEL"><a href="#SpringEL" class="headerlink" title="SpringEL"></a>SpringEL</h4><ul><li>Value实现资源的注入  </li></ul><h4 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h4><ul><li>Java配置方式：initMethod和destoryMethod</li><li>注解：@PostConstruct和@PreDestory</li></ul><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><p>提供在不同的环境下使用不同的配置</p><p><strong>激活Profile</strong></p><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。如果spring.profiles.active和spring.profiles.default均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。</p><p><strong>使用profile进行测试</strong></p><p>当运行集成测试时，通常会希望采用与生产环境（或者是生产环境的部分子集）相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在运行测试时，我们就需要有一种方式来启用合适的profile。</p><p>Spring提供了<code>@ActiveProfiles</code>注解，我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。</p><p>比如<code>Profile(“dev”)</code></p><h4 id="Application-Event"><a href="#Application-Event" class="headerlink" title="Application Event"></a>Application Event</h4><p>使用Application Event可以做到Bean与Bean之间的通信</p><p>Spring的事件需要遵循如下流程：</p><ul><li>自定义事件，集成ApplicationEvent</li><li>定义事件监听器，实现ApplicationListener</li><li>使用容器发布事件</li></ul><h3 id="关于AOP"><a href="#关于AOP" class="headerlink" title="关于AOP"></a>关于AOP</h3><h4 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h4><p><strong>通知（Advice）</strong></p><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p><p>Spring切面可以应用5种类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。  </li></ul><p>对应注解：</p><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>—-</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>—-</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>—-</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>—-</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr><tr><td>—-</td></tr></tbody></table><p><strong>连接点（Join point）</strong></p><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p><strong>切点（Pointcut）</strong></p><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处” 。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p><p><strong>切面（Aspect）</strong></p><p>通知+切点=切面</p><p><strong>引入（Introduction）</strong></p><p>引入允许我们向现有的类添加新方法或属性</p><p><strong>织入（Weaving）</strong></p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ul><h4 id="Spring对AOP的支持："><a href="#Spring对AOP的支持：" class="headerlink" title="Spring对AOP的支持："></a>Spring对AOP的支持：</h4><ol><li>基于代理的经典Spring AOP；</li><li>纯POJO切面（4.x版本需要XML配置）；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）。</li></ol><p><strong>例子</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Performance()&#123;</span><br><span class="line">  public void perform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来写一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* concert.Performance.perform(..)</span></span>)</span><br><span class="line"><span class="comment">//execution：在方法执行时触发</span></span><br><span class="line"><span class="comment">//*：返回任意类型</span></span><br><span class="line"><span class="comment">//concert.Performance：方法所属类</span></span><br><span class="line"><span class="comment">//perform：方法名</span></span><br><span class="line"><span class="comment">//(..)：使用任意参数</span></span><br></pre></td></tr></table></figure><p>不仅如此，还可以写的更复杂一点</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution<span class="comment">(* concert.Performance.perform(..)&amp;&amp;within(concert.*)</span>)</span><br><span class="line"><span class="comment">//增加了一个与操作，当concert包下的任意类方法被调用时也会触发</span></span><br></pre></td></tr></table></figure><p>在切点中选择bean</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(*concert.Performance.perform()</span></span>) and bean(<span class="string">'woodstock'</span>)</span><br><span class="line"><span class="comment">//限定bean id为woodstock</span></span><br></pre></td></tr></table></figure><p>来个完整的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span>&#123;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"execution(**concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"execution&#123;** concert.Performance.perform&#123;..&#125;&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"execution&#123;** concert.Performance.perform&#123;..&#125;&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterThrowing</span>(<span class="string">"execution&#123;** concert.Performance.perform&#123;..&#125;&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demanRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简化一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span>&#123;</span><br><span class="line">  <span class="comment">//避免频繁使用切点表达式</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demanRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XML中声明切面</strong></p><table><thead><tr><th>AOP配置元素</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;aop:advisor&gt;</code></td><td>定义AOP通知器</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:after&gt;</code></td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:after-returning&gt;</code></td><td>定义AOP返回通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:after-throwing&gt;</code></td><td>定义AOP异常通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:around&gt;</code></td><td>定义AOP环绕通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:aspect&gt;</code></td><td>定义一个切面</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:aspectj-autoproxy&gt;</code></td><td>启用@AspectJ注解驱动的切面</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:before&gt;</code></td><td>定义一个AOP前置通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:config&gt;</code></td><td>顶层的AOP配置元素。大多数的<a href="aop:*" target="_blank" rel="noopener">aop:*</a>元素必须包含在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>元素内</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:declare-parents&gt;</code></td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:pointcut&gt;</code></td><td>定义一个切点</td></tr><tr><td>—-</td></tr></tbody></table><p>来个栗子</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Audience</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过XML将无注解的Audience声明为切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"sillenceCellPhones"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"taskSeats"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"applause"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:After-throwing</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">"demanRefund"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AspectJ关于Spring AOP的AspectJ切点，最重要的一点就是Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。让我们回顾下，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。下表列出了Spring AOP所支持的AspectJ切点指示器。</p><p>Spring借助AspectJ的切点表达式语言来定义Spring切面</p><table><thead><tr><th>AspectJ指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><h3 id="Spring高级特性"><a href="#Spring高级特性" class="headerlink" title="Spring高级特性"></a>Spring高级特性</h3><p>由于Spring特殊的依赖注入技巧，导致Bean之间没有耦合度。</p><p>但是Bean有时需要使用spring容器本身的资源，这时你的Bean必须意识到Spring容器的存在。所以得使用Spring Aware，下面来看看Spring Aware提供的接口</p><table><thead><tr><th>BeanNameAware</th><th>获得到容器中Bean的名称</th></tr></thead><tbody><tr><td>BeanFactory</td><td>获得当前的bean factory，这样可以调用容器的服务</td></tr><tr><td>ApplicationContextAware*</td><td>当前application context，这样可以调用容器的服务</td></tr><tr><td>MessageSourceAware</td><td>获得Message source</td></tr><tr><td>ApplicationEventPublisherAware</td><td>应用时间发布器，可以发布时间，</td></tr><tr><td>ResourceLoaderAware</td><td>获得资源加载器，可以获得外部资源文件</td></tr></tbody></table><h4 id="TaskExecutor"><a href="#TaskExecutor" class="headerlink" title="@TaskExecutor"></a>@TaskExecutor</h4><p>这样可以实现多线程和并发编程。通过@EnableAsync开启对异步任务的支持，并通过实际执行的Bean的方法始中使用@Async注解来声明其是一个异步任务</p><h4 id="Scheduled-计划任务"><a href="#Scheduled-计划任务" class="headerlink" title="@Scheduled 计划任务"></a>@Scheduled 计划任务</h4><p>首先通过在配置类注解@EnableScheduling来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务</p><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>根据满足某一个特定条件创建一个特定的Bean。</p><h4 id="组合注解与元注解"><a href="#组合注解与元注解" class="headerlink" title="组合注解与元注解"></a>组合注解与元注解</h4><p>元注解就是可以注解到别的注解上的注解，被注解的注解称之为组合注解，组合注解具备注解其上的元注解的功能。</p><p><strong>@Enable*注解的工作原理</strong></p><p>通过观察这些@Enable*注解的源码，我们发现所有的注解都有一个@Import注解，@Import是用来导入配置类的，这也就意外着这些自动开启的实现其实是导入了一些自动配置的Bean。这些导入配置的方式主要范围以下三种类型：</p><ul><li>第一类：直接导入配置类</li><li>第二类：依据条件选择配置类</li><li>第三类：动态注册Bean</li></ul><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>简单的分析一下Spring。</p><p>Spring 框架中的核心组件只有三个：Core、Context 和 Bean。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。</p><h3 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h3><p>用过Spring的同学都知道Bean在Spring的作用是非常重要的。通过一系列简单的配置来满足类与类之间的依赖关系——这叫做依赖注入。而依赖注入的关系是在一个叫IOC的容器中进行管理。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>我们说到Spring 框架中的核心组件只有三个：<strong>Core</strong>、<strong>Context</strong> 和 <strong>Bean</strong>。那么Core和Context是如何协作的呢？</p><p>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器 ，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具。</p><h4 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h4><p>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。</p><p>ApplicationContext 的子类主要包含两个方面：</p><ul><li>ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext类。</li><li>WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。</li></ul><p>再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。</p><p>总体来说 ApplicationContext 必须要完成以下几件事：</p><ul><li>标识一个应用环境</li><li>利用 BeanFactory 创建 Bean 对象</li><li>保存对象关系表</li><li>能够捕获各种事件</li></ul><p>Context 作为 Spring 的 IOC 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="spring" scheme="https://www.shado.com.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://www.shado.com.cn/2017/04/08/2017-04-08-mybatis-introduction/"/>
    <id>https://www.shado.com.cn/2017/04/08/2017-04-08-mybatis-introduction/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2019-05-21T02:33:47.871Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p><strong>使用JDBC编程问题总结</strong><br><strong>1.JDBC编程步骤</strong>  </p><ol><li>加载数据库驱动</li><li>创建并获取数据库链接</li><li>创建jdbc statement对象</li><li>设置sql语句</li><li>设置sql语句中的参数(使用preparedStatement)</li><li>通过statement执行sql并获取结果</li><li>对sql执行结果进行解析处理</li><li>释放资源(resultSet、preparedstatement、connection)</li></ol><p><strong>2.JDBC问题总结</strong>  </p><ol><li>数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。</li><li>Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。</li><li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。  </li></ol><h3 id="1-MyBatis介绍"><a href="#1-MyBatis介绍" class="headerlink" title="1. MyBatis介绍"></a>1. MyBatis介绍</h3><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。<br>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。<br><strong>MyBatis架构</strong><br><img src="/2017/04/08/2017-04-08-mybatis-introduction/mybatis-architecture.png" alt="MyBatis架构"></p><h3 id="2-MyBatis配置"><a href="#2-MyBatis配置" class="headerlink" title="2. MyBatis配置"></a>2. MyBatis配置</h3><ol><li>mybatis配置<br>SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。<br>mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。  </li><li>通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂</li><li>由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。</li><li>mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。</li><li>Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。</li><li>Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。</li><li>Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。</li></ol><h4 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h4><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String<span class="built_in"> resource </span>= <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p><p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。这里先给出一个简单的示例：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE configuration</span></span></span><br><span class="line"><span class="xml">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="xml">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;driver&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;username&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;password&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。</p><h3 id="3-Mapper-XML-文件"><a href="#3-Mapper-XML-文件" class="headerlink" title="3. Mapper XML 文件"></a>3. Mapper XML 文件</h3><p>MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。</p><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><ul><li><code>cache</code> – 给定命名空间的缓存配置。</li><li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li><li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li><li><code>parameterMap</code> – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</li><li><code>sql</code> – 可被其他语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句</li><li><code>update</code> – 映射更新语句</li><li><code>delete</code> – 映射删除语句</li><li><code>select</code> – 映射查询语句</li></ul><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如：</p><pre><code>&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;  SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt;</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：</p><p><code>#{id}</code><br>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Similar JDBC <span class="meta">code</span>, NOT MyBatis…</span><br><span class="line"><span class="keyword">String </span><span class="keyword">selectPerson </span>= <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">PreparedStatement</span> ps = conn.prepareStatement(<span class="keyword">selectPerson);</span></span><br><span class="line"><span class="keyword">ps.setInt(1,id);</span></span><br></pre></td></tr></table></figure></p><p>下面就是 insert，update 和 delete 语句的示例：</p><pre><code>&lt;insert id=&quot;insertAuthor&quot;&gt;  insert into Author (id,username,password,email,bio)  values (#{id},#{username},#{password},#{email},#{bio})&lt;/insert&gt;&lt;update id=&quot;updateAuthor&quot;&gt;  update Author set    username = #{username},    password = #{password},    email = #{email},    bio = #{bio}  where id = #{id}&lt;/update&gt;&lt;delete id=&quot;deleteAuthor&quot;&gt;  delete from Author where id = #{id}&lt;/delete&gt;</code></pre><p>如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，而且有多种生成方式。</p><p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为:</p><pre><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;    keyProperty=&quot;id&quot;&gt;  insert into Author (username,password,email,bio)  values (#{username},#{password},#{email},#{bio})&lt;/insert&gt;</code></pre><p>如果你的数据库还支持多行插入, 你也可以传入一个Authors数组或集合，并返回自动生成的主键。</p><pre><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;    keyProperty=&quot;id&quot;&gt;  insert into Author (username, password, email, bio) values  &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;    (#{item.username}, #{item.password}, #{item.email}, #{item.bio})  &lt;/foreach&gt;&lt;/insert&gt;</code></pre><h4 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h4><p>MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。</p><p>虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。</p><p>动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach<br><strong>if</strong></li></ul><p>动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如：</p><pre><code>&lt;select id=&quot;findActiveBlogWithTitleLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG  WHERE state = ‘ACTIVE’  &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;&lt;/select&gt;</code></pre><p>这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果（细心的读者可能会发现，“title”参数值是可以包含一些掩码或通配符的）。</p><p>如果希望通过“title”和“author”两个参数进行可选搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;  &lt;if test=&quot;author != null and author.name != null&quot;&gt;    AND author_name like #{author.name}  &lt;/if&gt;&lt;/select&gt;</code></pre><p><strong>choose, when, otherwise</strong>  </p><p>有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是这次变为提供了“title”就按“title”查找，提供了“author”就按“author”查找的情形，若两者都没有提供，就返回所有符合条件的 BLOG（实际情况可能是由管理员按一定策略选出 BLOG 列表，而不是返回大量无意义的随机结果）。</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  &lt;choose&gt;    &lt;when test=&quot;title != null&quot;&gt;      AND title like #{title}    &lt;/when&gt;    &lt;when test=&quot;author != null and author.name != null&quot;&gt;      AND author_name like #{author.name}    &lt;/when&gt;    &lt;otherwise&gt;      AND featured = 1    &lt;/otherwise&gt;  &lt;/choose&gt;&lt;/select&gt;</code></pre><p><strong>trim, where, set</strong></p><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到“if”示例，这次我们将“ACTIVE = 1”也设置成动态的条件，看看会发生什么。</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG  WHERE  &lt;if test=&quot;state != null&quot;&gt;    state = #{state}  &lt;/if&gt;  &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;  &lt;if test=&quot;author != null and author.name != null&quot;&gt;    AND author_name like #{author.name}  &lt;/if&gt;&lt;/select&gt;</code></pre><p>如果这些条件没有一个能匹配上会发生什么？最终这条 SQL 会变成这样：</p><pre><code>SELECT * FROM BLOGWHERE</code></pre><p>这会导致查询失败。如果仅仅第二个条件匹配又会怎样？这条 SQL 最终会是这样:</p><pre><code>SELECT * FROM BLOGWHEREAND title like ‘someTitle’</code></pre><p>这个查询也会失败。这个问题不能简单地用条件句式来解决，如果你也曾经被迫这样写过，那么你很可能从此以后都不会再写出这种语句了。</p><p>MyBatis 有一个简单的处理，这在 90% 的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能达到目的：</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG  &lt;where&gt;    &lt;if test=&quot;state != null&quot;&gt;         state = #{state}    &lt;/if&gt;    &lt;if test=&quot;title != null&quot;&gt;        AND title like #{title}    &lt;/if&gt;    &lt;if test=&quot;author != null and author.name != null&quot;&gt;        AND author_name like #{author.name}    &lt;/if&gt;  &lt;/where&gt;&lt;/select&gt;</code></pre><p>where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。</p><p>如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><pre><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;  ...&lt;/trim&gt;</code></pre><p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容，并且插入 prefix 属性中指定的内容。</p><p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以用于动态包含需要更新的列，而舍去其它的。比如：</p><pre><code>&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;  update Author    &lt;set&gt;      &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;      &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt;      &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt;    &lt;/set&gt;  where id=#{id}&lt;/update&gt;</code></pre><p>这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号。（译者注：因为用的是“if”元素，若最后一个“if”没有匹配上而前面的匹配上，SQL 语句的最后就会有一个逗号遗留）</p><p>若你对 set 元素等价的自定义 trim 元素的代码感兴趣，那这就是它的真面目：</p><pre><code>&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;  ...&lt;/trim&gt;</code></pre><p>注意这里我们删去的是后缀值，同时添加了前缀值。</p><p><strong>foreach</strong>  </p><p>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p><pre><code>&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;  SELECT *  FROM POST P  WHERE ID in  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{item}  &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p><p>注意 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><p>到此我们已经完成了涉及 XML 配置文件和 XML 映射文件的讨论。</p><p><strong>bind</strong>  </p><p>bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：</p><pre><code>&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;  &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + _parameter.getTitle() + &apos;%&apos;&quot; /&gt;  SELECT * FROM BLOG  WHERE title LIKE #{pattern}&lt;/select&gt;</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><h4 id="1-和"><a href="#1-和" class="headerlink" title="(1) #{}和${}"></a>(1) <code>#{}</code>和<code>${}</code></h4><p><code>#{}</code>表示一个占位符号，通过<code>#{}</code>可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。<code>#{}</code>可以有效防止sql注入。 <code>#{}</code>可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，<code>#{}</code>括号中可以是value或其它名称。</p><p><code>${}</code>表示拼接sql串，通过<code>${}</code>可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， <code>${}</code>可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，<code>${}</code>括号中只能是value。</p><h4 id="2-parameterType和resultType"><a href="#2-parameterType和resultType" class="headerlink" title="(2) parameterType和resultType"></a>(2) parameterType和resultType</h4><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。</p><p>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中</p><h4 id="3-selectOne和selectList"><a href="#3-selectOne和selectList" class="headerlink" title="(3) selectOne和selectList"></a>(3) selectOne和selectList</h4><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常。</p><p>selectList可以查询一条或多条记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="mybatis" scheme="https://www.shado.com.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>EL表达式</title>
    <link href="https://www.shado.com.cn/2017/04/05/2017-04-05-el/"/>
    <id>https://www.shado.com.cn/2017/04/05/2017-04-05-el/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><h3 id="1．EL-表达式概述"><a href="#1．EL-表达式概述" class="headerlink" title="1．EL 表达式概述"></a>1．EL 表达式概述</h3><p>EL（Express Lanuage）表达式可以嵌入在jsp页面内部，减少jsp脚本的编写，EL出现的目的是要替代jsp页面中脚本的编写。</p><h3 id="2．EL从域中取出数据"><a href="#2．EL从域中取出数据" class="headerlink" title="2．EL从域中取出数据"></a>2．EL从域中取出数据</h3><p>EL最主要的作用是获得四大域中的数据，格式${EL表达式}<br>EL获得pageContext域中的值：<code>$(pageContextScope.key)</code>;<br>EL获得request域中的值：<code>$(request.key)</code>;<br>EL获得session域中的值：<code>$(session.key)</code>;<br>EL获得application域中的值：<code>$(application.key)</code>;<br>EL从四个域中获得某个值<code>$(key)</code>;<br>—同样是依次从pageContext域，request域，session域，application域中    获取属性，在某个域中获取后将不在向后寻找  </p><h3 id="3．EL的内置对象"><a href="#3．EL的内置对象" class="headerlink" title="3．EL的内置对象"></a>3．EL的内置对象</h3><p><strong>pageScope</strong><br><strong>requestScope</strong><br><strong>sessionScope</strong><br><strong>applicationScope</strong>  </p><table><thead><tr><th>获取JSP中域中的数据</th></tr></thead><tbody><tr><td>param,paramValues</td><td>接收参数</td></tr><tr><td>—-</td></tr><tr><td>header,headerValues</td><td>获取请求头信息</td></tr><tr><td>—-</td></tr><tr><td>initParam</td><td>获取全局初始化参数</td></tr><tr><td>—-</td></tr><tr><td>cookie</td><td>WEB开发中cookie</td></tr><tr><td>—-</td></tr><tr><td>pageContext</td><td>WEB开发中的pageContext</td></tr><tr><td>—-</td></tr></tbody></table><p><code>$(pageContext.request.contextPath)</code><br>相当于<br><code>&lt;%=pageContext.getRequest().getContextPath%&gt;</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="el" scheme="https://www.shado.com.cn/tags/el/"/>
    
  </entry>
  
  <entry>
    <title>JSP</title>
    <link href="https://www.shado.com.cn/2017/04/01/2017-04-01-jsp/"/>
    <id>https://www.shado.com.cn/2017/04/01/2017-04-01-jsp/</id>
    <published>2017-03-31T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h3><h4 id="1．jsp脚本和注释"><a href="#1．jsp脚本和注释" class="headerlink" title="1．jsp脚本和注释"></a>1．jsp脚本和注释</h4><p><strong>jsp脚本：</strong><br>(1)&lt;%java代码%&gt; —– 内部的java代码翻译到service方法的内部<br>(2)&lt;%=java变量或表达式&gt; —– 会被翻译成service方法内部out.print()<br>(3)&lt;%!java代码%&gt; —- 会被翻译成servlet的成员的内容<br><strong>jsp注释：</strong>  不同的注释可见范围是不同<br>(1)Html注释：<!--注释内容--> —可见范围 jsp源码、翻译后的servlet、页面显示html源码<br>(2)java注释：//单行注释  /<em>多行注释</em>/ –可见范围 jsp源码 翻译后的servlet<br>(3)jsp注释：&lt;%–注释内容–%&gt; —– 可见范围 jsp源码可见</p><h4 id="2．jsp运行原理—–jsp本质就是servlet"><a href="#2．jsp运行原理—–jsp本质就是servlet" class="headerlink" title="2．jsp运行原理—–jsp本质就是servlet"></a>2．jsp运行原理—–jsp本质就是servlet</h4><p>jsp在第一次被访问时会被Web容器翻译成servlet，在执行过程：<br><img src="/2017/04/01/2017-04-01-jsp/jsp-process.jpg" alt="JSP执行过程"><br>PS：被翻译后的servlet在Tomcat的work目录中可以找到</p><h4 id="3．jsp指令"><a href="#3．jsp指令" class="headerlink" title="3．jsp指令"></a>3．jsp指令</h4><p>jsp的指令是指导jsp翻译和运行的命令，jsp包括三大指令：<br><strong>(1)page指令</strong> — 属性最多的指令（实际开发中page指令默认）<br>属性最多的一个指令，根据不同的属性，指导整个页面特性<br>格式：&lt;%@ page 属性名1= “属性值1” 属性名2= “属性值2” …%&gt;<br>常用属性如下：<br>language：jsp脚本中可以嵌入的语言种类<br>pageEncoding：当前jsp文件的本身编码—内部可以包含contentType<br>contentType：response.setContentType(text/html;charset=UTF-8)<br>session：是否jsp在翻译时自动创建session<br>import：导入java的包<br>errorPage：当当前页面出错后跳转到哪个页面<br>isErrorPage：当前页面是一个处理错误的页面  </p><p><strong>(2)include指令</strong><br>页面包含（静态包含）指令，可以将一个jsp页面包含到另一个jsp页面中<br>格式：&lt;%@ include file=”被包含的文件地址”%&gt;  </p><p><strong>(3)taglib指令</strong><br>在jsp页面中引入标签库（jstl标签库、struts2标签库）<br>格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt;  </p><h4 id="4．jsp内置对象（9个）"><a href="#4．jsp内置对象（9个）" class="headerlink" title="4．jsp内置对象（9个）"></a>4．jsp内置对象（9个）</h4><p>jsp被翻译成servlet之后，service方法中有9个对象定义并初始化完毕，我们在jsp    脚本中可以直接使用这9个对象  </p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">类型</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:left">out</td><td style="text-align:center">javax.servlet.jsp.JspWriter</td><td style="text-align:right">用于页面输出</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">request</td><td style="text-align:center">javax.servlet.http.HttpServletRequest</td><td style="text-align:right">得到用户请求信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">response</td><td style="text-align:center">javax.servlet.http.HttpServletResponse</td><td style="text-align:right">服务器向客户端的回应信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">config</td><td style="text-align:center">javax.servlet.ServletConfig</td><td style="text-align:right">服务器配置，可以取得初始化参数</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">session</td><td style="text-align:center">javax.servlet.http.HttpSession</td><td style="text-align:right">用来保存用户的信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">application</td><td style="text-align:center">javax.servlet.ServletContext</td><td style="text-align:right">所有用户的共享信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">page</td><td style="text-align:center">java.lang.Object</td><td style="text-align:right">指当前页面转换后的Servlet类的实例</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">pageContext</td><td style="text-align:center">javax.servlet.jsp.PageContext</td><td style="text-align:right">JSP的页面容器</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">exception</td><td style="text-align:center">java.lang.Throwable</td><td style="text-align:right">表示JSP页面所发生的异常，在错误页中才起作用</td></tr><tr><td style="text-align:left">—-</td></tr></tbody></table><p><strong>(1)out对象</strong><br>out的类型：JspWriter<br>out作用就是想客户端输出内容—-out.write()<br>out缓冲区默认8kb 可以设置成0 代表关闭out缓冲区 内容直接写到respons缓冲    器  </p><p><strong>(2)pageContext对象</strong><br>jsp页面的上下文对象，作用如下：<br>page对象与pageContext对象不是一回事<br>1.pageContext是一个域对象<br>setAttribute(String name,Object obj)<br>getAttribute(String name)<br>removeAttrbute(String name)  </p><p>2.pageContext可以向指定的其他域中存取数据<br>setAttribute(String name,Object obj,int scope)<br>getAttribute(String name,int scope)<br>removeAttrbute(String name,int scope)<br>findAttribute(String name)<br>—依次从pageContext域，request域，session域，application域中获取属性，在某个域中获取后将不在向后寻找</p><p>3.可以获得其他8大隐式对象<br>例如： pageContext.getRequest()<br>pageContext.getSession()</p><p><strong>四大作用域：</strong><br>page域：当前jsp页面范围<br>request域：一次请求<br>session域：一次会话<br>application域：整个web应用  </p><h4 id="5．jsp标签（动作）"><a href="#5．jsp标签（动作）" class="headerlink" title="5．jsp标签（动作）"></a>5．jsp标签（动作）</h4><p><strong>(1)页面包含(动态包含)：</strong><code>&lt;jsp :include page=&quot;a.jsp&quot;/&gt;</code>  </p><p><strong>(2)请求转发：</strong><code>&lt;jsp:forward page=&quot;要转发的资源&quot; /&gt;</code>  </p><p><strong>动态包含与静态包含的区别：</strong><br>1.静态包含: <code>&lt;%@include  file=&quot;fileurl&quot;%&gt;</code><br>2.动态包含: <code>&lt;jsp :include page=&quot;a.jsp&quot;/&gt;</code><br>(1)静态包含发生在：JSP—-&gt;java文件阶段。动态包含发生在：执行class文件阶段,动态加入。<br>(2)静态包含：只生成一个java文件，动态包含：生成多个class文件。<br>(3)静态包含不会检查所包含文件中的变化；但是动态包含，每次检查所含文件中的变化，并且可以带参数</p><p><strong>请求转发与请求重定向的区别：</strong><br>1.请求转发：request.getRequestDispatcher().forward(req,resp)<br>服务器行为，request.getRequestDispatcher().forward(req,resp);是一次请求，转发后请求对象会保存，地址栏的URL地址不会改变。<br>2.请求重定向：response.sendRedirect()<br>客户端行为，response.sendRedirect(),从本质上讲等同于两次请求，前一次的请求对象不会保存，地址栏的URL地址会改变。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="https://www.shado.com.cn/tags/java/"/>
    
      <category term="jsp" scheme="https://www.shado.com.cn/tags/jsp/"/>
    
  </entry>
  
</feed>
