<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shado&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-15T07:04:13.746Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shado Fung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo-Next主题配置</title>
    <link href="http://yoursite.com/2019/02/22/2019-02-22-hexo-next-setting/"/>
    <id>http://yoursite.com/2019/02/22/2019-02-22-hexo-next-setting/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-05-15T07:04:13.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-搜索功能"><a href="#1-搜索功能" class="headerlink" title="1. 搜索功能"></a>1. 搜索功能</h2><h3 id="1-1-在Hexo根目录下执行-npm-install-hexo-generator-searchdb-–save"><a href="#1-1-在Hexo根目录下执行-npm-install-hexo-generator-searchdb-–save" class="headerlink" title="1.1. 在Hexo根目录下执行 npm install hexo-generator-searchdb –save"></a>1.1. 在Hexo根目录下执行 npm install hexo-generator-searchdb –save</h3><h3 id="1-2-blog下的-config-yml文件编辑"><a href="#1-2-blog下的-config-yml文件编辑" class="headerlink" title="1.2. blog下的_config.yml文件编辑"></a>1.2. blog下的_config.yml文件编辑</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="1-3-blog-themes-next下的-config-yml文件编辑"><a href="#1-3-blog-themes-next下的-config-yml文件编辑" class="headerlink" title="1.3. /blog/themes/next下的_config.yml文件编辑"></a>1.3. /blog/themes/next下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2-RSS订阅"><a href="#2-RSS订阅" class="headerlink" title="2. RSS订阅"></a>2. RSS订阅</h2><h3 id="2-1-在Hexo根目录下执行-npm-install-hexo-generator-feed-–save"><a href="#2-1-在Hexo根目录下执行-npm-install-hexo-generator-feed-–save" class="headerlink" title="2.1. 在Hexo根目录下执行 npm install hexo-generator-feed –save"></a>2.1. 在Hexo根目录下执行 npm install hexo-generator-feed –save</h3><h3 id="2-2-blog下的-config-yml文件编辑"><a href="#2-2-blog下的-config-yml文件编辑" class="headerlink" title="2.2. blog下的_config.yml文件编辑"></a>2.2. blog下的_config.yml文件编辑</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># RSS订阅</span></span><br><span class="line"><span class="symbol">plugin:</span></span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line"><span class="meta"># RSS</span></span><br><span class="line"><span class="symbol">feed:</span></span><br><span class="line"><span class="symbol">  type:</span> atom</span><br><span class="line"><span class="symbol">  path:</span> atom.xml</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="2-3-blog-themes-next下的-config-yml文件编辑"><a href="#2-3-blog-themes-next下的-config-yml文件编辑" class="headerlink" title="2.3. /blog/themes/next下的_config.yml文件编辑"></a>2.3. /blog/themes/next下的_config.yml文件编辑</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rss:</span> /atom.xml</span><br></pre></td></tr></table></figure><h2 id="发布到Github"><a href="#发布到Github" class="headerlink" title="发布到Github"></a>发布到Github</h2><h3 id="在Hexo根目录下执行-npm-install-–save-hexo-deployer-git"><a href="#在Hexo根目录下执行-npm-install-–save-hexo-deployer-git" class="headerlink" title="在Hexo根目录下执行 npm install –save hexo-deployer-git"></a>在Hexo根目录下执行 npm install –save hexo-deployer-git</h3><h3 id="自动关联域名-创建-Hexo根目录-source-CNAME-内容为域名，如：www-mingdong-online"><a href="#自动关联域名-创建-Hexo根目录-source-CNAME-内容为域名，如：www-mingdong-online" class="headerlink" title="自动关联域名 创建../Hexo根目录/source/CNAME 内容为域名，如：www.mingdong.online"></a>自动关联域名 创建../Hexo根目录/source/CNAME 内容为域名，如：<code>www.mingdong.online</code></h3><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><h2 id="文章字数统计和阅读时间统计"><a href="#文章字数统计和阅读时间统计" class="headerlink" title="文章字数统计和阅读时间统计"></a>文章字数统计和阅读时间统计</h2><h3 id="https-github-com-theme-next-hexo-symbols-count-time"><a href="#https-github-com-theme-next-hexo-symbols-count-time" class="headerlink" title="https://github.com/theme-next/hexo-symbols-count-time"></a><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a></h3><h3 id="在Hexo根目录下执行-npm-install-hexo-symbols-count-time-–save"><a href="#在Hexo根目录下执行-npm-install-hexo-symbols-count-time-–save" class="headerlink" title="在Hexo根目录下执行 npm install hexo-symbols-count-time –save"></a>在Hexo根目录下执行 npm install hexo-symbols-count-time –save</h3><h3 id="blog下的-config-yml文件编辑"><a href="#blog下的-config-yml文件编辑" class="headerlink" title="blog下的_config.yml文件编辑"></a>blog下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">  symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="博客中插入图片"><a href="#博客中插入图片" class="headerlink" title="博客中插入图片"></a>博客中插入图片</h2><h3 id="在Hexo根目录下执行-npm-install-hexo-asset-image-–save"><a href="#在Hexo根目录下执行-npm-install-hexo-asset-image-–save" class="headerlink" title="在Hexo根目录下执行 npm install hexo-asset-image –save"></a>在Hexo根目录下执行 npm install hexo-asset-image –save</h3><h3 id="blog下的-config-yml文件编辑-1"><a href="#blog下的-config-yml文件编辑-1" class="headerlink" title="blog下的_config.yml文件编辑"></a>blog下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="live2d"><a href="#live2d" class="headerlink" title="live2d"></a>live2d</h2><h3 id="https-github-com-EYHN-hexo-helper-live2d-blob-master-README-md"><a href="#https-github-com-EYHN-hexo-helper-live2d-blob-master-README-md" class="headerlink" title="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md"></a><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.md</a></h3><h3 id="安装live2d-在Hexo根目录下执行-npm-install-–save-hexo-helper-live2d"><a href="#安装live2d-在Hexo根目录下执行-npm-install-–save-hexo-helper-live2d" class="headerlink" title="安装live2d 在Hexo根目录下执行 npm install –save hexo-helper-live2d"></a>安装live2d 在Hexo根目录下执行 npm install –save hexo-helper-live2d</h3><h3 id="安装模块包-在Hexo根目录下执行-npm-install-packagename-如-npm-install-live2d-widget-model-wanko"><a href="#安装模块包-在Hexo根目录下执行-npm-install-packagename-如-npm-install-live2d-widget-model-wanko" class="headerlink" title="安装模块包 在Hexo根目录下执行 npm install {packagename} 如:npm install live2d-widget-model-wanko"></a>安装模块包 在Hexo根目录下执行 npm install {packagename} 如:npm install live2d-widget-model-wanko</h3><h3 id="blog下的-config-yml文件编辑-2"><a href="#blog下的-config-yml文件编辑-2" class="headerlink" title="blog下的_config.yml文件编辑"></a>blog下的_config.yml文件编辑</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br></pre></td></tr></table></figure><h2 id="aplayer"><a href="#aplayer" class="headerlink" title="aplayer"></a>aplayer</h2><h3 id="https-github-com-MoePlayer-hexo-tag-aplayer"><a href="#https-github-com-MoePlayer-hexo-tag-aplayer" class="headerlink" title="https://github.com/MoePlayer/hexo-tag-aplayer"></a><a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">https://github.com/MoePlayer/hexo-tag-aplayer</a></h3><h3 id="在Hexo根目录下执行-npm-install-–save-hexo-tag-aplayer"><a href="#在Hexo根目录下执行-npm-install-–save-hexo-tag-aplayer" class="headerlink" title="在Hexo根目录下执行 npm install –save hexo-tag-aplayer"></a>在Hexo根目录下执行 npm install –save hexo-tag-aplayer</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id><a href="#" class="headerlink" title></a><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found ([picture_url,)");</script></h4><ul><li>title : 曲目标题</li><li>author: 曲目作者</li><li>url: 音乐文件 URL 地址</li><li>picture_url: (可选) 音乐对应的图片地址</li><li>narrow: （可选）播放器袖珍风格</li><li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li><li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li><li>lrc:xxx: （可选）歌词文件 URL 地址<br>当开启 Hexo 的 文章资源文件夹<code>post_asset_folder: true</code> 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用：</li></ul><p><code><script>console.error("Error: [hexo-tag-aplayer] Specified asset file not found (picture.jpg)");</script></code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Java CPU 100%排查问题与解决</title>
    <link href="http://yoursite.com/2018/06/07/2018-06-07-java-cpu-100-resolve/"/>
    <id>http://yoursite.com/2018/06/07/2018-06-07-java-cpu-100-resolve/</id>
    <published>2018-06-07T02:28:44.000Z</published>
    <updated>2019-03-18T13:44:37.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记一次线上服务器Java程序CPU 100%排查问题与解决</p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>首先用top命令查看当前占用CPU高的进程(PID)<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mingdong<span class="variable">@VM_45_31_centos</span> V2]<span class="variable">$ </span>top</span><br></pre></td></tr></table></figure></p><p>小写键盘的情况下，<code>Shift+P</code>键按照CPU占用由高到低排序<br>打开大写键盘的情况下，直接按<code>P</code>键<br><img src="/2018/06/07/2018-06-07-java-cpu-100-resolve/linux-top-cpu-sort.png" alt="top命令"></p><blockquote><p>top命令</p></blockquote><p>可以看到占用CPU最高的进程PID是30672<br>然后通过<code>top -Hp 30672</code>查看每个线程占用的CPU情况<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mingdong<span class="variable">@VM_45_31_centos</span> V2]<span class="variable">$ </span>top -Hp <span class="number">30672</span></span><br></pre></td></tr></table></figure></p><p>然后可以看到占用CPU最高的线程tid是30679<br>得到tid之后再将tid转化为16进制<code>30679</code>转化为16进制就是<code>0x77d7</code><br>用<code>jstack PID</code>查看java虚拟机的堆栈情况<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mingdong<span class="variable">@VM_45_31_centos</span> V2]<span class="variable">$ </span>jstack <span class="number">30672</span></span><br></pre></td></tr></table></figure></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Reference Handler"</span> #2 daemon <span class="attribute">prio</span>=10 <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8114000 <span class="attribute">nid</span>=0x77d8 <span class="keyword">in</span> Object.wait() [0x00007fe9df6a1000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">- locked &lt;0x00000000fc0067d0&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.<span class="builtin-name">run</span>(Reference.java:153)</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d810a000 <span class="attribute">nid</span>=0x77d7 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#0 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d801a800 <span class="attribute">nid</span>=0x77d2 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#1 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d801c800 <span class="attribute">nid</span>=0x77d3 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#2 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d801e000 <span class="attribute">nid</span>=0x77d4 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Gang worker#3 (Parallel GC Threads)"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8020000 <span class="attribute">nid</span>=0x77d5 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"Concurrent Mark-Sweep GC Thread"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8063000 <span class="attribute">nid</span>=0x77d6 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> <span class="attribute">os_prio</span>=0 <span class="attribute">tid</span>=0x00007fe9d8162000 <span class="attribute">nid</span>=0x77e0 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 1281</span><br></pre></td></tr></table></figure><p>可以看到nid=0x77d7是GC所在的线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hashCode and equals</title>
    <link href="http://yoursite.com/2017/05/06/2017-05-06-hashCode-and-equals/"/>
    <id>http://yoursite.com/2017/05/06/2017-05-06-hashCode-and-equals/</id>
    <published>2017-05-06T07:08:18.000Z</published>
    <updated>2019-03-18T13:44:37.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>hashCode()方法和equals()方法的区别和联系很多人觉得很简单，但是要回答的时候却答得差强人意。正确的回答应该是先介绍hashCode()和equals()方法的作用是什么，然后才说他的区别，说了区别之后再说使用的时候需要注意到的地方。如果你在了解一些其他人不知道的那就更好了！下边我们就开始介绍</p><h2 id="hashCode-和equals-是什么"><a href="#hashCode-和equals-是什么" class="headerlink" title="hashCode()和equals()是什么"></a>hashCode()和equals()是什么</h2><p>hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。</p><h2 id="hashCode-和equals-的区别"><a href="#hashCode-和equals-的区别" class="headerlink" title="hashCode()和equals()的区别"></a>hashCode()和equals()的区别</h2><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hashCode()效率高，但并不是完全可靠的，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>equals()是完全可靠的，但是重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的，equals()性能较差。</p></li><li><p>hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的，hashCode()性能较好。</p></li></ol><h2 id="hashCode-和equals-使用的注意事项"><a href="#hashCode-和equals-使用的注意事项" class="headerlink" title="hashCode()和equals()使用的注意事项"></a>hashCode()和equals()使用的注意事项</h2><ol><li><p>对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p></li><li><p>这种大量的并且快速的对象对比一般使用的hash容器中，比如HashSet,HashMap,HashTable等等，比如HashSet里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equals()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。</p></li><li><p>然而hashCode()和equals()一样都是基本类Object里的方法，而和equals()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值，比如下面：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num * name.hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>由于标识这个类的是他的内部的变量num和name,所以我们就根据他们返回一个hash值，作为这个类的唯一hash值。</p><p>所以如果我们的对象要想放进hashSet，并且发挥hashSet的特性（即不包含一样的对象），则我们就要重写我们类的hashCode()和equals()方法了。像String,Integer等这种类内部都已经重写了这两个方法。</p><p>当然如果我们只是平时想对比两个对象是否一致，则只重写一个equals()，然后利用equals()去对比也行的。</p><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><h3 id="阿里巴巴规定"><a href="#阿里巴巴规定" class="headerlink" title="阿里巴巴规定"></a>阿里巴巴规定</h3><h4 id="【强制】关于hashCode和equals的处理，遵循如下规则："><a href="#【强制】关于hashCode和equals的处理，遵循如下规则：" class="headerlink" title="【强制】关于hashCode和equals的处理，遵循如下规则："></a>【强制】关于hashCode和equals的处理，遵循如下规则：</h4><blockquote><p>1） 只要重写equals，就必须重写hashCode。<br>2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。<br>3） 如果自定义对象作为Map的键，那么必须重写hashCode和equals。<br> <strong>说明：</strong> String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。  </p></blockquote><h3 id="什么时候需要重写"><a href="#什么时候需要重写" class="headerlink" title="什么时候需要重写"></a>什么时候需要重写</h3><p>一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode。</p><h3 id="为什么要重载hashCode"><a href="#为什么要重载hashCode" class="headerlink" title="为什么要重载hashCode"></a>为什么要重载hashCode</h3><p>如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。</p><p>这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。</p><h3 id="为什么equals-相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等"><a href="#为什么equals-相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等" class="headerlink" title="为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等"></a>为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等</h3><ol><li><p>因为是按照hashCode来访问小内存块，所以hashCode必须相等。</p></li><li><p>HashMap获取一个对象是比较key的hashCode相等和equals为true。</p></li></ol><p>之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equals为false。</p><h3 id="为什么需要hashCode"><a href="#为什么需要hashCode" class="headerlink" title="为什么需要hashCode"></a>为什么需要hashCode</h3><ol><li><p>通过hashCode可以很快的查到小内存块。</p></li><li><p>通过hashCode比较比equals方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java工程师之路</title>
    <link href="http://yoursite.com/2017/04/20/2017-04-20-to-be-java-coder/"/>
    <id>http://yoursite.com/2017/04/20/2017-04-20-to-be-java-coder/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.281Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java工程师之路"><a href="#Java工程师之路" class="headerlink" title="Java工程师之路"></a>Java工程师之路</h1><p><img src="https://img.shields.io/badge/version-v2.0.0-green.svg" alt> <img src="https://img.shields.io/badge/author-Hollis-yellow.svg" alt> <img src="https://img.shields.io/badge/license-GPL-blue.svg" alt></p><h2 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><ol><li><p>面向对象、面向过程</p></li><li><p>面向对象的三大基本特征和五大基本原则</p></li></ol><h4 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h4><ol><li><p>Java如何实现的平台无关</p></li><li><p>JVM还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</p></li></ol><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><ol><li><p>值传递、引用传递</p></li><li><p>为什么说Java中只有值传递</p></li></ol><h4 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h4><ol><li><p>什么是多态、方法重写与重载</p></li><li><p>Java的继承与实现</p></li><li><p>构造函数与默认构造函数</p></li><li><p>类变量、成员变量和局部变量</p></li><li><p>成员变量和方法作用域</p></li></ol><h3 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ol><li><p>7种基本数据类型：整型、浮点型、布尔型、字符型</p></li><li><p>整型中byte、short、int、long的取值范围</p></li><li><p>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</p></li></ol><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><ol><li><p>什么是包装类型、什么是基本类型、什么是自动拆装箱</p></li><li><p>Integer的缓存机制</p></li></ol><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ol><li><p>字符串的不可变性</p></li><li><p>JDK 6和JDK 7中substring的原理及区别、</p></li><li><p>replaceFirst、replaceAll、replace区别、</p></li><li><p>String对“+”的重载、字符串拼接的几种方式和区别</p></li><li><p>String.valueOf和Integer.toString的区别、</p></li><li><p>switch对String的支持</p></li><li><p>字符串池、常量池（运行时常量池、Class常量池）、intern</p></li></ol><h4 id="熟悉Java中各种关键字"><a href="#熟悉Java中各种关键字" class="headerlink" title="熟悉Java中各种关键字"></a>熟悉Java中各种关键字</h4><ol><li>transient、instanceof、volatile、synchronized、final、static、const 原理及用法。</li></ol><h4 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h4><ol><li><p>常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、</p></li><li><p>Set和List区别？Set如何保证元素不重复？</p></li><li><p>Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因</p></li><li><p>Collection和Collections区别</p></li><li><p>Arrays.asList获得的List使用时需要注意什么</p></li><li><p>Enumeration和Iterator区别</p></li><li><p>fail-fast 和 fail-safe</p></li><li><p>CopyOnWriteArrayList、ConcurrentSkipListMap</p></li></ol><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ol><li><p>枚举的用法、枚举的实现、枚举与单例、Enum类</p></li><li><p>Java枚举如何比较</p></li><li><p>switch对枚举的支持</p></li><li><p>枚举的序列化如何实现</p></li><li><p>枚举的线程安全性问题</p></li></ol><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><ol><li><p>字符流、字节流、输入流、输出流、</p></li><li><p>同步、异步、阻塞、非阻塞、Linux 5种IO模型</p></li><li><p>BIO、NIO和AIO的区别、三种IO的用法与原理、netty</p></li></ol><h4 id="Java反射与javassist"><a href="#Java反射与javassist" class="headerlink" title="Java反射与javassist"></a>Java反射与javassist</h4><ol><li><p>反射与工厂模式、 反射有什么作用</p></li><li><p>Class类</p></li><li><p><code>java.lang.reflect.*</code></p></li></ol><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ol><li><p>静态代理、动态代理</p></li><li><p>动态代理和反射的关系</p></li><li><p>动态代理的几种实现方式</p></li><li><p>AOP</p></li></ol><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ol><li>什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全</li></ol><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ol><li><p>元注解、自定义注解、Java中常用注解使用、注解与反射的结合</p></li><li><p>Spring常用注解</p></li></ol><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><ol><li>什么是Java消息服务、JMS消息传送模型</li></ol><h4 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h4><ol><li><code>java.lang.management.*</code>、 <code>javax.management.*</code></li></ol><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ol><li><p>泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法</p></li><li><p>限定通配符和非限定通配符、上下界限定符extends 和 super</p></li><li><p>List<object>和原始类型List之间的区别?</object></p></li><li><p>List&lt;?&gt;和List<object>之间的区别是什么?</object></p></li></ol><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ol><li>junit、mock、mockito、内存数据库（h2）</li></ol><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ol><li><code>java.lang.util.regex.*</code></li></ol><h4 id="常用的Java工具库"><a href="#常用的Java工具库" class="headerlink" title="常用的Java工具库"></a>常用的Java工具库</h4><ol><li><code>commons.lang</code>, <code>commons.*...</code> <code>guava-libraries</code> <code>netty</code></li></ol><h4 id="API-amp-SPI"><a href="#API-amp-SPI" class="headerlink" title="API&amp;SPI"></a>API&amp;SPI</h4><ol><li><p>API、API和SPI的关系和区别</p></li><li><p>如何定义SPI、SPI的实现原理</p></li></ol><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ol><li><p>异常类型、正确处理异常、自定义异常</p></li><li><p>Error和Exception</p></li><li><p>异常链、try-with-resources</p></li><li><p>finally和return的执行顺序</p></li></ol><h4 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h4><ol><li><p>时区、冬令时和夏令时、时间戳、Java中时间API</p></li><li><p>格林威治时间、CET,UTC,GMT,CST几种常见时间的含义和关系</p></li><li><p>SimpleDateFormat的线程安全性问题</p></li><li><p>Java 8中的时间处理</p></li><li><p>如何在东八区的计算机上获取美国时间</p></li></ol><h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><ol><li><p>Unicode、有了Unicode为啥还需要UTF-8</p></li><li><p>GBK、GB2312、GB18030之间的区别</p></li><li><p>UTF8、UTF16、UTF32区别</p></li><li><p>URL编解码、Big Endian和Little Endian</p></li><li><p>如何解决乱码问题</p></li></ol><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><ol><li><p>Java中语法糖原理、解语法糖</p></li><li><p>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda表达式、</p></li></ol><h3 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h3><ol><li>String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet</li></ol><h3 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h3><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><ol><li><p>什么是并发</p></li><li><p>什么是并行</p></li><li><p>并发与并行的区别</p></li></ol><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ol><li><p>线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程</p></li><li><p>线程与进程的区别</p></li></ol><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ol><li><p>自己设计线程池、submit() 和 execute()、线程池原理</p></li><li><p>为什么不允许使用Executors创建线程池</p></li></ol><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ol><li>死锁、死锁如何排查、线程安全和内存模型的关系</li></ol><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ol><li><p>CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、</p></li><li><p>锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁</p></li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ol><li><p>死锁的原因</p></li><li><p>死锁的解决办法</p></li></ol><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ol><li><p>synchronized是如何实现的？</p></li><li><p>synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例</p></li><li><p>synchronized和原子性、可见性和有序性之间的关系</p></li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ol><li><p>happens-before、内存屏障、编译器指令重排和CPU指令重排</p></li><li><p>volatile的实现原理</p></li><li><p>volatile和原子性、可见性和有序性之间的关系</p></li><li><p>有了symchronized为什么还需要volatile</p></li></ol><h4 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep 和 wait"></a>sleep 和 wait</h4><h4 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait 和 notify"></a>wait 和 notify</h4><h4 id="notify-和-notifyAll"><a href="#notify-和-notifyAll" class="headerlink" title="notify 和 notifyAll"></a>notify 和 notifyAll</h4><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h4 id="写一个死锁的程序"><a href="#写一个死锁的程序" class="headerlink" title="写一个死锁的程序"></a>写一个死锁的程序</h4><h4 id="写代码来解决生产者消费者问题"><a href="#写代码来解决生产者消费者问题" class="headerlink" title="写代码来解决生产者消费者问题"></a>写代码来解决生产者消费者问题</h4><h3 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h3><h4 id="阅读源代码，并学会使用"><a href="#阅读源代码，并学会使用" class="headerlink" title="阅读源代码，并学会使用"></a>阅读源代码，并学会使用</h4><ol><li>Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors</li></ol><h2 id="二、底层篇"><a href="#二、底层篇" class="headerlink" title="二、底层篇"></a>二、底层篇</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><ol><li><p>class文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、</p></li><li><p>堆和栈区别</p></li><li><p>Java中的对象一定在堆上分配吗？</p></li></ol><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><ol><li><p>计算机内存模型、缓存一致性、MESI协议</p></li><li><p>可见性、原子性、顺序性、happens-before、</p></li><li><p>内存屏障、synchronized、volatile、final、锁</p></li></ol><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ol><li><p>GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</p></li><li><p>GC参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）</p></li></ol><h4 id="JVM参数及调优"><a href="#JVM参数及调优" class="headerlink" title="JVM参数及调优"></a>JVM参数及调优</h4><ol><li><p>-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、</p></li><li><p>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold</p></li></ol><h4 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h4><ol><li>oop-klass、对象头</li></ol><h4 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h4><ol><li>即时编译器、编译优化</li></ol><h4 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h4><ol><li><p>jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler</p></li><li><p>Arthas</p></li></ol><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ol><li>classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）</li></ol><h3 id="编译与反编译"><a href="#编译与反编译" class="headerlink" title="编译与反编译"></a>编译与反编译</h3><ol><li><p>什么是编译（前端编译、后端编译）、什么是反编译</p></li><li><p>JIT、JIT优化（逃逸分析、栈上分配、标量替换、锁优化）</p></li><li><p>编译工具：javac</p></li><li><p>反编译工具：javap 、jad 、CRF</p></li></ol><h2 id="三、-进阶篇"><a href="#三、-进阶篇" class="headerlink" title="三、 进阶篇"></a>三、 进阶篇</h2><h3 id="Java底层知识"><a href="#Java底层知识" class="headerlink" title="Java底层知识"></a>Java底层知识</h3><h4 id="字节码、class文件格式"><a href="#字节码、class文件格式" class="headerlink" title="字节码、class文件格式"></a>字节码、class文件格式</h4><h4 id="CPU缓存，L1，L2，L3和伪共享"><a href="#CPU缓存，L1，L2，L3和伪共享" class="headerlink" title="CPU缓存，L1，L2，L3和伪共享"></a>CPU缓存，L1，L2，L3和伪共享</h4><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ol><li>用位运算实现加、减、乘、除、取余</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ol><li><p>设计模式的六大原则：</p></li><li><p>开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle）</p></li><li><p>接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle）</p></li></ol><h4 id="了解23种设计模式"><a href="#了解23种设计模式" class="headerlink" title="了解23种设计模式"></a>了解23种设计模式</h4><ol><li><p>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</p></li><li><p>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</p></li><li><p>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</p></li></ol><h4 id="会使用常用设计模式"><a href="#会使用常用设计模式" class="headerlink" title="会使用常用设计模式"></a>会使用常用设计模式</h4><ol><li><p>单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁</p></li><li><p>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会</p></li></ol><h4 id="不用synchronized和lock，实现线程安全的单例模式"><a href="#不用synchronized和lock，实现线程安全的单例模式" class="headerlink" title="不用synchronized和lock，实现线程安全的单例模式"></a>不用synchronized和lock，实现线程安全的单例模式</h4><h4 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h4><h4 id="实现IOC"><a href="#实现IOC" class="headerlink" title="实现IOC"></a>实现IOC</h4><h4 id="nio和reactor设计模式"><a href="#nio和reactor设计模式" class="headerlink" title="nio和reactor设计模式"></a>nio和reactor设计模式</h4><h3 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h3><h4 id="tcp、udp、http、https等常用协议"><a href="#tcp、udp、http、https等常用协议" class="headerlink" title="tcp、udp、http、https等常用协议"></a>tcp、udp、http、https等常用协议</h4><ol><li>三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包</li></ol><h4 id="http-1-0-http-1-1-http-2之间的区别"><a href="#http-1-0-http-1-1-http-2之间的区别" class="headerlink" title="http/1.0 http/1.1 http/2之间的区别"></a>http/1.0 http/1.1 http/2之间的区别</h4><ol><li><p>http中 get和post区别</p></li><li><p>常见的web请求返回的状态码</p></li><li><p>404、302、301、500分别代表什么</p></li></ol><h4 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h4><h4 id="Java-RMI，Socket，HttpClient"><a href="#Java-RMI，Socket，HttpClient" class="headerlink" title="Java RMI，Socket，HttpClient"></a>Java RMI，Socket，HttpClient</h4><h4 id="cookie-与-session"><a href="#cookie-与-session" class="headerlink" title="cookie 与 session"></a>cookie 与 session</h4><ol><li>cookie被禁用，如何实现session</li></ol><h4 id="用Java写一个简单的静态文件的HTTP服务器"><a href="#用Java写一个简单的静态文件的HTTP服务器" class="headerlink" title="用Java写一个简单的静态文件的HTTP服务器"></a>用Java写一个简单的静态文件的HTTP服务器</h4><h4 id="了解nginx和apache服务器的特性并搭建一个对应的服务器"><a href="#了解nginx和apache服务器的特性并搭建一个对应的服务器" class="headerlink" title="了解nginx和apache服务器的特性并搭建一个对应的服务器"></a>了解nginx和apache服务器的特性并搭建一个对应的服务器</h4><h4 id="用Java实现FTP、SMTP协议"><a href="#用Java实现FTP、SMTP协议" class="headerlink" title="用Java实现FTP、SMTP协议"></a>用Java实现FTP、SMTP协议</h4><h4 id="进程间通讯的方式"><a href="#进程间通讯的方式" class="headerlink" title="进程间通讯的方式"></a>进程间通讯的方式</h4><h4 id="什么是CDN？如果实现？"><a href="#什么是CDN？如果实现？" class="headerlink" title="什么是CDN？如果实现？"></a>什么是CDN？如果实现？</h4><h4 id="DNS？"><a href="#DNS？" class="headerlink" title="DNS？"></a>DNS？</h4><ol><li><p>什么是DNS 、记录类型:A记录、CNAME记录、AAAA记录等</p></li><li><p>域名解析、根域名服务器</p></li><li><p>DNS污染、DNS劫持、公共DNS：114 DNS、Google DNS、OpenDNS</p></li></ol><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ol><li><p>正向代理、反向代理</p></li><li><p>反向代理服务器</p></li></ol><h3 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h3><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><ol><li><p>生命周期</p></li><li><p>线程安全问题</p></li><li><p>filter和listener</p></li><li><p>web.xml中常用配置及作用</p></li></ol><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><ol><li><p>什么是OR Mapping</p></li><li><p>Hibernate的缓存机制</p></li><li><p>Hibernate的懒加载</p></li><li><p>Hibernate/Ibatis/MyBatis之间的区别</p></li></ol><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ol><li><p>Bean的初始化</p></li><li><p>AOP原理</p></li><li><p>实现Spring的IOC</p></li><li><p>spring四种依赖注入方式</p></li></ol><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><ol><li><p>什么是MVC</p></li><li><p>Spring mvc与Struts mvc的区别</p></li></ol><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><ol><li><p>Spring Boot 2.0、起步依赖、自动配置、</p></li><li><p>Spring Boot的starter原理，自己实现一个starter</p></li></ol><h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ol><li><p>服务发现与注册：Eureka、Zookeeper、Consul</p></li><li><p>负载均衡：Feign、Spring Cloud Loadbalance</p></li><li><p>服务配置：Spring Cloud Config</p></li><li><p>服务限流与熔断：Hystrix</p></li><li><p>服务链路追踪：Dapper</p></li><li><p>服务网关、安全、消息</p></li></ol><h3 id="应用服务器知识"><a href="#应用服务器知识" class="headerlink" title="应用服务器知识"></a>应用服务器知识</h3><h4 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h4><h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h4><h4 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h4><h4 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h4><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="git-amp-svn"><a href="#git-amp-svn" class="headerlink" title="git &amp; svn"></a>git &amp; svn</h4><h4 id="maven-amp-gradle"><a href="#maven-amp-gradle" class="headerlink" title="maven &amp; gradle"></a>maven &amp; gradle</h4><h4 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h4><ol><li><p>常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat、aceJump</p></li><li><p>Lombok plugin、.ignore、Mybatis plugin</p></li></ol><h2 id="四、-高级篇"><a href="#四、-高级篇" class="headerlink" title="四、 高级篇"></a>四、 高级篇</h2><h3 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h3><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h4><ol><li>lambda表达式、Stream API、时间API</li></ol><h4 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h4><ol><li>Jigsaw、Jshell、Reactive Streams</li></ol><h4 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h4><ol><li>局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制</li></ol><h4 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h4><ol><li>ZGC、Epsilon、增强var、</li></ol><h4 id="Spring-5"><a href="#Spring-5" class="headerlink" title="Spring 5"></a>Spring 5</h4><ol><li>响应式编程</li></ol><h4 id="Spring-Boot-2-0"><a href="#Spring-Boot-2-0" class="headerlink" title="Spring Boot 2.0"></a>Spring Boot 2.0</h4><h3 id="http-2"><a href="#http-2" class="headerlink" title="http/2"></a>http/2</h3><h3 id="http-3-1"><a href="#http-3-1" class="headerlink" title="http/3"></a>http/3</h3><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li>使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存</li></ol><h3 id="线上问题分析"><a href="#线上问题分析" class="headerlink" title="线上问题分析"></a>线上问题分析</h3><h4 id="dump获取"><a href="#dump获取" class="headerlink" title="dump获取"></a>dump获取</h4><ol><li>线程Dump、内存Dump、gc情况</li></ol><h4 id="dump分析"><a href="#dump分析" class="headerlink" title="dump分析"></a>dump分析</h4><ol><li>分析死锁、分析内存泄露</li></ol><h4 id="dump分析及获取工具"><a href="#dump分析及获取工具" class="headerlink" title="dump分析及获取工具"></a>dump分析及获取工具</h4><ol><li>jstack、jstat、jmap、jhat、Arthas</li></ol><h4 id="自己编写各种outofmemory，stackoverflow程序"><a href="#自己编写各种outofmemory，stackoverflow程序" class="headerlink" title="自己编写各种outofmemory，stackoverflow程序"></a>自己编写各种outofmemory，stackoverflow程序</h4><ol><li>HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow</li></ol><h4 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h4><ol><li><p>jvm相关、class/classloader相关、monitor/watch/trace相关、</p></li><li><p>options、管道、后台异步任务</p></li><li><p>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/advanced-use.html</a></p></li></ol><h4 id="常见问题解决思路"><a href="#常见问题解决思路" class="headerlink" title="常见问题解决思路"></a>常见问题解决思路</h4><ol><li>内存溢出、线程死锁、类加载冲突</li></ol><h4 id="使用工具尝试解决以下问题，并写下总结"><a href="#使用工具尝试解决以下问题，并写下总结" class="headerlink" title="使用工具尝试解决以下问题，并写下总结"></a>使用工具尝试解决以下问题，并写下总结</h4><ol><li><p>当一个Java程序响应很慢时如何查找问题、</p></li><li><p>当一个Java程序频繁FullGC时如何解决问题、</p></li><li><p>如何查看垃圾回收日志、</p></li><li><p>当一个Java应用发生OutOfMemory时该如何解决、</p></li><li><p>如何判断是否出现死锁、</p></li><li><p>如何判断是否存在内存泄露</p></li><li><p>使用Arthas快速排查Spring Boot应用404/401问题</p></li><li><p>使用Arthas排查线上应用日志打满问题</p></li><li><p>利用Arthas排查Spring Boot应用NoSuchMethodError</p></li></ol><h3 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h3><h4 id="编译与反编译-1"><a href="#编译与反编译-1" class="headerlink" title="编译与反编译"></a>编译与反编译</h4><h4 id="Java代码的编译与反编译"><a href="#Java代码的编译与反编译" class="headerlink" title="Java代码的编译与反编译"></a>Java代码的编译与反编译</h4><h4 id="Java的反编译工具"><a href="#Java的反编译工具" class="headerlink" title="Java的反编译工具"></a>Java的反编译工具</h4><ol><li>javap 、jad 、CRF</li></ol><h4 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h4><h4 id="词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化"><a href="#词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化" class="headerlink" title="词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化"></a>词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化</h4><h3 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h3><h4 id="Linux的常用命令"><a href="#Linux的常用命令" class="headerlink" title="Linux的常用命令"></a>Linux的常用命令</h4><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><ol><li>生产者消费者问题、哲学家就餐问题、读者写者问题</li></ol><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><h4 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h4><h4 id="虚拟内存与主存"><a href="#虚拟内存与主存" class="headerlink" title="虚拟内存与主存"></a>虚拟内存与主存</h4><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><h4 id="换页算法"><a href="#换页算法" class="headerlink" title="换页算法"></a>换页算法</h4><h3 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h3><h4 id="MySql-执行引擎"><a href="#MySql-执行引擎" class="headerlink" title="MySql 执行引擎"></a>MySql 执行引擎</h4><h4 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h4><ol><li>如何查看执行计划，如何根据执行计划进行SQL优化</li></ol><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ol><li><p>Hash索引、B树索引（B+树、和B树、R树）</p></li><li><p>普通索引、唯一索引</p></li><li><p>覆盖索引、最左前缀原则、索引下推</p></li></ol><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><h4 id="数据库事务和隔离级别"><a href="#数据库事务和隔离级别" class="headerlink" title="数据库事务和隔离级别"></a>数据库事务和隔离级别</h4><ol><li>事务的隔离级别、事务能不能实现锁的功能</li></ol><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><ol><li>行锁、表锁、使用数据库锁实现乐观锁、</li></ol><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ol><li>内连接，左连接，右连接</li></ol><h4 id="数据库主备搭建"><a href="#数据库主备搭建" class="headerlink" title="数据库主备搭建"></a>数据库主备搭建</h4><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><h4 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h4><h4 id="内存数据库"><a href="#内存数据库" class="headerlink" title="内存数据库"></a>内存数据库</h4><ol><li>h2</li></ol><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><h4 id="常用的nosql数据库"><a href="#常用的nosql数据库" class="headerlink" title="常用的nosql数据库"></a>常用的nosql数据库</h4><ol><li>redis、memcached</li></ol><h4 id="分别使用数据库锁、NoSql实现分布式锁"><a href="#分别使用数据库锁、NoSql实现分布式锁" class="headerlink" title="分别使用数据库锁、NoSql实现分布式锁"></a>分别使用数据库锁、NoSql实现分布式锁</h4><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><h3 id="数据结构与算法知识"><a href="#数据结构与算法知识" class="headerlink" title="数据结构与算法知识"></a>数据结构与算法知识</h3><h4 id="简单的数据结构"><a href="#简单的数据结构" class="headerlink" title="简单的数据结构"></a>简单的数据结构</h4><ol><li><p>栈、队列、链表、数组、哈希表、</p></li><li><p>栈和队列的相同和不同之处</p></li><li><p>栈通常采用的两种存储结构</p></li></ol><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><ol><li>二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ol><li>大根堆、小根堆</li></ol><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ol><li>有向图、无向图、拓扑</li></ol><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ol><li><p>稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序</p></li><li><p>不稳定的排序：选择排序、希尔排序、Clover排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序</p></li><li><p>各种排序算法和时间复杂度</p></li></ol><h4 id="深度优先和广度优先搜索"><a href="#深度优先和广度优先搜索" class="headerlink" title="深度优先和广度优先搜索"></a>深度优先和广度优先搜索</h4><h4 id="全排列、贪心算法、KMP算法、hash算法"><a href="#全排列、贪心算法、KMP算法、hash算法" class="headerlink" title="全排列、贪心算法、KMP算法、hash算法"></a>全排列、贪心算法、KMP算法、hash算法</h4><h4 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h4><ol><li>分治，hash映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce等。</li></ol><h4 id="两个栈实现队列，和两个队列实现栈"><a href="#两个栈实现队列，和两个队列实现栈" class="headerlink" title="两个栈实现队列，和两个队列实现栈"></a>两个栈实现队列，和两个队列实现栈</h4><h3 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h3><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><ol><li>基本概念、常见用法</li></ol><h4 id="Solr，Lucene，ElasticSearch"><a href="#Solr，Lucene，ElasticSearch" class="headerlink" title="Solr，Lucene，ElasticSearch"></a>Solr，Lucene，ElasticSearch</h4><ol><li>在linux上部署solr，solrcloud，，新增、删除、查询索引</li></ol><h4 id="Storm，流式计算，了解Spark，S4"><a href="#Storm，流式计算，了解Spark，S4" class="headerlink" title="Storm，流式计算，了解Spark，S4"></a>Storm，流式计算，了解Spark，S4</h4><ol><li>在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。</li></ol><h4 id="Hadoop，离线计算"><a href="#Hadoop，离线计算" class="headerlink" title="Hadoop，离线计算"></a>Hadoop，离线计算</h4><ol><li>HDFS、MapReduce</li></ol><h4 id="分布式日志收集flume，kafka，logstash"><a href="#分布式日志收集flume，kafka，logstash" class="headerlink" title="分布式日志收集flume，kafka，logstash"></a>分布式日志收集flume，kafka，logstash</h4><h4 id="数据挖掘，mahout"><a href="#数据挖掘，mahout" class="headerlink" title="数据挖掘，mahout"></a>数据挖掘，mahout</h4><h3 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ol><li>XSS的防御</li></ol><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><h4 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h4><ol><li>SQL注入、XML注入、CRLF注入</li></ol><h4 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h4><h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><ol><li><p>对称加密、非对称加密、哈希算法、加盐哈希算法</p></li><li><p>MD5，SHA1、DES、AES、RSA、DSA</p></li><li><p>彩虹表</p></li></ol><h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><ol><li><p>DOS攻击、DDOS攻击</p></li><li><p>memcached为什么可以导致DDos攻击、什么是反射型DDoS</p></li><li><p>如何通过Hash碰撞进行DOS攻击</p></li></ol><h4 id="SSL、TLS，HTTPS"><a href="#SSL、TLS，HTTPS" class="headerlink" title="SSL、TLS，HTTPS"></a>SSL、TLS，HTTPS</h4><h4 id="用openssl签一个证书部署到apache或nginx"><a href="#用openssl签一个证书部署到apache或nginx" class="headerlink" title="用openssl签一个证书部署到apache或nginx"></a>用openssl签一个证书部署到apache或nginx</h4><h2 id="五、架构篇"><a href="#五、架构篇" class="headerlink" title="五、架构篇"></a>五、架构篇</h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ol><li>数据一致性、服务治理、服务降级</li></ol><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ol><li>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC</li></ol><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><ol><li><p>服务注册、服务发现，服务治理</p></li><li><p><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a></p></li></ol><h4 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h4><ol><li>怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase</li></ol><h4 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h4><ol><li>mfs、fastdfs</li></ol><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><ol><li>缓存一致性、缓存命中率、缓存冗余</li></ol><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><ol><li>Hystrix、Sentinal</li></ol><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li><p>共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法</p></li><li><p>2PC、3PC</p></li></ol><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ol><li>SOA、康威定律</li></ol><h4 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h4><ol><li>sidecar</li></ol><h4 id="Docker-amp-Kubernets"><a href="#Docker-amp-Kubernets" class="headerlink" title="Docker &amp; Kubernets"></a>Docker &amp; Kubernets</h4><h4 id="Spring-Boot-1"><a href="#Spring-Boot-1" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><h4 id="Spring-Cloud-1"><a href="#Spring-Cloud-1" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><h4 id="分库分表-1"><a href="#分库分表-1" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="CDN技术"><a href="#CDN技术" class="headerlink" title="CDN技术"></a>CDN技术</h4><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ol><li>ActiveMQ</li></ol><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="监控什么"><a href="#监控什么" class="headerlink" title="监控什么"></a>监控什么</h4><ol><li>CPU、内存、磁盘I/O、网络I/O等</li></ol><h4 id="监控手段"><a href="#监控手段" class="headerlink" title="监控手段"></a>监控手段</h4><ol><li>进程监控、语义监控、机器资源监控、数据波动</li></ol><h4 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h4><ol><li>日志、埋点</li></ol><h4 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h4><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ol><li><p>tomcat负载均衡、Nginx负载均衡</p></li><li><p>四层负载均衡、七层负载均衡</p></li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ol><li>DNS原理、DNS的设计</li></ol><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol><li>数据一致性</li></ol><h2 id="六、-扩展篇"><a href="#六、-扩展篇" class="headerlink" title="六、 扩展篇"></a>六、 扩展篇</h2><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><ol><li>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</li></ol><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ol><li>Solr、Lucene、Nutch、Elasticsearch</li></ol><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ol><li>Shiro</li></ol><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><ol><li>哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名</li></ol><h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><ol><li>挖矿、共识机制、闪电网络、侧链、热点问题、分叉</li></ol><h4 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h4><h4 id="超级账本"><a href="#超级账本" class="headerlink" title="超级账本"></a>超级账本</h4><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><ol><li>数学基础、机器学习、人工神经网络、深度学习、应用场景。</li></ol><h4 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h4><ol><li>TensorFlow、DeepLearning4J</li></ol><h3 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h3><h3 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h3><h3 id="AR-amp-VR"><a href="#AR-amp-VR" class="headerlink" title="AR &amp; VR"></a>AR &amp; VR</h3><h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><ol><li>Groovy、Python、Go、NodeJs、Swift、Rust</li></ol><h2 id="六、-推荐书籍"><a href="#六、-推荐书籍" class="headerlink" title="六、 推荐书籍"></a>六、 推荐书籍</h2><ol><li>《深入理解Java虚拟机》</li><li>《Effective Java》</li><li>《深入分析Java Web技术内幕》</li><li>《大型网站技术架构》</li><li>《代码整洁之道》</li><li>《架构整洁之道》</li><li>《Head First设计模式》</li><li>《maven实战》</li><li>《区块链原理、设计与应用》</li><li>《Java并发编程实战》</li><li>《鸟哥的Linux私房菜》</li><li>《从Paxos到Zookeeper》</li><li>《架构即未来》</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://yoursite.com/2017/04/15/2017-04-15-spring-introduction/"/>
    <id>http://yoursite.com/2017/04/15/2017-04-15-spring-introduction/</id>
    <published>2017-04-14T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>为什么要使用Spring？</p><p>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p><ul><li>DI（Dependency Injection，依赖注入）</li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul><h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>每一个类实现了Bean的规范才可以由Spring来接管，那么Bean的规范是什么呢？</p><ul><li>必须是个公有(public)类</li><li>有无参构造函数</li><li>用公共方法暴露内部成员属性(getter,setter)</li></ul><p>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</p><h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI-依赖注入"></a>DI-依赖注入</h3><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p><h3 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP-面向切面编程"></a>AOP-面向切面编程</h3><p>就以日志系统为例。在执行某个操作前后都需要输出日志，如果手工加代码，那简直太可怕了。而且等代码庞大起来，也是非常难维护的一种情况。这里就需要面向切面来编程</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><h3 id="关于Bean"><a href="#关于Bean" class="headerlink" title="关于Bean"></a>关于Bean</h3><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。我们对图进行详细描述：</p><ol><li>Spring对bean进行实例化；</li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</li><li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ol><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p><ul><li>单例（Singleton）：在整个应用中，只创建bean的一个实例。</li><li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li><li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li></ul><p>在代码里看起来是这样的：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Scope</span>(<span class="type">ConfigurableBeanFactory</span>.<span class="type">SCOPE_PROTOTYPE</span>)</span><br><span class="line">public class <span class="type">MyIsBean</span><span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure></p><p>XML版本：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"BEANID"</span></span><br><span class="line">  <span class="built_in">class</span> = <span class="string">"net.itxm.beans"</span></span><br><span class="line">  scope=<span class="string">"prototype"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p><p>在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><p>有时候，可能会发现，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。</p><h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><p>以下是声明Bean的注解：</p><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层使用</li><li>@Repository 在数据访问层使用</li><li>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用</li><li>在这里，可以指定bean的id名：Component(“yourBeanName”)</li><li>同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</li></ul><h3 id="关于依赖注入"><a href="#关于依赖注入" class="headerlink" title="关于依赖注入"></a>关于依赖注入</h3><h4 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h4><p><strong>@Autowired Spring提供的注解</strong></p><p>不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。</p><p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。</p><p>如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。</p><p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。</p><p><code>@Inject</code>注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持<code>@Inject</code>和<code>@Autowired</code>。尽管<code>@Inject</code>和<code>@Autowired</code>之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p><p><code>@Autowired</code> 是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和<code>@Autowired</code> 相近：</p><p><code>@Inject</code> 是JSR-330提供的注解<br><code>@Resource</code> 是JSR-250提供的注解</p><h4 id="条件化的Bean"><a href="#条件化的Bean" class="headerlink" title="条件化的Bean"></a>条件化的Bean</h4><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。</p><p>在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。</p><p>通过ConditionContext，我们可以做到如下几点：</p><ul><li>借助getRegistry()返回的BeanDefinitionRegistry检查bean定义；</li><li>借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性；</li><li>借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么；</li><li>读取并探查getResourceLoader()返回的ResourceLoader所加载的资源；</li><li>借助getClassLoader()返回的ClassLoader加载并检查类是否存在。</li></ul><h4 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h4><p><strong>标示首选的bean</strong></p><p>在声明bean的时候，通过将其中一个可选的bean设置为首选（primary）bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其他可选的bean。实际上，你所声明就是“最喜欢”的bean。</p><p><strong>限定自动装配的bean</strong></p><p>设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义性的选项中。它只能标示一个优先的可选方案。当首选bean的数量超过一个时，我们并没有其他的方法进一步缩小可选范围。</p><p>与之相反，Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小选择范围。</p><p><code>@Qualifier</code>注解是使用限定符的主要方式。它可以与<code>@Autowired</code>和<code>@Inject</code>协同使用，在注入的时候指定想要注入进去的是哪个bean。例如，我们想要确保要将IceCream注入到setDessert()之中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是使用限定符的最简单的例子。为<code>@Qualifier</code>注解所设置的参数就是想要注入的bean的ID。所有使用<code>@Component</code>注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。因此，<code>@Qualifier(“iceCream”)</code>指向的是组件扫描时所创建的bean，并且这个bean是IceCream类的实例。</p><p>实际上，还有一点需要补充一下。更准确地讲，<code>@Qualifier(“iceCream”)</code>所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话，所有的bean都会给定一个默认的限定符，这个限定符与bean的ID相同。因此，框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean，它是IceCream类在组件扫描的时候创建的。</p><p>基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCream类，将其重命名为Gelato的话，那此时会发生什么情况呢？如果这样的话，bean的ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符。自动装配会失败。</p><p>这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失效。</p><h4 id="SpringEL"><a href="#SpringEL" class="headerlink" title="SpringEL"></a>SpringEL</h4><ul><li>Value实现资源的注入  </li></ul><h4 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h4><ul><li>Java配置方式：initMethod和destoryMethod</li><li>注解：@PostConstruct和@PreDestory</li></ul><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><p>提供在不同的环境下使用不同的配置</p><p><strong>激活Profile</strong></p><p>Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。如果spring.profiles.active和spring.profiles.default均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。</p><p><strong>使用profile进行测试</strong></p><p>当运行集成测试时，通常会希望采用与生产环境（或者是生产环境的部分子集）相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在运行测试时，我们就需要有一种方式来启用合适的profile。</p><p>Spring提供了<code>@ActiveProfiles</code>注解，我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。</p><p>比如<code>Profile(“dev”)</code></p><h4 id="Application-Event"><a href="#Application-Event" class="headerlink" title="Application Event"></a>Application Event</h4><p>使用Application Event可以做到Bean与Bean之间的通信</p><p>Spring的事件需要遵循如下流程：</p><ul><li>自定义事件，集成ApplicationEvent</li><li>定义事件监听器，实现ApplicationListener</li><li>使用容器发布事件</li></ul><h3 id="关于AOP"><a href="#关于AOP" class="headerlink" title="关于AOP"></a>关于AOP</h3><h4 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h4><p><strong>通知（Advice）</strong></p><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p><p>Spring切面可以应用5种类型的通知：</p><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。  </li></ul><p>对应注解：</p><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>—-</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>—-</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>—-</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr><tr><td>—-</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr><tr><td>—-</td></tr></tbody></table><p><strong>连接点（Join point）</strong></p><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p><strong>切点（Pointcut）</strong></p><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处” 。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p><p><strong>切面（Aspect）</strong></p><p>通知+切点=切面</p><p><strong>引入（Introduction）</strong></p><p>引入允许我们向现有的类添加新方法或属性</p><p><strong>织入（Weaving）</strong></p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li></ul><h4 id="Spring对AOP的支持："><a href="#Spring对AOP的支持：" class="headerlink" title="Spring对AOP的支持："></a>Spring对AOP的支持：</h4><ol><li>基于代理的经典Spring AOP；</li><li>纯POJO切面（4.x版本需要XML配置）；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）。</li></ol><p><strong>例子</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Performance()&#123;</span><br><span class="line">  public void perform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来写一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* concert.Performance.perform(..)</span></span>)</span><br><span class="line"><span class="comment">//execution：在方法执行时触发</span></span><br><span class="line"><span class="comment">//*：返回任意类型</span></span><br><span class="line"><span class="comment">//concert.Performance：方法所属类</span></span><br><span class="line"><span class="comment">//perform：方法名</span></span><br><span class="line"><span class="comment">//(..)：使用任意参数</span></span><br></pre></td></tr></table></figure><p>不仅如此，还可以写的更复杂一点</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution<span class="comment">(* concert.Performance.perform(..)&amp;&amp;within(concert.*)</span>)</span><br><span class="line"><span class="comment">//增加了一个与操作，当concert包下的任意类方法被调用时也会触发</span></span><br></pre></td></tr></table></figure><p>在切点中选择bean</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(*concert.Performance.perform()</span></span>) and bean(<span class="string">'woodstock'</span>)</span><br><span class="line"><span class="comment">//限定bean id为woodstock</span></span><br></pre></td></tr></table></figure><p>来个完整的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span>&#123;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"execution(**concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"execution&#123;** concert.Performance.perform&#123;..&#125;&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"execution&#123;** concert.Performance.perform&#123;..&#125;&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterThrowing</span>(<span class="string">"execution&#123;** concert.Performance.perform&#123;..&#125;&#125;"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demanRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简化一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span>&#123;</span><br><span class="line">  <span class="comment">//避免频繁使用切点表达式</span></span><br><span class="line">  <span class="meta">@Pointcut</span>(<span class="string">"execution(** concert.Performance.perform(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterReturning</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demanRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XML中声明切面</strong></p><table><thead><tr><th>AOP配置元素</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;aop:advisor&gt;</code></td><td>定义AOP通知器</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:after&gt;</code></td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:after-returning&gt;</code></td><td>定义AOP返回通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:after-throwing&gt;</code></td><td>定义AOP异常通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:around&gt;</code></td><td>定义AOP环绕通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:aspect&gt;</code></td><td>定义一个切面</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:aspectj-autoproxy&gt;</code></td><td>启用@AspectJ注解驱动的切面</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:before&gt;</code></td><td>定义一个AOP前置通知</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:config&gt;</code></td><td>顶层的AOP配置元素。大多数的<a href="aop:*" target="_blank" rel="noopener">aop:*</a>元素必须包含在<a href="aop:config" target="_blank" rel="noopener">aop:config</a>元素内</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:declare-parents&gt;</code></td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td>—-</td></tr><tr><td><code>&lt;aop:pointcut&gt;</code></td><td>定义一个切点</td></tr><tr><td>—-</td></tr></tbody></table><p>来个栗子</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Audience</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过XML将无注解的Audience声明为切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"audience"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"sillenceCellPhones"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"taskSeats"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span></span></span><br><span class="line"><span class="tag">      <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">"applause"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:After-throwing</span></span></span><br><span class="line"><span class="tag">        <span class="attr">pointcut</span> =<span class="string">"execution(** concert.Performance.perform(..))"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">method</span>=<span class="string">"demanRefund"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AspectJ关于Spring AOP的AspectJ切点，最重要的一点就是Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。让我们回顾下，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。下表列出了Spring AOP所支持的AspectJ切点指示器。</p><p>Spring借助AspectJ的切点表达式语言来定义Spring切面</p><table><thead><tr><th>AspectJ指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</td></tr><tr><td>@annotation</td><td>限定匹配带有指定注解的连接点</td></tr></tbody></table><h3 id="Spring高级特性"><a href="#Spring高级特性" class="headerlink" title="Spring高级特性"></a>Spring高级特性</h3><p>由于Spring特殊的依赖注入技巧，导致Bean之间没有耦合度。</p><p>但是Bean有时需要使用spring容器本身的资源，这时你的Bean必须意识到Spring容器的存在。所以得使用Spring Aware，下面来看看Spring Aware提供的接口</p><table><thead><tr><th>BeanNameAware</th><th>获得到容器中Bean的名称</th></tr></thead><tbody><tr><td>BeanFactory</td><td>获得当前的bean factory，这样可以调用容器的服务</td></tr><tr><td>ApplicationContextAware*</td><td>当前application context，这样可以调用容器的服务</td></tr><tr><td>MessageSourceAware</td><td>获得Message source</td></tr><tr><td>ApplicationEventPublisherAware</td><td>应用时间发布器，可以发布时间，</td></tr><tr><td>ResourceLoaderAware</td><td>获得资源加载器，可以获得外部资源文件</td></tr></tbody></table><h4 id="TaskExecutor"><a href="#TaskExecutor" class="headerlink" title="@TaskExecutor"></a>@TaskExecutor</h4><p>这样可以实现多线程和并发编程。通过@EnableAsync开启对异步任务的支持，并通过实际执行的Bean的方法始中使用@Async注解来声明其是一个异步任务</p><h4 id="Scheduled-计划任务"><a href="#Scheduled-计划任务" class="headerlink" title="@Scheduled 计划任务"></a>@Scheduled 计划任务</h4><p>首先通过在配置类注解@EnableScheduling来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务</p><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>根据满足某一个特定条件创建一个特定的Bean。</p><h4 id="组合注解与元注解"><a href="#组合注解与元注解" class="headerlink" title="组合注解与元注解"></a>组合注解与元注解</h4><p>元注解就是可以注解到别的注解上的注解，被注解的注解称之为组合注解，组合注解具备注解其上的元注解的功能。</p><p><strong>@Enable*注解的工作原理</strong></p><p>通过观察这些@Enable*注解的源码，我们发现所有的注解都有一个@Import注解，@Import是用来导入配置类的，这也就意外着这些自动开启的实现其实是导入了一些自动配置的Bean。这些导入配置的方式主要范围以下三种类型：</p><ul><li>第一类：直接导入配置类</li><li>第二类：依据条件选择配置类</li><li>第三类：动态注册Bean</li></ul><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>简单的分析一下Spring。</p><p>Spring 框架中的核心组件只有三个：Core、Context 和 Bean。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。</p><h3 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h3><p>用过Spring的同学都知道Bean在Spring的作用是非常重要的。通过一系列简单的配置来满足类与类之间的依赖关系——这叫做依赖注入。而依赖注入的关系是在一个叫IOC的容器中进行管理。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>我们说到Spring 框架中的核心组件只有三个：<strong>Core</strong>、<strong>Context</strong> 和 <strong>Bean</strong>。那么Core和Context是如何协作的呢？</p><p>我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器 ，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具。</p><h4 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h4><p>前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>ApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。</p><p>ApplicationContext 的子类主要包含两个方面：</p><ul><li>ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext类。</li><li>WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。</li></ul><p>再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。</p><p>总体来说 ApplicationContext 必须要完成以下几件事：</p><ul><li>标识一个应用环境</li><li>利用 BeanFactory 创建 Bean 对象</li><li>保存对象关系表</li><li>能够捕获各种事件</li></ul><p>Context 作为 Spring 的 IOC 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。</p><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><p>Core 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://yoursite.com/2017/04/08/2017-04-08-mybatis-introduction/"/>
    <id>http://yoursite.com/2017/04/08/2017-04-08-mybatis-introduction/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p><strong>使用JDBC编程问题总结</strong><br><strong>1.JDBC编程步骤</strong>  </p><ol><li>加载数据库驱动</li><li>创建并获取数据库链接</li><li>创建jdbc statement对象</li><li>设置sql语句</li><li>设置sql语句中的参数(使用preparedStatement)</li><li>通过statement执行sql并获取结果</li><li>对sql执行结果进行解析处理</li><li>释放资源(resultSet、preparedstatement、connection)</li></ol><p><strong>2.JDBC问题总结</strong>  </p><ol><li>数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。</li><li>Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。</li><li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。  </li></ol><h3 id="1-MyBatis介绍"><a href="#1-MyBatis介绍" class="headerlink" title="1. MyBatis介绍"></a>1. MyBatis介绍</h3><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。<br>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。<br><strong>MyBatis架构</strong><br><img src="/2017/04/08/2017-04-08-mybatis-introduction/mybatis-architecture.png" alt="MyBatis架构"></p><h3 id="2-MyBatis配置"><a href="#2-MyBatis配置" class="headerlink" title="2. MyBatis配置"></a>2. MyBatis配置</h3><ol><li>mybatis配置<br>SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。<br>mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。  </li><li>通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂</li><li>由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。</li><li>mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。</li><li>Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。</li><li>Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。</li><li>Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。</li></ol><h4 id="从-XML-中构建-SqlSessionFactory"><a href="#从-XML-中构建-SqlSessionFactory" class="headerlink" title="从 XML 中构建 SqlSessionFactory"></a>从 XML 中构建 SqlSessionFactory</h4><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String<span class="built_in"> resource </span>= <span class="string">"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p><p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。这里先给出一个简单的示例：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE configuration</span></span></span><br><span class="line"><span class="xml">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="xml">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;driver&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;username&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;password&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。</p><h3 id="3-Mapper-XML-文件"><a href="#3-Mapper-XML-文件" class="headerlink" title="3. Mapper XML 文件"></a>3. Mapper XML 文件</h3><p>MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。</p><p>SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）：</p><ul><li><code>cache</code> – 给定命名空间的缓存配置。</li><li><code>cache-ref</code> – 其他命名空间缓存配置的引用。</li><li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li><li><code>parameterMap</code> – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</li><li><code>sql</code> – 可被其他语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句</li><li><code>update</code> – 映射更新语句</li><li><code>delete</code> – 映射删除语句</li><li><code>select</code> – 映射查询语句</li></ul><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如：</p><pre><code>&lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt;  SELECT * FROM PERSON WHERE ID = #{id}&lt;/select&gt;</code></pre><p>这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：</p><p><code>#{id}</code><br>这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Similar JDBC <span class="meta">code</span>, NOT MyBatis…</span><br><span class="line"><span class="keyword">String </span><span class="keyword">selectPerson </span>= <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">PreparedStatement</span> ps = conn.prepareStatement(<span class="keyword">selectPerson);</span></span><br><span class="line"><span class="keyword">ps.setInt(1,id);</span></span><br></pre></td></tr></table></figure></p><p>下面就是 insert，update 和 delete 语句的示例：</p><pre><code>&lt;insert id=&quot;insertAuthor&quot;&gt;  insert into Author (id,username,password,email,bio)  values (#{id},#{username},#{password},#{email},#{bio})&lt;/insert&gt;&lt;update id=&quot;updateAuthor&quot;&gt;  update Author set    username = #{username},    password = #{password},    email = #{email},    bio = #{bio}  where id = #{id}&lt;/update&gt;&lt;delete id=&quot;deleteAuthor&quot;&gt;  delete from Author where id = #{id}&lt;/delete&gt;</code></pre><p>如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，而且有多种生成方式。</p><p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为:</p><pre><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;    keyProperty=&quot;id&quot;&gt;  insert into Author (username,password,email,bio)  values (#{username},#{password},#{email},#{bio})&lt;/insert&gt;</code></pre><p>如果你的数据库还支持多行插入, 你也可以传入一个Authors数组或集合，并返回自动生成的主键。</p><pre><code>&lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot;    keyProperty=&quot;id&quot;&gt;  insert into Author (username, password, email, bio) values  &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt;    (#{item.username}, #{item.password}, #{item.email}, #{item.bio})  &lt;/foreach&gt;&lt;/insert&gt;</code></pre><h4 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h4><p>MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。</p><p>虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。</p><p>动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach<br><strong>if</strong></li></ul><p>动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如：</p><pre><code>&lt;select id=&quot;findActiveBlogWithTitleLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG  WHERE state = ‘ACTIVE’  &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;&lt;/select&gt;</code></pre><p>这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果（细心的读者可能会发现，“title”参数值是可以包含一些掩码或通配符的）。</p><p>如果希望通过“title”和“author”两个参数进行可选搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;  &lt;if test=&quot;author != null and author.name != null&quot;&gt;    AND author_name like #{author.name}  &lt;/if&gt;&lt;/select&gt;</code></pre><p><strong>choose, when, otherwise</strong>  </p><p>有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是这次变为提供了“title”就按“title”查找，提供了“author”就按“author”查找的情形，若两者都没有提供，就返回所有符合条件的 BLOG（实际情况可能是由管理员按一定策略选出 BLOG 列表，而不是返回大量无意义的随机结果）。</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG WHERE state = ‘ACTIVE’  &lt;choose&gt;    &lt;when test=&quot;title != null&quot;&gt;      AND title like #{title}    &lt;/when&gt;    &lt;when test=&quot;author != null and author.name != null&quot;&gt;      AND author_name like #{author.name}    &lt;/when&gt;    &lt;otherwise&gt;      AND featured = 1    &lt;/otherwise&gt;  &lt;/choose&gt;&lt;/select&gt;</code></pre><p><strong>trim, where, set</strong></p><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到“if”示例，这次我们将“ACTIVE = 1”也设置成动态的条件，看看会发生什么。</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG  WHERE  &lt;if test=&quot;state != null&quot;&gt;    state = #{state}  &lt;/if&gt;  &lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;  &lt;if test=&quot;author != null and author.name != null&quot;&gt;    AND author_name like #{author.name}  &lt;/if&gt;&lt;/select&gt;</code></pre><p>如果这些条件没有一个能匹配上会发生什么？最终这条 SQL 会变成这样：</p><pre><code>SELECT * FROM BLOGWHERE</code></pre><p>这会导致查询失败。如果仅仅第二个条件匹配又会怎样？这条 SQL 最终会是这样:</p><pre><code>SELECT * FROM BLOGWHEREAND title like ‘someTitle’</code></pre><p>这个查询也会失败。这个问题不能简单地用条件句式来解决，如果你也曾经被迫这样写过，那么你很可能从此以后都不会再写出这种语句了。</p><p>MyBatis 有一个简单的处理，这在 90% 的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能达到目的：</p><pre><code>&lt;select id=&quot;findActiveBlogLike&quot;     resultType=&quot;Blog&quot;&gt;  SELECT * FROM BLOG  &lt;where&gt;    &lt;if test=&quot;state != null&quot;&gt;         state = #{state}    &lt;/if&gt;    &lt;if test=&quot;title != null&quot;&gt;        AND title like #{title}    &lt;/if&gt;    &lt;if test=&quot;author != null and author.name != null&quot;&gt;        AND author_name like #{author.name}    &lt;/if&gt;  &lt;/where&gt;&lt;/select&gt;</code></pre><p>where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。</p><p>如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><pre><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;  ...&lt;/trim&gt;</code></pre><p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容，并且插入 prefix 属性中指定的内容。</p><p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以用于动态包含需要更新的列，而舍去其它的。比如：</p><pre><code>&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;  update Author    &lt;set&gt;      &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;      &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt;      &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt;    &lt;/set&gt;  where id=#{id}&lt;/update&gt;</code></pre><p>这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号。（译者注：因为用的是“if”元素，若最后一个“if”没有匹配上而前面的匹配上，SQL 语句的最后就会有一个逗号遗留）</p><p>若你对 set 元素等价的自定义 trim 元素的代码感兴趣，那这就是它的真面目：</p><pre><code>&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;  ...&lt;/trim&gt;</code></pre><p>注意这里我们删去的是后缀值，同时添加了前缀值。</p><p><strong>foreach</strong>  </p><p>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p><pre><code>&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;  SELECT *  FROM POST P  WHERE ID in  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{item}  &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p><p>注意 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><p>到此我们已经完成了涉及 XML 配置文件和 XML 映射文件的讨论。下一章将详细探讨 Java API，这样就能提高已创建的映射文件的利用效率。</p><p><strong>bind</strong>  </p><p>bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：</p><pre><code>&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;  &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + _parameter.getTitle() + &apos;%&apos;&quot; /&gt;  SELECT * FROM BLOG  WHERE title LIKE #{pattern}&lt;/select&gt;</code></pre><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><h4 id="1-和"><a href="#1-和" class="headerlink" title="(1) #{}和${}"></a>(1) <code>#{}</code>和<code>${}</code></h4><p><code>#{}</code>表示一个占位符号，通过<code>#{}</code>可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。<code>#{}</code>可以有效防止sql注入。 <code>#{}</code>可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，<code>#{}</code>括号中可以是value或其它名称。</p><p><code>${}</code>表示拼接sql串，通过<code>${}</code>可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， <code>${}</code>可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，<code>${}</code>括号中只能是value。</p><h4 id="2-parameterType和resultType"><a href="#2-parameterType和resultType" class="headerlink" title="(2) parameterType和resultType"></a>(2) parameterType和resultType</h4><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。</p><p>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中</p><h4 id="3-selectOne和selectList"><a href="#3-selectOne和selectList" class="headerlink" title="(3) selectOne和selectList"></a>(3) selectOne和selectList</h4><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常。</p><p>selectList可以查询一条或多条记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>EL表达式</title>
    <link href="http://yoursite.com/2017/04/05/2017-04-05-el/"/>
    <id>http://yoursite.com/2017/04/05/2017-04-05-el/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><h3 id="1．EL-表达式概述"><a href="#1．EL-表达式概述" class="headerlink" title="1．EL 表达式概述"></a>1．EL 表达式概述</h3><p>EL（Express Lanuage）表达式可以嵌入在jsp页面内部，减少jsp脚本的编写，EL出现的目的是要替代jsp页面中脚本的编写。</p><h3 id="2．EL从域中取出数据"><a href="#2．EL从域中取出数据" class="headerlink" title="2．EL从域中取出数据"></a>2．EL从域中取出数据</h3><p>EL最主要的作用是获得四大域中的数据，格式${EL表达式}<br>EL获得pageContext域中的值：<code>$(pageContextScope.key)</code>;<br>EL获得request域中的值：<code>$(request.key)</code>;<br>EL获得session域中的值：<code>$(session.key)</code>;<br>EL获得application域中的值：<code>$(application.key)</code>;<br>EL从四个域中获得某个值<code>$(key)</code>;<br>—同样是依次从pageContext域，request域，session域，application域中    获取属性，在某个域中获取后将不在向后寻找  </p><h3 id="3．EL的内置对象"><a href="#3．EL的内置对象" class="headerlink" title="3．EL的内置对象"></a>3．EL的内置对象</h3><p><strong>pageScope</strong><br><strong>requestScope</strong><br><strong>sessionScope</strong><br><strong>applicationScope</strong>  </p><table><thead><tr><th>获取JSP中域中的数据</th></tr></thead><tbody><tr><td>param,paramValues</td><td>接收参数</td></tr><tr><td>—-</td></tr><tr><td>header,headerValues</td><td>获取请求头信息</td></tr><tr><td>—-</td></tr><tr><td>initParam</td><td>获取全局初始化参数</td></tr><tr><td>—-</td></tr><tr><td>cookie</td><td>WEB开发中cookie</td></tr><tr><td>—-</td></tr><tr><td>pageContext</td><td>WEB开发中的pageContext</td></tr><tr><td>—-</td></tr></tbody></table><p><code>$(pageContext.request.contextPath)</code><br>相当于<br><code>&lt;%=pageContext.getRequest().getContextPath%&gt;</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="el" scheme="http://yoursite.com/tags/el/"/>
    
  </entry>
  
  <entry>
    <title>JSP</title>
    <link href="http://yoursite.com/2017/04/01/2017-04-01-jsp/"/>
    <id>http://yoursite.com/2017/04/01/2017-04-01-jsp/</id>
    <published>2017-03-31T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h3><h4 id="1．jsp脚本和注释"><a href="#1．jsp脚本和注释" class="headerlink" title="1．jsp脚本和注释"></a>1．jsp脚本和注释</h4><p><strong>jsp脚本：</strong><br>(1)&lt;%java代码%&gt; —– 内部的java代码翻译到service方法的内部<br>(2)&lt;%=java变量或表达式&gt; —– 会被翻译成service方法内部out.print()<br>(3)&lt;%!java代码%&gt; —- 会被翻译成servlet的成员的内容<br><strong>jsp注释：</strong>  不同的注释可见范围是不同<br>(1)Html注释：<!--注释内容--> —可见范围 jsp源码、翻译后的servlet、页面显示html源码<br>(2)java注释：//单行注释  /<em>多行注释</em>/ –可见范围 jsp源码 翻译后的servlet<br>(3)jsp注释：&lt;%–注释内容–%&gt; —– 可见范围 jsp源码可见</p><h4 id="2．jsp运行原理—–jsp本质就是servlet"><a href="#2．jsp运行原理—–jsp本质就是servlet" class="headerlink" title="2．jsp运行原理—–jsp本质就是servlet"></a>2．jsp运行原理—–jsp本质就是servlet</h4><p>jsp在第一次被访问时会被Web容器翻译成servlet，在执行过程：<br><img src="/2017/04/01/2017-04-01-jsp/jsp-process.jpg" alt="JSP执行过程"><br>PS：被翻译后的servlet在Tomcat的work目录中可以找到</p><h4 id="3．jsp指令"><a href="#3．jsp指令" class="headerlink" title="3．jsp指令"></a>3．jsp指令</h4><p>jsp的指令是指导jsp翻译和运行的命令，jsp包括三大指令：<br><strong>(1)page指令</strong> — 属性最多的指令（实际开发中page指令默认）<br>属性最多的一个指令，根据不同的属性，指导整个页面特性<br>格式：&lt;%@ page 属性名1= “属性值1” 属性名2= “属性值2” …%&gt;<br>常用属性如下：<br>language：jsp脚本中可以嵌入的语言种类<br>pageEncoding：当前jsp文件的本身编码—内部可以包含contentType<br>contentType：response.setContentType(text/html;charset=UTF-8)<br>session：是否jsp在翻译时自动创建session<br>import：导入java的包<br>errorPage：当当前页面出错后跳转到哪个页面<br>isErrorPage：当前页面是一个处理错误的页面  </p><p><strong>(2)include指令</strong><br>页面包含（静态包含）指令，可以将一个jsp页面包含到另一个jsp页面中<br>格式：&lt;%@ include file=”被包含的文件地址”%&gt;  </p><p><strong>(3)taglib指令</strong><br>在jsp页面中引入标签库（jstl标签库、struts2标签库）<br>格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt;  </p><h4 id="4．jsp内置对象（9个）"><a href="#4．jsp内置对象（9个）" class="headerlink" title="4．jsp内置对象（9个）"></a>4．jsp内置对象（9个）</h4><p>jsp被翻译成servlet之后，service方法中有9个对象定义并初始化完毕，我们在jsp    脚本中可以直接使用这9个对象  </p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:center">类型</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:left">out</td><td style="text-align:center">javax.servlet.jsp.JspWriter</td><td style="text-align:right">用于页面输出</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">request</td><td style="text-align:center">javax.servlet.http.HttpServletRequest</td><td style="text-align:right">得到用户请求信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">response</td><td style="text-align:center">javax.servlet.http.HttpServletResponse</td><td style="text-align:right">服务器向客户端的回应信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">config</td><td style="text-align:center">javax.servlet.ServletConfig</td><td style="text-align:right">服务器配置，可以取得初始化参数</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">session</td><td style="text-align:center">javax.servlet.http.HttpSession</td><td style="text-align:right">用来保存用户的信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">application</td><td style="text-align:center">javax.servlet.ServletContext</td><td style="text-align:right">所有用户的共享信息</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">page</td><td style="text-align:center">java.lang.Object</td><td style="text-align:right">指当前页面转换后的Servlet类的实例</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">pageContext</td><td style="text-align:center">javax.servlet.jsp.PageContext</td><td style="text-align:right">JSP的页面容器</td></tr><tr><td style="text-align:left">—-</td></tr><tr><td style="text-align:left">exception</td><td style="text-align:center">java.lang.Throwable</td><td style="text-align:right">表示JSP页面所发生的异常，在错误页中才起作用</td></tr><tr><td style="text-align:left">—-</td></tr></tbody></table><p><strong>(1)out对象</strong><br>out的类型：JspWriter<br>out作用就是想客户端输出内容—-out.write()<br>out缓冲区默认8kb 可以设置成0 代表关闭out缓冲区 内容直接写到respons缓冲    器  </p><p><strong>(2)pageContext对象</strong><br>jsp页面的上下文对象，作用如下：<br>page对象与pageContext对象不是一回事<br>1.pageContext是一个域对象<br>setAttribute(String name,Object obj)<br>getAttribute(String name)<br>removeAttrbute(String name)  </p><p>2.pageContext可以向指定的其他域中存取数据<br>setAttribute(String name,Object obj,int scope)<br>getAttribute(String name,int scope)<br>removeAttrbute(String name,int scope)<br>findAttribute(String name)<br>—依次从pageContext域，request域，session域，application域中获取属性，在某个域中获取后将不在向后寻找</p><p>3.可以获得其他8大隐式对象<br>例如： pageContext.getRequest()<br>pageContext.getSession()</p><p><strong>四大作用域：</strong><br>page域：当前jsp页面范围<br>request域：一次请求<br>session域：一次会话<br>application域：整个web应用  </p><h4 id="5．jsp标签（动作）"><a href="#5．jsp标签（动作）" class="headerlink" title="5．jsp标签（动作）"></a>5．jsp标签（动作）</h4><p><strong>(1)页面包含(动态包含)：</strong><code>&lt;jsp :include page=&quot;a.jsp&quot;/&gt;</code>  </p><p><strong>(2)请求转发：</strong><code>&lt;jsp:forward page=&quot;要转发的资源&quot; /&gt;</code>  </p><p><strong>动态包含与静态包含的区别：</strong><br>1.静态包含: <code>&lt;%@include  file=&quot;fileurl&quot;%&gt;</code><br>2.动态包含: <code>&lt;jsp :include page=&quot;a.jsp&quot;/&gt;</code><br>(1)静态包含发生在：JSP—-&gt;java文件阶段。动态包含发生在：执行class文件阶段,动态加入。<br>(2)静态包含：只生成一个java文件，动态包含：生成多个class文件。<br>(3)静态包含不会检查所包含文件中的变化；但是动态包含，每次检查所含文件中的变化，并且可以带参数</p><p><strong>请求转发与请求重定向的区别：</strong><br>1.请求转发：request.getRequestDispatcher().forward(req,resp)<br>服务器行为，request.getRequestDispatcher().forward(req,resp);是一次请求，转发后请求对象会保存，地址栏的URL地址不会改变。<br>2.请求重定向：response.sendRedirect()<br>客户端行为，response.sendRedirect(),从本质上讲等同于两次请求，前一次的请求对象不会保存，地址栏的URL地址会改变。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jsp" scheme="http://yoursite.com/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>Session</title>
    <link href="http://yoursite.com/2017/03/25/2017-03-25-session/"/>
    <id>http://yoursite.com/2017/03/25/2017-03-25-session/</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间存储客户的数据，但客户端需要每次都携带一个标识ID去服务器中寻找属于自己的内存空间。所以说Session的实现是基于Cookie，Session需要借助于Cookie存储客户的唯一性标识JSESSIONID</p><h3 id="Session的使用"><a href="#Session的使用" class="headerlink" title="Session的使用"></a>Session的使用</h3><h4 id="1．获得Session对象"><a href="#1．获得Session对象" class="headerlink" title="1．获得Session对象"></a>1．获得Session对象</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HttpSession session</span> = request.getSession();</span><br></pre></td></tr></table></figure><p>此方法会获得专属于当前会话的Session对象，如果服务器端没有该会话的Session对象会创建一个新的Session返回，如果已经有了属于该会话的Session直接将已有的Session返回（实质就是根据JSESSIONID判断该客户端是否在服务器上已经存在    session了）</p><h4 id="2．向session中存取数据（session也是一个域对象）"><a href="#2．向session中存取数据（session也是一个域对象）" class="headerlink" title="2．向session中存取数据（session也是一个域对象）"></a>2．向session中存取数据（session也是一个域对象）</h4><p>Session也是存储数据的区域对象，所以session对象也具有如下三个方法：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(<span class="keyword">String</span> <span class="keyword">name</span>,<span class="keyword">Object</span> obj);</span><br><span class="line">session.getAttribute(<span class="keyword">String</span> <span class="keyword">name</span>);</span><br><span class="line">session.removeAttribute(<span class="keyword">String</span> <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></p><h4 id="3．Session对象的生命周期"><a href="#3．Session对象的生命周期" class="headerlink" title="3．Session对象的生命周期"></a>3．Session对象的生命周期</h4><p><strong>创建：</strong>第一次执行request.getSession()时创建<br><strong>销毁：</strong><br>1.服务器(非正常)关闭时<br>2.session过期/失效（默认30分钟,从不操作服务器端的资源开始计时）,可以在工程的web.xml中进行配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>3.手动销毁session<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.invalidate()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="session" scheme="http://yoursite.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="http://yoursite.com/2017/03/22/2017-03-22-cookie/"/>
    <id>http://yoursite.com/2017/03/22/2017-03-22-cookie/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie技术是将用户的数据存储到客户端本地的技术<br><strong>优点：</strong>数据存储在客户端本地，减少服务器端的存储的压力<br><strong>缺点：</strong>安全性存在问题</p><h3 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h3><h4 id="1．服务器端向客户端发送一个Cookie"><a href="#1．服务器端向客户端发送一个Cookie" class="headerlink" title="1．服务器端向客户端发送一个Cookie"></a>1．服务器端向客户端发送一个Cookie</h4><p><strong>(1)创建Cookie：</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> <span class="type">Cookie</span>(<span class="keyword">String</span> cookieName,<span class="keyword">String</span> cookieValue);</span><br></pre></td></tr></table></figure></p><p>cookie会以响应头的形式发送给客户端<br>注意：Cookie中不能存储中文<br><strong>(2)设置Cookie在客户端的持久化时间：</strong><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setMaxAge(int seconds)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>注意：如果不设置持久化时间，cookie会存储在浏览器的内存中，浏览器关闭cookie信息销毁（会话级别的cookie），如果设置持久化时间，cookie信息会被持久化到浏览器的磁盘文件里<br>cookie.setMaxAge(10*60);<br>设置cookie信息在浏览器的磁盘文件中存储的时间是10分钟，过期浏览器会自动删除该cookie信息    <strong>(3)设置Cookie的路径：</strong><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setPath(String path)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>注意：如果不设置携带路径，那么该cookie信息会在访问产生该cookie的web资源所在的路径都携带cookie信息<br>示例：  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cookie</span><span class="selector-class">.setPath</span>(<span class="string">"/WEB16"</span>);<span class="comment">// 代表访问WEB16应用中的任何资源都携带cookie</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">cookie</span><span class="selector-class">.setPath</span>(<span class="string">"/WEB16/cookieServlet"</span>);<span class="comment">// 代表访问WEB16中的cookieServlet时才携带cookie信息</span></span><br></pre></td></tr></table></figure><p><strong>(4)向客户端发送cookie：</strong>      </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.<span class="keyword">addCookie(Cookie </span>cookie)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>(5)删除客户端的cookie：</strong><br>如果想删除客户端的已经存储的cookie信息，那么就使用同名同路径的持久化时间为0的cookie进行覆盖即可</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> <span class="type">Cookie</span>(<span class="string">"key"</span>, <span class="literal">null</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="2．服务器端接受客户端携带的Cookie"><a href="#2．服务器端接受客户端携带的Cookie" class="headerlink" title="2．服务器端接受客户端携带的Cookie"></a>2．服务器端接受客户端携带的Cookie</h4><p>cookie信息是以请求头的方式发送到服务器端的<br><strong>(1)通过request获得所有的Cookie：</strong><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><strong>(2)遍历Cookie数组，通过Cookie的名称获得我们想要的Cookie</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Cookie cookie : <span class="type">cookies</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cookie.getName().equal(cookieName))&#123;</span><br><span class="line">String cookieValue = cookie.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://yoursite.com/2017/03/16/2017-03-16-jdbc/"/>
    <id>http://yoursite.com/2017/03/16/2017-03-16-jdbc/</id>
    <published>2017-03-15T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JDBC技术"><a href="#JDBC技术" class="headerlink" title="JDBC技术"></a>JDBC技术</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准方法。<br>简单地说，JDBC 可做三件事：与数据库建立连接、发送 操作数据库的语句并处理结果。</p><h3 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2.执行过程"></a>2.执行过程</h3><p>第一步：Class.forName()加载数据库连接驱动；<br>第二步：DriverManager.getConnection()获取数据连接对象;<br>第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;<br>第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX();<br>第五步：关闭结果集、关闭会话、关闭连接。<br>下列代码段给出了JDBC执行过程的基本示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">Connection con = DriverManager.getConnection(<span class="string">"jdbc:odbc:wombat"</span>,<span class="string">"login"</span>,<span class="string">"password"</span>);</span><br><span class="line">Statement stmt = con.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">"SELECT a, b, c FROM Table1"</span>);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">int x = rs.getInt(<span class="string">"a"</span>);</span><br><span class="line">String s = rs.getString(<span class="string">"b"</span>);</span><br><span class="line">float f = rs.getFloat(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-相关知识点"><a href="#3-相关知识点" class="headerlink" title="3.相关知识点"></a>3.相关知识点</h3><h4 id="PreparedStatement的优点"><a href="#PreparedStatement的优点" class="headerlink" title="PreparedStatement的优点"></a>PreparedStatement的优点</h4><p>1、PreparedStatement 接口继承 Statement，PreparedStatement 实例包含已编译的 SQL 语句，所以其执行速度要快于 Statement 对象。<br>2、作为Statement的子类，PreparedStatement继承了Statement的所有功能。三种方法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数。<br>3、在 JDBC 应用中,在任何时候都不要使用 Statement，原因如下：<br>一、代码的可读性和可维护性.Statement 需要不断地拼接，而 PreparedStatement 不会。<br>二、PreparedStatement 尽最大可能提高性能.DB 有缓存机制，相同的预编译语句再次被调用不会再次需要编译。<br>三、最重要的一点是极大地提高了安全性.Statement 容易被 SQL 注入，而 reparedStatementc 传入的内容不会和 sql 语句发生任何匹配关系。  </p><h4 id="关系型数据库中连接池的机制"><a href="#关系型数据库中连接池的机制" class="headerlink" title="关系型数据库中连接池的机制"></a>关系型数据库中连接池的机制</h4><p>前提：为数据库连接建立一个缓冲池。<br>1：从连接池获取或创建可用连接<br>2：使用完毕之后，把连接返回给连接池<br>3：在系统关闭前，断开所有连接并释放连接占用的系统资源<br>4：能够处理无效连接，限制连接池中的连接总数不低于或者不超过某个限定值。  </p><h4 id="事物处理"><a href="#事物处理" class="headerlink" title="事物处理"></a>事物处理</h4><p>Connection类中提供了3个事务处理方法:<br>  setAutoCommit(Boolean autoCommit):设置是否自动提交事务,默认为自动提交,即为true,通过设置false禁止自动提交事务;<br>  commit():提交事务;<br>  rollback():回滚事务  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="jdbc" scheme="http://yoursite.com/tags/jdbc/"/>
    
  </entry>
  
  <entry>
    <title>Android ContentProvider</title>
    <link href="http://yoursite.com/2017/03/12/2017-03-12-android-contentprovider/"/>
    <id>http://yoursite.com/2017/03/12/2017-03-12-android-contentprovider/</id>
    <published>2017-03-11T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-ContentProvider"><a href="#1-ContentProvider" class="headerlink" title="1 ContentProvider"></a>1 ContentProvider</h2><p>ContentProvider在android中的作用是可以通过ContentProvider把应用中的数据共享给其他应用访问，其他应用可以通过ContentProvider对应用中的数据进行增、删、改、查。使用ContentProvider对外共享数据的好处是，统一了数据的访问方式，它实际上是对SQLiteOpenHelper的进一步封装，通过Uri映射来判断选择需要曹组哦数据库中的哪个表，并且进行增、删、改、查处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="ContentProvider" scheme="http://yoursite.com/tags/ContentProvider/"/>
    
  </entry>
  
  <entry>
    <title>Android Broadcast</title>
    <link href="http://yoursite.com/2017/02/26/2017-02-26-android-broadcast/"/>
    <id>http://yoursite.com/2017/02/26/2017-02-26-android-broadcast/</id>
    <published>2017-02-25T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Broadcast-广播"><a href="#1-Broadcast-广播" class="headerlink" title="1 Broadcast(广播)"></a>1 Broadcast(广播)</h2><p>Broadcast是一种广泛运用的、在应用程序之间传输信息的机制，一个广播可以有任意个接收者。广播机制是一个典型的发布——订阅模式，最大的特点就是发送方不关心接收方是否接到数据，也不关心是如何处理数据的，通过这样的形式来达到接、收双方的完全解耦合。</p><p>Android中的广播使用了<strong>设计模式</strong>中的<strong>观察者模式</strong>：基于消息的发布 / 订阅事件模型</p><p>Android广播机制包含3个基本要素，分别是用于发送广播的Broadcast、接收广播的BroadcastReceiver以及用于传递信息的Intent。Android广播可分为普通广播、有序广播、本地广播和Sticky。</p><h3 id="1-1-普通广播"><a href="#1-1-普通广播" class="headerlink" title="1.1 普通广播"></a>1.1 普通广播</h3><p>  普通广播是完全<strong>异步</strong>的，通过Context的sendBroadcast()函数发送，<br><strong>优点</strong>：消息传递的效率比较高。<br><strong>缺点</strong>：receivers(接收器)的执行顺序不确定，接收者不能讲处理结果传递给下一个接收者，并且无法终止广播Intent的传播，直到没有与之匹配的广播接收器为止。<br>1、首先定义一个广播接收器，如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HelloBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcaseReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) &#123;</span><br><span class="line"><span class="type">Toast</span>.makeText(context, <span class="string">"hello"</span>, <span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、注册广播，可以通过AndroidManifest.xml静态注册或者代码动态注册。</p><p>AndroidManifest.xml静态注册：<br><code>&lt;receiver android:name=&quot;.broadcast.HelloBroadcastReceiver&quot;&gt;&lt;/receiver&gt;</code></p><p>代码动态注册：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHelloBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">registerReceiver(<span class="keyword">new</span> HelloBroadcastReceiver(), <span class="keyword">new</span> IntentFilter(HELLO_ACTION));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是在Activity或者Fragment中动态测试，那么不要忘了在执行onDestory时注销该广播。</p><p>3、发送广播<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNormalBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sendBroadcast(<span class="keyword">new</span> Intent(HELLO_ACTION));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就会调用HelloBroadcastReceiver的onReceive函数，在该函数中执行相关操作即可。</p><h3 id="1-2-有序广播"><a href="#1-2-有序广播" class="headerlink" title="1.2 有序广播"></a>1.2 有序广播</h3><p>有序广播通过Context.sendOrderedBroadcast()来发送，所有的广播接收器按照优先级依次执行，广播接收器的优先级通过AndroidManifest.xml中的receiver的intent-filter中的android:priority属性来设置，数值越大优先级越高。当广播接收器接收到广播后，可以使用setResult()函数来将结果传给下一个广播接收器接收，然后通过getResult()函数来取得上个广播接收器返回的结果，并可以用abortBroadcast()函数来让系统丢弃该广播，使该广播不再传送到别的广播接收器。</p><h3 id="1-3-本地广播"><a href="#1-3-本地广播" class="headerlink" title="1.3 本地广播"></a>1.3 本地广播</h3><p>之前的广播都是全局的，所有应用程序都可以接收到，这样就会带来安全隐患。<br>LocalBroadcastManager能够实现限于应用内的广播，只是进程内使用，提高程序的安全性。</p><h3 id="1-4-sticky广播"><a href="#1-4-sticky广播" class="headerlink" title="1.4 sticky广播"></a>1.4 sticky广播</h3><p>sticky广播通过Context.sendStickyBroadcast()函数来发送，用此函数发送的广播会一直滞留，当有匹配此广播的广播接收器被注册后，该广播接收器就会收到此条广播。使用此函数发送广播时，需要获得BROADCAST_STICKY权限：</p><p><code>&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt;</code></p><p>sendStickyBroadcast只保留最后一条广播，并且一直保留下去，这样即使已经有广播接收器处理了该广播，当再有匹配的广播接收器被注册时，此广播仍会被接收。如果你只想处理一遍该广播，可以通过removeStickyBroadcast函数实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="Broadcast" scheme="http://yoursite.com/tags/Broadcast/"/>
    
  </entry>
  
  <entry>
    <title>Android Service</title>
    <link href="http://yoursite.com/2017/02/12/2017-02-12-android-service/"/>
    <id>http://yoursite.com/2017/02/12/2017-02-12-android-service/</id>
    <published>2017-02-11T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Service与AIDL"><a href="#1-Service与AIDL" class="headerlink" title="1 Service与AIDL"></a>1 Service与AIDL</h2><p>Service是Android中实现程序后台运行的解决方案，适合用于那些不需要和用户交互而且还要求长期运行的任务。但不要被“后台”二字所迷惑，Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作。</p><p>Service的运行不依赖于任何用户界面，即使程序被切换到后台或者用户打开了另一个应用程序，Service仍然能够保持正常运行，这也正是Service的使用场景。当某个应用程序进程被杀掉时，所有依赖于该进程的Service也会停止运行。</p><h3 id="1-1-普通Service"><a href="#1-1-普通Service" class="headerlink" title="1.1 普通Service"></a>1.1 普通Service</h3><p>Service的生命周期只有三个，分别为<strong>onCreate</strong>、<strong>onStartCommand</strong>和<strong>onDestory</strong>。一旦在项目的任何位置调用了Context的startService()函数，相应的服务就会启动起来，首次创建时会调用onCreate函数，然后回调onStartCommand()函数。服务启动之后会一直保持运行状态，直到stopService()或stopSelf()函数被调用。虽然每调用一次startService()函数，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService()函数，只需调用一个stopService()或stopSelf()函数，服务就会被停止。</p><p>与Activity一样，Service也需要在AndroidManifest.xml中进行注册。</p><h3 id="1-2-IntentService"><a href="#1-2-IntentService" class="headerlink" title="1.2 IntentService"></a>1.2 IntentService</h3><p>IntentService将用户的请求执行在一个子线程中，用户只需要覆写onHandleIntent函数，并且在该函数中完成自己的耗时操作即可。需要注意的是，在任务执行完毕之后IntentService会调用stopSelf自我销毁，因此，它适用于完成一些短期的耗时任务。</p><h3 id="1-3-运行在前台的Service"><a href="#1-3-运行在前台的Service" class="headerlink" title="1.3 运行在前台的Service"></a>1.3 运行在前台的Service</h3><p>将Service运行在前台不仅不会被系统无情地回收，它还会在通知栏显示一条消息，下拉状态栏后可以看到更加详细的信息。例如，墨迹天气在前台运行了一个Service，并且在Service中定时更新通知栏上的天气信息。</p><h3 id="1-4-AIDL"><a href="#1-4-AIDL" class="headerlink" title="1.4 AIDL"></a>1.4 AIDL</h3><p>Android Interface Definition Language(Android接口定义语言)，同行用于进程间通信（Android系统中的进程之间不能共享内存）。  </p><p>Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.</p><p>“只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL”，其他情况下你都可以选择其他方法，如使用Messager，也能跨进程通讯。可见AIDL是处理多线程、多客户端并发访问的。而Messager是单线程处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="service" scheme="http://yoursite.com/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>Android Activity</title>
    <link href="http://yoursite.com/2017/02/02/2017-02-02-android-activity/"/>
    <id>http://yoursite.com/2017/02/02/2017-02-02-android-activity/</id>
    <published>2017-02-01T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Activity"><a href="#1-Activity" class="headerlink" title="1 Activity"></a>1 Activity</h2><h3 id="1-1-Activity的生命周期"><a href="#1-1-Activity的生命周期" class="headerlink" title="1.1 Activity的生命周期"></a>1.1 Activity的生命周期</h3><p><img src="/2017/02/02/2017-02-02-android-activity/activity_lifecycle.png" alt="Activity的生命周期"><br><strong>1.onCreate()</strong></p><p>onCreate()方法会在Activity第一次被创建时调用，通常会在这个函数中完成Activity的初始化操作，如设置布局、初始化视图、绑定事件等。</p><p><strong>2.onStart()</strong></p><p>这个函数在Activity可见之前被调用。</p><p><strong>3.onResume()</strong></p><p>这个函数在Activity变为可见时被调用，执行完onResume之后，Activity就会请求AMS渲染它所管理的视图。此时的Activity一定位于返回栈的栈顶，并且处于运行状态。可见的、有焦点的。</p><p><strong>4.onPause()</strong></p><p>这个函数在Activity失去焦点，从可见变为不完全可见时调用。</p><p><strong>5.onStop()</strong></p><p>这个函数在Activity完全不可见时调用。</p><p><strong>6.onDestroy()</strong></p><p>这个函数在Activity被销毁之前调用，之后Activity的状态变为销毁状态。在这个函数里释放内存。</p><p><strong>7.onRestart()</strong></p><p>这个函数在Activity由停止状态重新变为运行状态之前调用，下一个调用onStart()。</p><p>###1.2 Activity的构成 ###</p><p>PhoneWindow→DecorView→DefultLayout→ViewGroup:mContentParent→用户自己的xml布局</p><h3 id="1-3-Activity的4种启动模式"><a href="#1-3-Activity的4种启动模式" class="headerlink" title="1.3 Activity的4种启动模式"></a>1.3 Activity的4种启动模式</h3><p><strong>1.standard</strong></p><p>在这种模式下启动的Activity可以被多次实例化，每启动一个Activity都会在栈顶创建一个新的实例。实际开发中，闹钟程序通常使采用这种模式。如果Activity是一个非常耗资源的类，那么将会使应用消耗更多的系统资源。</p><p><strong>2.singleTop</strong></p><p>singleTop模式启动Activity时，首先会判断要启动Acitity实例是否位于栈顶，如果位于栈顶则直接复用，否则与standard模式相同，创建一个新的实例。实际开发中，浏览器的书签通常采用这种模式。</p><p><strong>3.singleTask</strong></p><p>singleTask模式可以保证一个任务栈中只能有一个该Activity实例。每次启动该Activity时，首先会判断该Acitivity是否存在任务栈中，如果已存在，系统会销毁该Activity之上的所有Activity实例，最终让该Activity实例位于栈顶。如果任务栈中没有该Activity实例，会新创建一个实例并放在栈顶。在实际开发中，浏览器主界面通常采用这种模式。</p><p><strong>4.singleInstance</strong></p><p>设置为singleInstance模式的Activity会启动一个独立的任务栈来管理Activity实例，并且这个任务栈中有且只有一个实例。如果要启动的Activity已存在，无论当前Activity位于哪个程序哪个任务栈中，系统都会把Activity所在的任务栈转移到前台，从而使Activity显示。实际开发中，来电界面通常采用这种模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="activity" scheme="http://yoursite.com/tags/activity/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件</title>
    <link href="http://yoursite.com/2017/01/28/2017-01-28-android-components/"/>
    <id>http://yoursite.com/2017/01/28/2017-01-28-android-components/</id>
    <published>2017-01-27T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>入门训练 Fibonacci数列</title>
    <link href="http://yoursite.com/2017/01/18/2017-01-18-introductory-training-fibonacci-sequence/"/>
    <id>http://yoursite.com/2017/01/18/2017-01-18-introductory-training-fibonacci-sequence/</id>
    <published>2017-01-18T11:05:52.000Z</published>
    <updated>2019-03-18T13:44:37.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p><p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含一个整数n。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个整数，表示Fn除以10007的余数。</p><blockquote><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p></blockquote><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p><code>10</code></p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p><code>55</code></p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p><code>22</code></p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p><code>7704</code></p><h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p><code>1 &lt;= n &lt;= 1,000,000</code></p><p>提交序号    1209677<br>提交时间    2017-01-18 19:05:30<br>评测结果    正确<br>得分    100<br>CPU使用    250ms<br>内存使用    21.17MB<br>试题名称    入门训练 Fibonacci数列<br>语言    JAVA<br>源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a1,a2;  </span><br><span class="line">    a1=a2=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,temp;<span class="comment">//sum是保存余数的变量 ，temp是为了方便交换数据   </span></span><br><span class="line">    <span class="keyword">long</span> n;<span class="comment">//因为n&gt;=1 and n&lt;=1000000   </span></span><br><span class="line">    <span class="keyword">long</span> i;  </span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">n = scanner.nextLong();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        sum=a1 % <span class="number">10007</span>;  </span><br><span class="line">        temp=a2;  </span><br><span class="line">        a2=(a1+a2) % <span class="number">10007</span>;  </span><br><span class="line">        a1=temp;   </span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="http://yoursite.com/2016/08/26/2016-08-26-jquery/"/>
    <id>http://yoursite.com/2016/08/26/2016-08-26-jquery/</id>
    <published>2016-08-25T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><ul><li>是什么?</li></ul><blockquote><p>javascript 的代码框架。  </p></blockquote><ul><li>有什么用?</li></ul><blockquote><p>简化代码，提高效率。  </p></blockquote><ul><li>核心</li></ul><blockquote><p>write less do more , 写得更少，做的更多。</p></blockquote><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">""</span> onclick=<span class="string">"load()"</span>&gt;使用JQuery执行<span class="built_in">load</span>方法&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">有两次刷新，  先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=<span class="string">""</span>的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示</span></span><br><span class="line">$(<span class="string">"#aaa"</span>).<span class="built_in">load</span>(<span class="string">"/day16/DemoServlet02"</span> , <span class="function"><span class="keyword">function</span><span class="params">(responseText , statusTXT  , xhr)</span> &#123;</span></span><br><span class="line"><span class="comment">//找到id为text01的元素， 设置它的value属性值为 responseText 对应的值</span></span><br><span class="line">$(<span class="string">"#aaa"</span>).val(responseText);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(<span class="string">"/day16/DemoServlet02"</span>  , <span class="function"><span class="keyword">function</span>(<span class="params">data ,status</span>) </span>&#123;</span><br><span class="line">$(<span class="string">"#div01"</span>).text(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="赋值显示"><a href="#赋值显示" class="headerlink" title="赋值显示"></a>赋值显示</h1><ul><li>val(“aa”);</li></ul><blockquote><p>只能放那些标签带有value属性</p><ul><li>html(“aa”); —写html代码</li><li>text(“aa”);</li></ul></blockquote><blockquote><p>其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html()</p></blockquote><h3 id="load-amp-get"><a href="#load-amp-get" class="headerlink" title="load &amp; get"></a>load &amp; get</h3><ul><li><p>load</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span><span class="string">"#元素id"</span>).load(url地址);</span><br><span class="line"></span><br><span class="line"><span class="variable">$(</span><span class="string">"#div1"</span>).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值</span><br></pre></td></tr></table></figure></li><li><p>get<br>语法格式 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(URL,callback);</span><br></pre></td></tr></table></figure></li></ul><p>使用案例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(<span class="string">"/day16/DemoServlet02"</span>  , <span class="function"><span class="keyword">function</span>(<span class="params">data ,status</span>) </span>&#123;</span><br><span class="line">$(<span class="string">"#div01"</span>).text(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>post<br>语法格式：<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="type">URL</span>,<span class="class"><span class="keyword">data</span>,callback);</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$.post(<span class="string">"/day16/DemoServlet02"</span>, &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>) </span>&#123;</span><br><span class="line"><span class="comment">//想要放数据到div里面去。 --- 找到div</span></span><br><span class="line">$(<span class="string">"#div01"</span>).html(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用JQuery去实现校验用户名"><a href="#使用JQuery去实现校验用户名" class="headerlink" title="使用JQuery去实现校验用户名"></a>使用JQuery去实现校验用户名</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkUserName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1. 获取输入框的内容</span></span><br><span class="line"><span class="keyword">var</span> name = $(<span class="string">"#name"</span>).val();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送请求</span></span><br><span class="line">$.post(<span class="string">"/day16/CheckUserNameServlet"</span> , &#123;<span class="attr">name</span>:name&#125; , <span class="function"><span class="keyword">function</span>(<span class="params">data , status</span>)</span>&#123;</span><br><span class="line"><span class="comment">//alert(data);</span></span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1</span>)&#123;<span class="comment">//用户名存在</span></span><br><span class="line"><span class="comment">//alert("用户名存在");</span></span><br><span class="line">$(<span class="string">"#span01"</span>).html(<span class="string">"&lt;font color='red'&gt;用户名已被注册&lt;/font&gt;"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//alert("用户名可用");</span></span><br><span class="line">$(<span class="string">"#span01"</span>).html(<span class="string">"&lt;font color='green'&gt;用户名可以使用&lt;/font&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">//3. 输出响应的数据到页面上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现百度搜索提示"><a href="#实现百度搜索提示" class="headerlink" title="实现百度搜索提示"></a>实现百度搜索提示</h2><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol><li>定义首页</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"word"</span> <span class="attr">id</span>=<span class="string">"word"</span> <span class="attr">style</span>=<span class="string">"width: 600px ; height: 50px  ;font-size: 20px;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"百度一下"</span>  <span class="attr">style</span>=<span class="string">"height: 55px ; width: 100px ; "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div01"</span> <span class="attr">style</span>=<span class="string">"position:relative; left : -54px; width: 600px; height: 200px ; border:  1px solid blue; display: none"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义数据库</li></ol><h3 id="捕获键盘弹起"><a href="#捕获键盘弹起" class="headerlink" title="捕获键盘弹起"></a>捕获键盘弹起</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#word"</span>).keyup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">"键盘弹起了.."</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="JS请求"><a href="#JS请求" class="headerlink" title="JS请求"></a>JS请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#word"</span>).keyup(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//2。 获取输入框的值</span></span><br><span class="line"><span class="comment">//var word = $("#word").val();</span></span><br><span class="line"><span class="comment">//this  对应就是执行这个方法的那个对象， $("#word")</span></span><br><span class="line"><span class="keyword">var</span> word = $(<span class="keyword">this</span>).val();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(word == <span class="string">""</span>)&#123;</span><br><span class="line">$(<span class="string">"#div01"</span>).hide();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//3. 请求数据。</span></span><br><span class="line">$.post(<span class="string">"find"</span>,&#123;<span class="attr">word</span>:word&#125; ,<span class="function"><span class="keyword">function</span>(<span class="params">data , status</span>)</span>&#123;</span><br><span class="line"><span class="comment">//alert(data);</span></span><br><span class="line">$(<span class="string">"#div01"</span>).show();</span><br><span class="line">$(<span class="string">"#div01"</span>).html(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Servlet代码"><a href="#Servlet代码" class="headerlink" title="Servlet代码"></a>Servlet代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="built_in">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 先获取参数</span></span><br><span class="line"><span class="keyword">String</span> <span class="keyword">word</span> = request.getParameter(<span class="string">"word"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"word="</span>+<span class="keyword">word</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 让dao执行查询</span></span><br><span class="line">WordsDao dao = <span class="keyword">new</span> WordsDaoImpl();</span><br><span class="line">List&lt;WordBean&gt; list = dao.findWords(<span class="keyword">word</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">for</span> (WordBean wordBean : list) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"==="</span>+wordBean.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.setAttribute(<span class="string">"list"</span>, list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 返回数据</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="comment">//response.getWriter().write("数据是：");</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"list.jsp"</span>).forward(request, response);</span><br><span class="line">&#125; <span class="built_in">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list-jsp"><a href="#list-jsp" class="headerlink" title="list.jsp"></a>list.jsp</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span></span><br><span class="line"><span class="xml">    pageEncoding="UTF-8"%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span>  <span class="attr">prefix</span>=<span class="string">"c"</span>%&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">​</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"width: 100%"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;list &#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">var</span>=<span class="string">"wordBean"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span>$</span><span class="template-variable">&#123;wordBean.words&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="使用JQuery实现-省市联动"><a href="#使用JQuery实现-省市联动" class="headerlink" title="使用JQuery实现 省市联动"></a>使用JQuery实现 省市联动</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>准备数据库</li></ol><p>2 。 准备页面<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery-1.11.3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/city.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">省份: <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"province"</span> <span class="attr">id</span> =<span class="string">"province"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span> &gt;</span>-请选择 -</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span> &gt;</span>广东</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span> &gt;</span>湖南</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span> &gt;</span>湖北</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"4"</span> &gt;</span>四川</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">城市:</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"city"</span> <span class="attr">id</span>=<span class="string">"city"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span> &gt;</span>-请选择 -</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="XStream的使用"><a href="#XStream的使用" class="headerlink" title="XStream的使用"></a>XStream的使用</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 返回数据。手动拼  ---&gt; XStream  转化 bean对象成 xml</span></span><br><span class="line">XStream xStream = <span class="keyword">new</span> XStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//想把id做成属性</span></span><br><span class="line">xStream.useAttributeFor(CityBean.<span class="keyword">class</span>, <span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置别名</span></span><br><span class="line">xStream.<span class="keyword">alias</span>(<span class="string">"city"</span>, CityBean.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化一个对象成xml字符串</span></span><br><span class="line">String xml = xStream.toXML(list);</span><br></pre></td></tr></table></figure><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1。找到省份的元素</span></span><br><span class="line">$(<span class="string">"#province"</span>).change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据</span></span><br><span class="line"><span class="comment">//$("#province").varl();</span></span><br><span class="line"><span class="keyword">var</span> pid = $(<span class="keyword">this</span>).val();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*&lt;list&gt;</span></span><br><span class="line"><span class="comment">&lt;city&gt;</span></span><br><span class="line"><span class="comment">&lt;id&gt;1&lt;id&gt;</span></span><br><span class="line"><span class="comment">&lt;pid&gt;1&lt;/pid&gt;</span></span><br><span class="line"><span class="comment">&lt;cname&gt;深圳&lt;/cname&gt;</span></span><br><span class="line"><span class="comment">&lt;/city&gt;</span></span><br><span class="line"><span class="comment">&lt;city &gt;</span></span><br><span class="line"><span class="comment">&lt;id&gt;2&lt;id&gt;</span></span><br><span class="line"><span class="comment">&lt;pid&gt;1&lt;/pid&gt;</span></span><br><span class="line"><span class="comment">&lt;cname&gt;东莞&lt;/cname&gt;</span></span><br><span class="line"><span class="comment">&lt;/city&gt;</span></span><br><span class="line"><span class="comment">&lt;/list&gt;*/</span></span><br><span class="line"></span><br><span class="line">$.post( <span class="string">"CityServlet"</span>,&#123;<span class="attr">pid</span>:pid&#125; ,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line"><span class="comment">//alert("回来数据了:"+data);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先清空以前的值：</span></span><br><span class="line">$(<span class="string">"#city"</span>).html(<span class="string">"&lt;option value='' &gt;-请选择-"</span>)</span><br><span class="line"><span class="comment">//遍历：</span></span><br><span class="line"><span class="comment">//从data数据里面找出所有的city  ， 然后遍历所有的city。</span></span><br><span class="line"><span class="comment">//遍历一个city，就执行一次function方法</span></span><br><span class="line">$(data).find(<span class="string">"city"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历出来的每一个city，取它的孩子。 id , cname</span></span><br><span class="line"><span class="keyword">var</span> id = $(<span class="keyword">this</span>).children(<span class="string">"id"</span>).text();</span><br><span class="line"><span class="keyword">var</span> cname = $(<span class="keyword">this</span>).children(<span class="string">"cname"</span>).text();</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#city"</span>).append(<span class="string">"&lt;option value='"</span>+id+<span class="string">"' &gt;"</span>+cname)</span><br><span class="line">&#125;);</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="服务器和客户端数据传输的方式"><a href="#服务器和客户端数据传输的方式" class="headerlink" title="服务器和客户端数据传输的方式"></a>服务器和客户端数据传输的方式</h2><ul><li><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pid</span>&gt;</span>1<span class="tag">&lt;/<span class="name">pid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cname</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">cname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">city</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>2<span class="tag">&lt;<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pid</span>&gt;</span>1<span class="tag">&lt;/<span class="name">pid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cname</span>&gt;</span>东莞<span class="tag">&lt;/<span class="name">cname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>json</p><p>阅读性更好 、 容量更小。</p><p>{“name”:”aaa” , “age”:19}</p></li></ul><p>把javaBean  转化成 json数据<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//3.</span> 把list <span class="params">---</span>&gt; json数据</span><br><span class="line"><span class="string">//JSONArray</span> <span class="params">---</span>&gt; 变成数组 ， 集合  []</span><br><span class="line"><span class="string">//JSONObject</span> <span class="params">---</span>&gt; 变成简单的数据  &#123; name : zhangsan , age<span class="function">:18</span>&#125;</span><br><span class="line"></span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject<span class="params">(list)</span>;</span><br><span class="line">String json = jsonArray.toString<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p><h2 id="使用json格式数据显示省市联动效果"><a href="#使用json格式数据显示省市联动效果" class="headerlink" title="使用json格式数据显示省市联动效果"></a>使用json格式数据显示省市联动效果</h2><pre><code>serlvet代码：</code></pre><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response) throws <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 获取参数</span></span><br><span class="line">int pid = <span class="type">Integer</span>.parseInt(request.getParameter(<span class="string">"pid"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 找出所有的城市</span></span><br><span class="line"><span class="type">CityDao</span> dao = <span class="function"><span class="keyword">new</span> <span class="title">CityDaoImpl</span>();</span></span><br><span class="line"><span class="function"><span class="title">List</span>&lt;<span class="title">CityBean</span>&gt; <span class="title">list</span> = <span class="title">dao</span>.<span class="title">findCity</span>(pid);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//3. 把list ---&gt; json数据</span></span></span><br><span class="line"><span class="function"><span class="comment">//JSONArray ---&gt; 变成数组 ， 集合  []</span></span></span><br><span class="line"><span class="function"><span class="comment">//JSONObject ---&gt; 变成简单的数据  &#123; name : zhangsan , age:18&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">JSONArray</span> <span class="title">jsonArray</span> = <span class="title">JSONArray</span>.<span class="title">fromObject</span>(list);</span></span><br><span class="line"><span class="function"><span class="title">String</span> <span class="title">json</span> = <span class="title">jsonArray</span>.<span class="title">toString</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">response</span>.<span class="title">setContentType</span>("text/html;charset=utf<span class="number">-8</span>");</span></span><br><span class="line"><span class="function"><span class="title">response</span>.<span class="title">getWriter</span>().<span class="title">write</span>(json);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&#125; <span class="title">catch</span> (<span class="type">SQLException</span> e) &#123;</span></span><br><span class="line"><span class="function"><span class="comment">// TODO Auto-generated catch block</span></span></span><br><span class="line"><span class="function"><span class="title">e</span>.<span class="title">printStackTrace</span>();</span></span><br><span class="line"><span class="function">&#125;;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><pre><code>js代码</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1。找到省份的元素</span></span><br><span class="line">$(<span class="string">"#province"</span>).change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据</span></span><br><span class="line"><span class="comment">//$("#province").varl();</span></span><br><span class="line"><span class="keyword">var</span> pid = $(<span class="keyword">this</span>).val();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*[</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        "cname": "深圳",</span></span><br><span class="line"><span class="comment">        "id": 1,</span></span><br><span class="line"><span class="comment">        "pid": 1</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        "cname": "东莞",</span></span><br><span class="line"><span class="comment">        "id": 2,</span></span><br><span class="line"><span class="comment">        "pid": 1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">]*/</span></span><br><span class="line">$.post( <span class="string">"CityServlet02"</span>,&#123;<span class="attr">pid</span>:pid&#125; ,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先清空</span></span><br><span class="line">$(<span class="string">"#city"</span>).html(<span class="string">"&lt;option value='' &gt;-请选择-"</span>);</span><br><span class="line"><span class="comment">//再遍历，追加</span></span><br><span class="line">$(data).each(<span class="function"><span class="keyword">function</span>(<span class="params">index , c</span>) </span>&#123;</span><br><span class="line">$(<span class="string">"#city"</span>).append(<span class="string">"&lt;option value='"</span>+c.id+<span class="string">"' &gt;"</span>+c.cname)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,<span class="string">"json"</span> );</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="JQuery-1"><a href="#JQuery-1" class="headerlink" title="JQuery"></a>JQuery</h3><pre><code>发送get请求发送post请求都要求带数据 + 获取数据＋　放置到元素上。---------------------------------------1. 服务器返回xml数据2. 服务器返回json数据</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2016/08/16/2016-08-16-ajax/"/>
    <id>http://yoursite.com/2016/08/16/2016-08-16-ajax/</id>
    <published>2016-08-15T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ul><li>是什么?</li></ul><blockquote><p>“Asynchronous Javascript And XML”（异步JavaScript和XML），</p></blockquote><blockquote><p>并不是新的技术，只是把原有的技术，整合到一起而已。</p></blockquote><pre><code>1.使用CSS和XHTML来表示。2.使用DOM模型来交互和动态显示。3.使用XMLHttpRequest来和服务器进行异步通信。4.使用javascript来绑定和调用。</code></pre><ul><li>有什么用?</li></ul><blockquote><p>咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。  就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。</p></blockquote><h2 id="数据请求-Get"><a href="#数据请求-Get" class="headerlink" title="数据请求 Get"></a>数据请求 Get</h2><p>1.创建对象<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">ajaxFunction</span></span>()&#123;</span><br><span class="line">   <span class="keyword">var</span> xmlHttp;</span><br><span class="line">   <span class="keyword">try</span> &#123; <span class="comment">// Firefox, Opera 8.0+, Safari</span></span><br><span class="line">        xmlHttp=<span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;<span class="comment">// Internet Explorer</span></span><br><span class="line">         xmlHttp=<span class="keyword">new</span> <span class="type">ActiveXObject</span>(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         xmlHttp=<span class="keyword">new</span> <span class="type">ActiveXObject</span>(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (e)&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> xmlHttp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>发送请求</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行get请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建xmlhttprequest 对象</span></span><br><span class="line"><span class="keyword">var</span> request = ajaxFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送请求。</span></span><br><span class="line"><span class="comment">// http://localhost:8080/day16/demo01.jsp</span></span><br><span class="line"><span class="comment">//http://localhost:8080/day16/DemoServlet01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数一： 请求类型  GET or  POST</span></span><br><span class="line"><span class="comment">参数二： 请求的路径</span></span><br><span class="line"><span class="comment">参数三： 是否异步， true  or false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">request.open(<span class="string">"GET"</span> ,<span class="string">"/day16/DemoServlet01"</span> ,<span class="literal">true</span> );</span><br><span class="line">request.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果发送请求的同时，还想获取数据，那么代码如下</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行get请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建xmlhttprequest 对象</span></span><br><span class="line"><span class="keyword">var</span> request = ajaxFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送请求</span></span><br><span class="line">request.open(<span class="string">"GET"</span> ,<span class="string">"/day16/DemoServlet01?name=aa&amp;age=18"</span> ,<span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法</span></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前半段表示 已经能够正常处理。  再判断状态码是否是200</span></span><br><span class="line"><span class="keyword">if</span>(request.readyState == <span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="comment">//弹出响应的信息</span></span><br><span class="line">alert(request.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据请求-Post"><a href="#数据请求-Post" class="headerlink" title="数据请求 Post"></a>数据请求 Post</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">ajaxFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> xmlHttp;</span><br><span class="line">   <span class="keyword">try</span>&#123; <span class="comment">// Firefox, Opera 8.0+, Safari</span></span><br><span class="line">        xmlHttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;<span class="comment">// Internet Explorer</span></span><br><span class="line">         xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (e)&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> xmlHttp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 创建对象</span></span><br><span class="line"><span class="keyword">var</span> request = ajaxFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送请求</span></span><br><span class="line">request.open( <span class="string">"POST"</span>, <span class="string">"/day16/DemoServlet01"</span>, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不带数据，写这行就可以了</span></span><br><span class="line"><span class="comment">//request.send();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想带数据，就写下面的两行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据</span></span><br><span class="line">request.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//带数据过去  ， 在send方法里面写表单数据。</span></span><br><span class="line">request.send(<span class="string">"name=aobama&amp;age=19"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要获取数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 创建对象</span></span><br><span class="line"><span class="keyword">var</span> request = ajaxFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送请求</span></span><br><span class="line">request.open( <span class="string">"POST"</span>, <span class="string">"/day16/DemoServlet01"</span>, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//想获取服务器传送过来的数据， 加一个状态的监听。</span></span><br><span class="line">request.onreadystatechange=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(request.readyState==<span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>)&#123;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"post："</span>+request.responseText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据</span></span><br><span class="line">request.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//带数据过去  ， 在send方法里面写表单数据。</span></span><br><span class="line">request.send(<span class="string">"name=aobama&amp;age=19"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="校验用户名是否可用"><a href="#校验用户名是否可用" class="headerlink" title="校验用户名是否可用"></a>校验用户名是否可用</h2><h3 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1. 搭建环境"></a>1. 搭建环境</h3><ol><li><p>页面准备</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">id</span>=<span class="string">"name"</span>  <span class="attr">onblur</span>=<span class="string">"checkUserName()"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"span01"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数据库准备</p></li></ol><h3 id="2-Servlet代码"><a href="#2-Servlet代码" class="headerlink" title="2. Servlet代码"></a>2. Servlet代码</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> doGet(HttpServletRequest request, HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 检测是否存在</span></span><br><span class="line"><span class="keyword">String</span> name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"name="</span>+name);</span><br><span class="line"></span><br><span class="line">UserDao dao = <span class="keyword">new</span> UserDaomImpl();</span><br><span class="line"><span class="built_in">boolean</span> isExist = dao.checkUserName(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.  通知页面，到底有还是没有。</span></span><br><span class="line"><span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">response.getWriter().<span class="built_in">println</span>(<span class="number">1</span>);  <span class="comment">//存在用户名</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">response.getWriter().<span class="built_in">println</span>(<span class="number">2</span>); <span class="comment">//不存在该用户名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Dao代码"><a href="#3-Dao代码" class="headerlink" title="3. Dao代码"></a>3. Dao代码</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaomImpl</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">UserDao</span></span></span>&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> boolean checkUserName(<span class="keyword">String</span> username) throws SQLException &#123;</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> <span class="type">QueryRunner</span>(JDBCUtil02.getDataSource());</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> sql = <span class="string">"select count(*) from t_user where username =?"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">runner.query(sql, <span class="keyword">new</span>  <span class="type">ScalarHandler</span>(), username);</span><br><span class="line"></span><br><span class="line">Long result = (Long) runner.query(sql, <span class="keyword">new</span>  <span class="type">ScalarHandler</span>(), username);</span><br><span class="line"><span class="keyword">return</span> result &gt; <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jsp页面显示"><a href="#jsp页面显示" class="headerlink" title="jsp页面显示"></a>jsp页面显示</h3><p>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkUserName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输入框的值 document 整个网页</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="built_in">document</span>.getElementById(<span class="string">"name"</span>).value; <span class="comment">// value  value() val val()</span></span><br><span class="line"><span class="comment">//1. 创建对象</span></span><br><span class="line"><span class="keyword">var</span> request = ajaxFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 发送请求</span></span><br><span class="line">request.open(<span class="string">"POST"</span>  ,<span class="string">"/day16/CheckUserNameServlet"</span> , <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册状态改变监听，获取服务器传送过来的数据</span></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(request.readyState == <span class="number">4</span> &amp;&amp; request.status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="comment">//alert(request.responseText);</span></span><br><span class="line"><span class="keyword">var</span> data = request.responseText;</span><br><span class="line"><span class="keyword">if</span>(data == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//alert("用户名已存在");</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"span01"</span>).innerHTML = <span class="string">"&lt;font color='red'&gt;用户名已存在!&lt;/font&gt;"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"span01"</span>).innerHTML = <span class="string">"&lt;font color='green'&gt;用户名可用!&lt;/font&gt;"</span>;</span><br><span class="line"><span class="comment">//alert("用户名未存在");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">request.send(<span class="string">"name="</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Ajax-1"><a href="#Ajax-1" class="headerlink" title="Ajax"></a>Ajax</h3><pre><code>发送get请求发送post请求都要求带数据 + 获取数据＋　放置到元素上。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>七大查找算法汇总</title>
    <link href="http://yoursite.com/2016/08/08/2016-08-08-search-algorithm/"/>
    <id>http://yoursite.com/2016/08/08/2016-08-08-search-algorithm/</id>
    <published>2016-08-07T16:00:00.000Z</published>
    <updated>2019-03-18T13:44:37.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.顺序查找<br>2.二分查找<br>3.插值查找<br>4.斐波那契查找<br>5.树表查找<br>6.分块查找<br>7.哈希查找</p><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。<br><strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。<br><strong>查找算法分类：</strong><br>（1）静态查找和动态查找；<br>    注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。<br>（2）无序查找和有序查找。<br>    无序查找：被查找数列有序无序均可；<br>    有序查找：被查找数列必须为有序数列。<br><strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。<br>对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>Pi：查找表中第i个数据元素的概率。<br>Ci：找到第i个数据元素时已经比较过的次数。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
