<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo-Next主题配置]]></title>
    <url>%2F2019%2F02%2F22%2F2019-02-22-hexo-next-setting%2F</url>
    <content type="text"><![CDATA[1. 搜索功能1.1. 在Hexo根目录下执行 npm install hexo-generator-searchdb –save1.2. blog下的_config.yml文件编辑12345search: path: search.xml field: post format: html limit: 10000 1.3. /blog/themes/next下的_config.yml文件编辑12local_search: enable: true 2. RSS订阅2.1. 在Hexo根目录下执行 npm install hexo-generator-feed –save2.2. blog下的_config.yml文件编辑123456789# RSS订阅plugin:- hexo-generator-feed# RSSfeed: type: atom path: atom.xml limit: 20 2.3. /blog/themes/next下的_config.yml文件编辑1rss: /atom.xml 发布到Github在Hexo根目录下执行 npm install –save hexo-deployer-git自动关联域名 创建../Hexo根目录/source/CNAME 内容为域名，如：www.mingdong.onlinehexo d文章字数统计和阅读时间统计https://github.com/theme-next/hexo-symbols-count-time在Hexo根目录下执行 npm install hexo-symbols-count-time –saveblog下的_config.yml文件编辑12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 博客中插入图片在Hexo根目录下执行 npm install hexo-asset-image –saveblog下的_config.yml文件编辑1post_asset_folder: true live2dhttps://github.com/EYHN/hexo-helper-live2d/blob/master/README.md安装live2d 在Hexo根目录下执行 npm install –save hexo-helper-live2d安装模块包 在Hexo根目录下执行 npm install {packagename} 如:npm install live2d-widget-model-wankoblog下的_config.yml文件编辑12345678910111213141516171819# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url aplayerhttps://github.com/MoePlayer/hexo-tag-aplayer在Hexo根目录下执行 npm install –save hexo-tag-aplayer使用 console.error("Error: [hexo-tag-aplayer] Specified asset file not found ([picture_url,)"); title : 曲目标题 author: 曲目作者 url: 音乐文件 URL 地址 picture_url: (可选) 音乐对应的图片地址 narrow: （可选）播放器袖珍风格 autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能 width:xxx: (可选) 播放器宽度 (默认: 100%) lrc:xxx: （可选）歌词文件 URL 地址当开启 Hexo 的 文章资源文件夹post_asset_folder: true 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： console.error("Error: [hexo-tag-aplayer] Specified asset file not found (picture.jpg)");]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java CPU 100%排查问题与解决]]></title>
    <url>%2F2018%2F06%2F07%2F2018-06-07-java-cpu-100-resolve%2F</url>
    <content type="text"><![CDATA[记一次线上服务器Java程序CPU 100%排查问题与解决 top命令首先用top命令查看当前占用CPU高的进程(PID)1[mingdong@VM_45_31_centos V2]$ top 小写键盘的情况下，Shift+P键按照CPU占用由高到低排序打开大写键盘的情况下，直接按P键 top命令 可以看到占用CPU最高的进程PID是30672然后通过top -Hp 30672查看每个线程占用的CPU情况1[mingdong@VM_45_31_centos V2]$ top -Hp 30672 然后可以看到占用CPU最高的线程tid是30679得到tid之后再将tid转化为16进制30679转化为16进制就是0x77d7用jstack PID查看java虚拟机的堆栈情况1[mingdong@VM_45_31_centos V2]$ jstack 30672 1234567891011121314151617181920212223"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007fe9d8114000 nid=0x77d8 in Object.wait() [0x00007fe9df6a1000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x00000000fc0067d0&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)"VM Thread" os_prio=0 tid=0x00007fe9d810a000 nid=0x77d7 runnable"Gang worker#0 (Parallel GC Threads)" os_prio=0 tid=0x00007fe9d801a800 nid=0x77d2 runnable"Gang worker#1 (Parallel GC Threads)" os_prio=0 tid=0x00007fe9d801c800 nid=0x77d3 runnable"Gang worker#2 (Parallel GC Threads)" os_prio=0 tid=0x00007fe9d801e000 nid=0x77d4 runnable"Gang worker#3 (Parallel GC Threads)" os_prio=0 tid=0x00007fe9d8020000 nid=0x77d5 runnable"Concurrent Mark-Sweep GC Thread" os_prio=0 tid=0x00007fe9d8063000 nid=0x77d6 runnable"VM Periodic Task Thread" os_prio=0 tid=0x00007fe9d8162000 nid=0x77e0 waiting on conditionJNI global references: 1281 可以看到nid=0x77d7是GC所在的线程]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashCode and equals]]></title>
    <url>%2F2017%2F05%2F06%2F2017-05-06-hashCode-and-equals%2F</url>
    <content type="text"><![CDATA[hashCode()方法和equals()方法的区别和联系很多人觉得很简单，但是要回答的时候却答得差强人意。正确的回答应该是先介绍hashCode()和equals()方法的作用是什么，然后才说他的区别，说了区别之后再说使用的时候需要注意到的地方。如果你在了解一些其他人不知道的那就更好了！下边我们就开始介绍 hashCode()和equals()是什么hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。 hashCode()和equals()的区别hashCodehashCode()效率高，但并不是完全可靠的，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。 equalsequals()是完全可靠的，但是重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。 总结 equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的，equals()性能较差。 hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的，hashCode()性能较好。 hashCode()和equals()使用的注意事项 对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ 这种大量的并且快速的对象对比一般使用的hash容器中，比如HashSet,HashMap,HashTable等等，比如HashSet里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equals()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。 然而hashCode()和equals()一样都是基本类Object里的方法，而和equals()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值，比如下面： 123456789public class Person &#123; private int num; private String name; @Override public int hashCode() &#123; return num * name.hashCode(); &#125;&#125; 由于标识这个类的是他的内部的变量num和name,所以我们就根据他们返回一个hash值，作为这个类的唯一hash值。 所以如果我们的对象要想放进hashSet，并且发挥hashSet的特性（即不包含一样的对象），则我们就要重写我们类的hashCode()和equals()方法了。像String,Integer等这种类内部都已经重写了这两个方法。 当然如果我们只是平时想对比两个对象是否一致，则只重写一个equals()，然后利用equals()去对比也行的。 使用规则阿里巴巴规定【强制】关于hashCode和equals的处理，遵循如下规则： 1） 只要重写equals，就必须重写hashCode。2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。3） 如果自定义对象作为Map的键，那么必须重写hashCode和equals。 说明： String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。 什么时候需要重写一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode。 为什么要重载hashCode如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。 这样，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。 为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等 因为是按照hashCode来访问小内存块，所以hashCode必须相等。 HashMap获取一个对象是比较key的hashCode相等和equals为true。 之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equals为false。 为什么需要hashCode 通过hashCode可以很快的查到小内存块。 通过hashCode比较比equals方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java工程师之路]]></title>
    <url>%2F2017%2F04%2F20%2F2017-04-20-to-be-java-coder%2F</url>
    <content type="text"><![CDATA[Java工程师之路 一、基础篇面向对象什么是面向对象 面向对象、面向过程 面向对象的三大基本特征和五大基本原则 平台无关性 Java如何实现的平台无关 JVM还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala） 值传递 值传递、引用传递 为什么说Java中只有值传递 封装、继承、多态 什么是多态、方法重写与重载 Java的继承与实现 构造函数与默认构造函数 类变量、成员变量和局部变量 成员变量和方法作用域 Java基础知识基本数据类型 7种基本数据类型：整型、浮点型、布尔型、字符型 整型中byte、short、int、long的取值范围 什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？ 自动拆装箱 什么是包装类型、什么是基本类型、什么是自动拆装箱 Integer的缓存机制 String 字符串的不可变性 JDK 6和JDK 7中substring的原理及区别、 replaceFirst、replaceAll、replace区别、 String对“+”的重载、字符串拼接的几种方式和区别 String.valueOf和Integer.toString的区别、 switch对String的支持 字符串池、常量池（运行时常量池、Class常量池）、intern 熟悉Java中各种关键字 transient、instanceof、volatile、synchronized、final、static、const 原理及用法。 集合类 常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、 Set和List区别？Set如何保证元素不重复？ Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因 Collection和Collections区别 Arrays.asList获得的List使用时需要注意什么 Enumeration和Iterator区别 fail-fast 和 fail-safe CopyOnWriteArrayList、ConcurrentSkipListMap 枚举 枚举的用法、枚举的实现、枚举与单例、Enum类 Java枚举如何比较 switch对枚举的支持 枚举的序列化如何实现 枚举的线程安全性问题 IO 字符流、字节流、输入流、输出流、 同步、异步、阻塞、非阻塞、Linux 5种IO模型 BIO、NIO和AIO的区别、三种IO的用法与原理、netty Java反射与javassist 反射与工厂模式、 反射有什么作用 Class类 java.lang.reflect.* 动态代理 静态代理、动态代理 动态代理和反射的关系 动态代理的几种实现方式 AOP 序列化 什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全 注解 元注解、自定义注解、Java中常用注解使用、注解与反射的结合 Spring常用注解 JMS 什么是Java消息服务、JMS消息传送模型 JMX java.lang.management.*、 javax.management.* 泛型 泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法 限定通配符和非限定通配符、上下界限定符extends 和 super List和原始类型List之间的区别? List&lt;?&gt;和List之间的区别是什么? 单元测试 junit、mock、mockito、内存数据库（h2） 正则表达式 java.lang.util.regex.* 常用的Java工具库 commons.lang, commons.*... guava-libraries netty API&amp;SPI API、API和SPI的关系和区别 如何定义SPI、SPI的实现原理 异常 异常类型、正确处理异常、自定义异常 Error和Exception 异常链、try-with-resources finally和return的执行顺序 时间处理 时区、冬令时和夏令时、时间戳、Java中时间API 格林威治时间、CET,UTC,GMT,CST几种常见时间的含义和关系 SimpleDateFormat的线程安全性问题 Java 8中的时间处理 如何在东八区的计算机上获取美国时间 编码方式 Unicode、有了Unicode为啥还需要UTF-8 GBK、GB2312、GB18030之间的区别 UTF8、UTF16、UTF32区别 URL编解码、Big Endian和Little Endian 如何解决乱码问题 语法糖 Java中语法糖原理、解语法糖 语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda表达式、 阅读源代码 String、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader &amp; URLClassLoader、ArrayList &amp; LinkedList、 HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap、HashSet &amp; LinkedHashSet &amp; TreeSet Java并发编程并发与并行 什么是并发 什么是并行 并发与并行的区别 线程 线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程 线程与进程的区别 线程池 自己设计线程池、submit() 和 execute()、线程池原理 为什么不允许使用Executors创建线程池 线程安全 死锁、死锁如何排查、线程安全和内存模型的关系 锁 CAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、 锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁 死锁 死锁的原因 死锁的解决办法 synchronized synchronized是如何实现的？ synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例 synchronized和原子性、可见性和有序性之间的关系 volatile happens-before、内存屏障、编译器指令重排和CPU指令重排 volatile的实现原理 volatile和原子性、可见性和有序性之间的关系 有了symchronized为什么还需要volatile sleep 和 waitwait 和 notifynotify 和 notifyAllThreadLocal写一个死锁的程序写代码来解决生产者消费者问题并发包阅读源代码，并学会使用 Thread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors 二、底层篇JVMJVM内存结构 class文件格式、运行时数据区：堆、栈、方法区、直接内存、运行时常量池、 堆和栈区别 Java中的对象一定在堆上分配吗？ Java内存模型 计算机内存模型、缓存一致性、MESI协议 可见性、原子性、顺序性、happens-before、 内存屏障、synchronized、volatile、final、锁 垃圾回收 GC算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收 GC参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon） JVM参数及调优 -Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、 -XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold Java对象模型 oop-klass、对象头 HotSpot 即时编译器、编译优化 虚拟机性能监控与故障处理工具 jps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler Arthas 类加载机制 classLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw） 编译与反编译 什么是编译（前端编译、后端编译）、什么是反编译 JIT、JIT优化（逃逸分析、栈上分配、标量替换、锁优化） 编译工具：javac 反编译工具：javap 、jad 、CRF 三、 进阶篇Java底层知识字节码、class文件格式CPU缓存，L1，L2，L3和伪共享尾递归位运算 用位运算实现加、减、乘、除、取余 设计模式 设计模式的六大原则： 开闭原则（Open Close Principle）、里氏代换原则（Liskov Substitution Principle）、依赖倒转原则（Dependence Inversion Principle） 接口隔离原则（Interface Segregation Principle）、迪米特法则（最少知道原则）（Demeter Principle）、合成复用原则（Composite Reuse Principle） 了解23种设计模式 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 会使用常用设计模式 单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁 工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会 不用synchronized和lock，实现线程安全的单例模式实现AOP实现IOCnio和reactor设计模式网络编程知识tcp、udp、http、https等常用协议 三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包 http/1.0 http/1.1 http/2之间的区别 http中 get和post区别 常见的web请求返回的状态码 404、302、301、500分别代表什么 http/3Java RMI，Socket，HttpClientcookie 与 session cookie被禁用，如何实现session 用Java写一个简单的静态文件的HTTP服务器了解nginx和apache服务器的特性并搭建一个对应的服务器用Java实现FTP、SMTP协议进程间通讯的方式什么是CDN？如果实现？DNS？ 什么是DNS 、记录类型:A记录、CNAME记录、AAAA记录等 域名解析、根域名服务器 DNS污染、DNS劫持、公共DNS：114 DNS、Google DNS、OpenDNS 反向代理 正向代理、反向代理 反向代理服务器 框架知识Servlet 生命周期 线程安全问题 filter和listener web.xml中常用配置及作用 Hibernate 什么是OR Mapping Hibernate的缓存机制 Hibernate的懒加载 Hibernate/Ibatis/MyBatis之间的区别 Spring Bean的初始化 AOP原理 实现Spring的IOC spring四种依赖注入方式 Spring MVC 什么是MVC Spring mvc与Struts mvc的区别 Spring Boot Spring Boot 2.0、起步依赖、自动配置、 Spring Boot的starter原理，自己实现一个starter Spring SecuritySpring Cloud 服务发现与注册：Eureka、Zookeeper、Consul 负载均衡：Feign、Spring Cloud Loadbalance 服务配置：Spring Cloud Config 服务限流与熔断：Hystrix 服务链路追踪：Dapper 服务网关、安全、消息 应用服务器知识JBosstomcatjettyWeblogic工具git &amp; svnmaven &amp; gradleIntellij IDEA 常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat、aceJump Lombok plugin、.ignore、Mybatis plugin 四、 高级篇新技术Java 8 lambda表达式、Stream API、时间API Java 9 Jigsaw、Jshell、Reactive Streams Java 10 局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制 Java 11 ZGC、Epsilon、增强var、 Spring 5 响应式编程 Spring Boot 2.0http/2http/3性能优化 使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存 线上问题分析dump获取 线程Dump、内存Dump、gc情况 dump分析 分析死锁、分析内存泄露 dump分析及获取工具 jstack、jstat、jmap、jhat、Arthas 自己编写各种outofmemory，stackoverflow程序 HeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow Arthas jvm相关、class/classloader相关、monitor/watch/trace相关、 options、管道、后台异步任务 文档：https://alibaba.github.io/arthas/advanced-use.html 常见问题解决思路 内存溢出、线程死锁、类加载冲突 使用工具尝试解决以下问题，并写下总结 当一个Java程序响应很慢时如何查找问题、 当一个Java程序频繁FullGC时如何解决问题、 如何查看垃圾回收日志、 当一个Java应用发生OutOfMemory时该如何解决、 如何判断是否出现死锁、 如何判断是否存在内存泄露 使用Arthas快速排查Spring Boot应用404/401问题 使用Arthas排查线上应用日志打满问题 利用Arthas排查Spring Boot应用NoSuchMethodError 编译原理知识编译与反编译Java代码的编译与反编译Java的反编译工具 javap 、jad 、CRF 即时编译器词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化操作系统知识Linux的常用命令进程间通信进程同步 生产者消费者问题、哲学家就餐问题、读者写者问题 缓冲区溢出分段和分页虚拟内存与主存虚拟内存管理换页算法数据库知识MySql 执行引擎MySQL 执行计划 如何查看执行计划，如何根据执行计划进行SQL优化 索引 Hash索引、B树索引（B+树、和B树、R树） 普通索引、唯一索引 覆盖索引、最左前缀原则、索引下推 SQL优化数据库事务和隔离级别 事务的隔离级别、事务能不能实现锁的功能 数据库锁 行锁、表锁、使用数据库锁实现乐观锁、 连接 内连接，左连接，右连接 数据库主备搭建binlogredolog内存数据库 h2 分库分表读写分离常用的nosql数据库 redis、memcached 分别使用数据库锁、NoSql实现分布式锁性能调优数据库连接池数据结构与算法知识简单的数据结构 栈、队列、链表、数组、哈希表、 栈和队列的相同和不同之处 栈通常采用的两种存储结构 树 二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树 堆 大根堆、小根堆 图 有向图、无向图、拓扑 排序算法 稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序 不稳定的排序：选择排序、希尔排序、Clover排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序 各种排序算法和时间复杂度 深度优先和广度优先搜索全排列、贪心算法、KMP算法、hash算法海量数据处理 分治，hash映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce等。 两个栈实现队列，和两个队列实现栈大数据知识Zookeeper 基本概念、常见用法 Solr，Lucene，ElasticSearch 在linux上部署solr，solrcloud，，新增、删除、查询索引 Storm，流式计算，了解Spark，S4 在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。 Hadoop，离线计算 HDFS、MapReduce 分布式日志收集flume，kafka，logstash数据挖掘，mahout网络安全知识XSS XSS的防御 CSRF注入攻击 SQL注入、XML注入、CRLF注入 文件上传漏洞加密与解密 对称加密、非对称加密、哈希算法、加盐哈希算法 MD5，SHA1、DES、AES、RSA、DSA 彩虹表 DDOS攻击 DOS攻击、DDOS攻击 memcached为什么可以导致DDos攻击、什么是反射型DDoS 如何通过Hash碰撞进行DOS攻击 SSL、TLS，HTTPS用openssl签一个证书部署到apache或nginx五、架构篇分布式 数据一致性、服务治理、服务降级 分布式事务 2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC Dubbo 服务注册、服务发现，服务治理 http://dubbo.apache.org/zh-cn/ 分布式数据库 怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase 分布式文件系统 mfs、fastdfs 分布式缓存 缓存一致性、缓存命中率、缓存冗余 限流降级 Hystrix、Sentinal 算法 共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法 2PC、3PC 微服务 SOA、康威定律 ServiceMesh sidecar Docker &amp; KubernetsSpring BootSpring Cloud高并发分库分表CDN技术消息队列 ActiveMQ 监控监控什么 CPU、内存、磁盘I/O、网络I/O等 监控手段 进程监控、语义监控、机器资源监控、数据波动 监控数据采集 日志、埋点 Dapper负载均衡 tomcat负载均衡、Nginx负载均衡 四层负载均衡、七层负载均衡 DNS DNS原理、DNS的设计 CDN 数据一致性 六、 扩展篇云计算 IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess 搜索引擎 Solr、Lucene、Nutch、Elasticsearch 权限管理 Shiro 区块链 哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名 比特币 挖矿、共识机制、闪电网络、侧链、热点问题、分叉 以太坊超级账本人工智能 数学基础、机器学习、人工神经网络、深度学习、应用场景。 常用框架 TensorFlow、DeepLearning4J IoT量子计算AR &amp; VR其他语言 Groovy、Python、Go、NodeJs、Swift、Rust 六、 推荐书籍 《深入理解Java虚拟机》 《Effective Java》 《深入分析Java Web技术内幕》 《大型网站技术架构》 《代码整洁之道》 《架构整洁之道》 《Head First设计模式》 《maven实战》 《区块链原理、设计与应用》 《Java并发编程实战》 《鸟哥的Linux私房菜》 《从Paxos到Zookeeper》 《架构即未来》]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2017%2F04%2F15%2F2017-04-15-spring-introduction%2F</url>
    <content type="text"><![CDATA[Why为什么要使用Spring？ Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法： DI（Dependency Injection，依赖注入） AOP（Aspect Oriented Programming，面向切面编程） Java Bean每一个类实现了Bean的规范才可以由Spring来接管，那么Bean的规范是什么呢？ 必须是个公有(public)类 有无参构造函数 用公共方法暴露内部成员属性(getter,setter) 实现这样规范的类，被称为Java Bean。即是一种可重用的组件。 DI-依赖注入简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。 AOP-面向切面编程就以日志系统为例。在执行某个操作前后都需要输出日志，如果手工加代码，那简直太可怕了。而且等代码庞大起来，也是非常难维护的一种情况。这里就需要面向切面来编程 How关于BeanBean的生命周期如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。我们对图进行详细描述： Spring对bean进行实例化； Spring将值和bean的引用注入到bean对应的属性中； 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法； 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入； 如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来； 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法； 如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用； 如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法； 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁； 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。 Bean的作用域Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括： 单例（Singleton）：在整个应用中，只创建bean的一个实例。 原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。 会话（Session）：在Web应用中，为每个会话创建一个bean实例。 请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。 在代码里看起来是这样的：12@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class MyIsBean&#123;...&#125; XML版本：1234&lt;bean id="BEANID" class = "net.itxm.beans" scope="prototype"&gt; 在默认情况下，Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。 在大多数情况下，单例bean是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。 有时候，可能会发现，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被污染，稍后重用的时候会出现意想不到的问题。 声明Bean以下是声明Bean的注解： @Component 组件，没有明确的角色 @Service 在业务逻辑层使用 @Repository 在数据访问层使用 @Controller 在展现层使用(MVC -&gt; Spring MVC)使用 在这里，可以指定bean的id名：Component(“yourBeanName”) 同时，Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。 关于依赖注入注入Bean的注解@Autowired Spring提供的注解 不仅仅是对象，还有在构造器上，还能用在属性的Setter方法上。 不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。 如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false。 将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。 @Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。 @Autowired 是最常见的注解之一，但在老项目中，你可能会看到这些注解，它们的作用和@Autowired 相近： @Inject 是JSR-330提供的注解@Resource 是JSR-250提供的注解 条件化的Bean假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。 在Spring 4之前，很难实现这种级别的条件化配置，但是Spring 4引入了一个新的@Conditional注解，它可以用到带有@Bean注解的方法上。如果给定的条件计算结果为true，就会创建这个bean，否则的话，这个bean会被忽略。 通过ConditionContext，我们可以做到如下几点： 借助getRegistry()返回的BeanDefinitionRegistry检查bean定义； 借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性； 借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么； 读取并探查getResourceLoader()返回的ResourceLoader所加载的资源； 借助getClassLoader()返回的ClassLoader加载并检查类是否存在。 处理自动装配的歧义性标示首选的bean 在声明bean的时候，通过将其中一个可选的bean设置为首选（primary）bean能够避免自动装配时的歧义性。当遇到歧义性的时候，Spring将会使用首选的bean，而不是其他可选的bean。实际上，你所声明就是“最喜欢”的bean。 限定自动装配的bean 设置首选bean的局限性在于@Primary无法将可选方案的范围限定到唯一一个无歧义性的选项中。它只能标示一个优先的可选方案。当首选bean的数量超过一个时，我们并没有其他的方法进一步缩小可选范围。 与之相反，Spring的限定符能够在所有可选的bean上进行缩小范围的操作，最终能够达到只有一个bean满足所规定的限制条件。如果将所有的限定符都用上后依然存在歧义性，那么你可以继续使用更多的限定符来缩小选择范围。 @Qualifier注解是使用限定符的主要方式。它可以与@Autowired和@Inject协同使用，在注入的时候指定想要注入进去的是哪个bean。例如，我们想要确保要将IceCream注入到setDessert()之中： 12345@Autowired@Qualifier("iceCream")public void setDessert(Dessert dessert)&#123; this.dessert = dessert;&#125; 这是使用限定符的最简单的例子。为@Qualifier注解所设置的参数就是想要注入的bean的ID。所有使用@Component注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。因此，@Qualifier(“iceCream”)指向的是组件扫描时所创建的bean，并且这个bean是IceCream类的实例。 实际上，还有一点需要补充一下。更准确地讲，@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。如果没有指定其他的限定符的话，所有的bean都会给定一个默认的限定符，这个限定符与bean的ID相同。因此，框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean，它是IceCream类在组件扫描的时候创建的。 基于默认的bean ID作为限定符是非常简单的，但这有可能会引入一些问题。如果你重构了IceCream类，将其重命名为Gelato的话，那此时会发生什么情况呢？如果这样的话，bean的ID和默认的限定符会变为gelato，这就无法匹配setDessert()方法中的限定符。自动装配会失败。 这里的问题在于setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会导致限定符失效。 SpringEL Value实现资源的注入 Bean的初始化和销毁 Java配置方式：initMethod和destoryMethod 注解：@PostConstruct和@PreDestory Profile提供在不同的环境下使用不同的配置 激活Profile Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring.profiles.active和spring.profiles.default。如果设置了spring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但如果没有设置spring.profiles.active属性的话，那Spring将会查找spring.profiles.default的值。如果spring.profiles.active和spring.profiles.default均没有设置的话，那就没有激活的profile，因此只会创建那些没有定义在profile中的bean。 使用profile进行测试 当运行集成测试时，通常会希望采用与生产环境（或者是生产环境的部分子集）相同的配置进行测试。但是，如果配置中的bean定义在了profile中，那么在运行测试时，我们就需要有一种方式来启用合适的profile。 Spring提供了@ActiveProfiles注解，我们可以使用它来指定运行测试时要激活哪个profile。在集成测试时，通常想要激活的是开发环境的profile。 比如Profile(“dev”) Application Event使用Application Event可以做到Bean与Bean之间的通信 Spring的事件需要遵循如下流程： 自定义事件，集成ApplicationEvent 定义事件监听器，实现ApplicationListener 使用容器发布事件 关于AOP名词介绍通知（Advice） 通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？ Spring切面可以应用5种类型的通知： 前置通知（Before）：在目标方法被调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功执行之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。 对应注解： 注解 通知 @After 通知方法会在目标方法返回或抛出异常后调用 —- @AfterReturning 通知方法会在目标方法返回后调用 —- @AfterThrowing 通知方法会在目标方法抛出异常后调用 —- @Around 通知方法会将目标方法封装起来 —- @Before 通知方法会在目标方法调用之前执行 —- 连接点（Join point） 连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。 切点（Pointcut） 如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处” 。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。 切面（Aspect） 通知+切点=切面 引入（Introduction） 引入允许我们向现有的类添加新方法或属性 织入（Weaving） 织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入： 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。 Spring对AOP的支持： 基于代理的经典Spring AOP； 纯POJO切面（4.x版本需要XML配置）； @AspectJ注解驱动的切面； 注入式AspectJ切面（适用于Spring各版本）。 例子 123public interface Performance()&#123; public void perform();&#125; 现在来写一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。 123456execution(* concert.Performance.perform(..))//execution：在方法执行时触发//*：返回任意类型//concert.Performance：方法所属类//perform：方法名//(..)：使用任意参数 不仅如此，还可以写的更复杂一点 12execution(* concert.Performance.perform(..)&amp;&amp;within(concert.*))//增加了一个与操作，当concert包下的任意类方法被调用时也会触发 在切点中选择bean 12execution(*concert.Performance.perform()) and bean('woodstock')//限定bean id为woodstock 来个完整的切面 12345678910111213141516171819@Aspectpublic class Audience&#123; @Before("execution(**concert.Performance.perform(..))") public void silenceCellPhones()&#123; System.out.println("Silencing cell phones"); &#125; @Before("execution&#123;** concert.Performance.perform&#123;..&#125;&#125;") public void taskSeats()&#123; System.out.println("Talking seats"); &#125; @AfterReturning("execution&#123;** concert.Performance.perform&#123;..&#125;&#125;") public void applause()&#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("execution&#123;** concert.Performance.perform&#123;..&#125;&#125;") public void demanRefund()&#123; System.out.println("Demanding a refund"); &#125;&#125; 可以简化一下 1234567891011121314151617181920212223@Aspectpublic class Audience&#123; //避免频繁使用切点表达式 @Pointcut("execution(** concert.Performance.perform(..))") public void performance()&#123;&#125; @Before("performance()") public void silenceCellPhones()&#123; System.out.println("Silencing cell phones"); &#125; @Before("performance()") public void taskSeats()&#123; System.out.println("Talking seats"); &#125; @AfterReturning("performance()") public void applause()&#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; @AfterThrowing("performance()") public void demanRefund()&#123; System.out.println("Demanding a refund"); &#125;&#125; XML中声明切面 AOP配置元素 用途 &lt;aop:advisor&gt; 定义AOP通知器 —- &lt;aop:after&gt; 定义AOP后置通知（不管被通知的方法是否执行成功） —- &lt;aop:after-returning&gt; 定义AOP返回通知 —- &lt;aop:after-throwing&gt; 定义AOP异常通知 —- &lt;aop:around&gt; 定义AOP环绕通知 —- &lt;aop:aspect&gt; 定义一个切面 —- &lt;aop:aspectj-autoproxy&gt; 启用@AspectJ注解驱动的切面 —- &lt;aop:before&gt; 定义一个AOP前置通知 —- &lt;aop:config&gt; 顶层的AOP配置元素。大多数的aop:*元素必须包含在aop:config元素内 —- &lt;aop:declare-parents&gt; 以透明的方式为被通知的对象引入额外的接口 —- &lt;aop:pointcut&gt; 定义一个切点 —- 来个栗子 1234567891011121314public class Audience&#123; public void silenceCellPhones()&#123; System.out.println("Silencing cell phones"); &#125; public void taskSeats()&#123; System.out.println("Talking seats"); &#125; public void applause()&#123; System.out.println("CLAP CLAP CLAP!!!"); &#125; public void demandRefund()&#123; System.out.println("Demanding a refund"); &#125;&#125; 通过XML将无注解的Audience声明为切面 12345678910111213141516&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:before pointcut ="execution(** concert.Performance.perform(..))" method="sillenceCellPhones"/&gt; &lt;aop:before pointcut ="execution(** concert.Performance.perform(..))" method="taskSeats"/&gt; &lt;aop:after-returning pointcut ="execution(** concert.Performance.perform(..))" method="applause"/&gt; &lt;aop:After-throwing pointcut ="execution(** concert.Performance.perform(..))" method="demanRefund"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; AspectJ关于Spring AOP的AspectJ切点，最重要的一点就是Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。让我们回顾下，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。下表列出了Spring AOP所支持的AspectJ切点指示器。 Spring借助AspectJ的切点表达式语言来定义Spring切面 AspectJ指示器 描述 arg() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数由指定注解标注的执行方法 execution() 用于匹配是连接点的执行方法 this() 限制连接点匹配AOP代理的bean引用为指定类型的类 target 限制连接点匹配目标对象为指定类型的类 @target() 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 within() 限制连接点匹配指定的类型 @within() 限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里） @annotation 限定匹配带有指定注解的连接点 Spring高级特性由于Spring特殊的依赖注入技巧，导致Bean之间没有耦合度。 但是Bean有时需要使用spring容器本身的资源，这时你的Bean必须意识到Spring容器的存在。所以得使用Spring Aware，下面来看看Spring Aware提供的接口 BeanNameAware 获得到容器中Bean的名称 BeanFactory 获得当前的bean factory，这样可以调用容器的服务 ApplicationContextAware* 当前application context，这样可以调用容器的服务 MessageSourceAware 获得Message source ApplicationEventPublisherAware 应用时间发布器，可以发布时间， ResourceLoaderAware 获得资源加载器，可以获得外部资源文件 @TaskExecutor这样可以实现多线程和并发编程。通过@EnableAsync开启对异步任务的支持，并通过实际执行的Bean的方法始中使用@Async注解来声明其是一个异步任务 @Scheduled 计划任务首先通过在配置类注解@EnableScheduling来开启对计划任务的支持，然后在要执行计划任务的方法上注解@Scheduled，声明这是一个计划任务 @Conditional根据满足某一个特定条件创建一个特定的Bean。 组合注解与元注解元注解就是可以注解到别的注解上的注解，被注解的注解称之为组合注解，组合注解具备注解其上的元注解的功能。 @Enable*注解的工作原理 通过观察这些@Enable*注解的源码，我们发现所有的注解都有一个@Import注解，@Import是用来导入配置类的，这也就意外着这些自动开启的实现其实是导入了一些自动配置的Bean。这些导入配置的方式主要范围以下三种类型： 第一类：直接导入配置类 第二类：依据条件选择配置类 第三类：动态注册Bean What简单的分析一下Spring。 Spring 框架中的核心组件只有三个：Core、Context 和 Bean。它们构建起了整个 Spring 的骨骼架构。没有它们就不可能有 AOP、Web 等上层的特性功能。下面也将主要从这三个组件入手分析 Spring。 Spring的设计理念用过Spring的同学都知道Bean在Spring的作用是非常重要的。通过一系列简单的配置来满足类与类之间的依赖关系——这叫做依赖注入。而依赖注入的关系是在一个叫IOC的容器中进行管理。 核心组件我们说到Spring 框架中的核心组件只有三个：Core、Context 和 Bean。那么Core和Context是如何协作的呢？ 我们知道 Bean 包装的是 Object，而 Object 必然有数据，如何给这些数据提供生存环境就是 Context 要解决的问题，对 Context 来说他就是要发现每个 Bean 之间的关系，为它们建立这种关系并且要维护好这种关系。所以 Context 就是一个 Bean 关系的集合，这个关系集合又叫 Ioc 容器 ，一旦建立起这个 Ioc 容器后 Spring 就可以为你工作了。那 Core 组件又有什么用武之地呢？其实 Core 就是发现、建立和维护每个 Bean 之间的关系所需要的一些列的工具。 Bean前面已经说明了 Bean 组件对 Spring 的重要性，下面看看 Bean 这个组件式怎么设计的。Bean 组件在 Spring 的 org.springframework.beans 包下。这个包下的所有类主要解决了三件事：Bean 的定义、Bean 的创建以及对 Bean 的解析。对 Spring 的使用者来说唯一需要关心的就是 Bean 的创建，其他两个由 Spring 在内部帮你完成了，对你来说是透明的。 ContextApplicationContext 是 Context 的顶级父类，他除了能标识一个应用环境的基本信息外，他还继承了五个接口，这五个接口主要是扩展了 Context 的功能。 ApplicationContext 的子类主要包含两个方面： ConfigurableApplicationContext 表示该 Context 是可修改的，也就是在构建 Context 中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最经常使用的是可更新的 Context，即 AbstractRefreshableApplicationContext类。 WebApplicationContext 顾名思义，就是为 web 准备的 Context 他可以直接访问到 ServletContext，通常情况下，这个接口使用的少。 再往下分就是按照构建 Context 的文件类型，接着就是访问 Context 的方式。这样一级一级构成了完整的 Context 等级层次。 总体来说 ApplicationContext 必须要完成以下几件事： 标识一个应用环境 利用 BeanFactory 创建 Bean 对象 保存对象关系表 能够捕获各种事件 Context 作为 Spring 的 IOC 容器，基本上整合了 Spring 的大部分功能，或者说是大部分功能的基础。 CoreCore 组件作为 Spring 的核心组件，他其中包含了很多的关键类，其中一个重要组成部分就是定义了资源的访问方式。这种把所有资源都抽象成一个接口的方式很值得在以后的设计中拿来学习。]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2017%2F04%2F08%2F2017-04-08-mybatis-introduction%2F</url>
    <content type="text"><![CDATA[MyBatis使用JDBC编程问题总结1.JDBC编程步骤 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语句中的参数(使用preparedStatement) 通过statement执行sql并获取结果 对sql执行结果进行解析处理 释放资源(resultSet、preparedstatement、connection) 2.JDBC问题总结 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。 Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 1. MyBatis介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。MyBatis架构 2. MyBatis配置 mybatis配置SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 从 XML 中构建 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。123String resource = "org/mybatis/example/mybatis-config.xml";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。这里先给出一个简单的示例：1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。 3. Mapper XML 文件MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 select查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，如果还能重新取出来才有用，多数应用也都是查询比修改要频繁。对每个插入、更新或删除操作，通常对应多个查询操作。这是 MyBatis 的基本原则之一，也是将焦点和努力放到查询和结果映射的原因。简单查询的 select 元素是非常简单的。比如： &lt;select id=&quot;selectPerson&quot; parameterType=&quot;int&quot; resultType=&quot;hashmap&quot;&gt; SELECT * FROM PERSON WHERE ID = #{id} &lt;/select&gt; 这个语句被称作 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号： #{id}这就告诉 MyBatis 创建一个预处理语句参数，通过 JDBC，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：1234// Similar JDBC code, NOT MyBatis…String selectPerson = "SELECT * FROM PERSON WHERE ID=?";PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); 下面就是 insert，update 和 delete 语句的示例： &lt;insert id=&quot;insertAuthor&quot;&gt; insert into Author (id,username,password,email,bio) values (#{id},#{username},#{password},#{email},#{bio}) &lt;/insert&gt; &lt;update id=&quot;updateAuthor&quot;&gt; update Author set username = #{username}, password = #{password}, email = #{email}, bio = #{bio} where id = #{id} &lt;/update&gt; &lt;delete id=&quot;deleteAuthor&quot;&gt; delete from Author where id = #{id} &lt;/delete&gt; 如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，而且有多种生成方式。 首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就OK了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为: &lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into Author (username,password,email,bio) values (#{username},#{password},#{email},#{bio}) &lt;/insert&gt; 如果你的数据库还支持多行插入, 你也可以传入一个Authors数组或集合，并返回自动生成的主键。 &lt;insert id=&quot;insertAuthor&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into Author (username, password, email, bio) values &lt;foreach item=&quot;item&quot; collection=&quot;list&quot; separator=&quot;,&quot;&gt; (#{item.username}, #{item.password}, #{item.email}, #{item.bio}) &lt;/foreach&gt; &lt;/insert&gt; 动态 SQLMyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 if choose (when, otherwise) trim (where, set) foreachif 动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如： &lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;/select&gt; 这条语句提供了一种可选的查找文本功能。如果没有传入“title”，那么所有处于“ACTIVE”状态的BLOG都会返回；反之若传入了“title”，那么就会对“title”一列进行模糊查找并返回 BLOG 结果（细心的读者可能会发现，“title”参数值是可以包含一些掩码或通配符的）。 如果希望通过“title”和“author”两个参数进行可选搜索该怎么办呢？首先，改变语句的名称让它更具实际意义；然后只要加入另一个条件即可。 &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/select&gt; choose, when, otherwise 有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 还是上面的例子，但是这次变为提供了“title”就按“title”查找，提供了“author”就按“author”查找的情形，若两者都没有提供，就返回所有符合条件的 BLOG（实际情况可能是由管理员按一定策略选出 BLOG 列表，而不是返回大量无意义的随机结果）。 &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; trim, where, set 前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到“if”示例，这次我们将“ACTIVE = 1”也设置成动态的条件，看看会发生什么。 &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE &lt;if test=&quot;state != null&quot;&gt; state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/select&gt; 如果这些条件没有一个能匹配上会发生什么？最终这条 SQL 会变成这样： SELECT * FROM BLOG WHERE 这会导致查询失败。如果仅仅第二个条件匹配又会怎样？这条 SQL 最终会是这样: SELECT * FROM BLOG WHERE AND title like ‘someTitle’ 这个查询也会失败。这个问题不能简单地用条件句式来解决，如果你也曾经被迫这样写过，那么你很可能从此以后都不会再写出这种语句了。 MyBatis 有一个简单的处理，这在 90% 的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能达到目的： &lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #{state} &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #{title} &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #{author.name} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。 如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为： &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ... &lt;/trim&gt; prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它的作用是移除所有指定在 prefixOverrides 属性中的内容，并且插入 prefix 属性中指定的内容。 类似的用于动态更新语句的解决方案叫做 set。set 元素可以用于动态包含需要更新的列，而舍去其它的。比如： &lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt; 这里，set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号，因为用了条件语句之后很可能就会在生成的 SQL 语句的后面留下这些逗号。（译者注：因为用的是“if”元素，若最后一个“if”没有匹配上而前面的匹配上，SQL 语句的最后就会有一个逗号遗留） 若你对 set 元素等价的自定义 trim 元素的代码感兴趣，那这就是它的真面目： &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ... &lt;/trim&gt; 注意这里我们删去的是后缀值，同时添加了前缀值。 foreach 动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如： &lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{item} &lt;/foreach&gt; &lt;/select&gt; foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。 注意 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。 到此我们已经完成了涉及 XML 配置文件和 XML 映射文件的讨论。下一章将详细探讨 Java API，这样就能提高已创建的映射文件的利用效率。 bind bind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如： &lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + _parameter.getTitle() + &apos;%&apos;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #{pattern} &lt;/select&gt; 4. 小结(1) #{}和${}#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 (2) parameterType和resultTypeparameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中 (3) selectOne和selectListselectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常。 selectList可以查询一条或多条记录。]]></content>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EL表达式]]></title>
    <url>%2F2017%2F04%2F05%2F2017-04-05-el%2F</url>
    <content type="text"><![CDATA[EL表达式1．EL 表达式概述EL（Express Lanuage）表达式可以嵌入在jsp页面内部，减少jsp脚本的编写，EL出现的目的是要替代jsp页面中脚本的编写。 2．EL从域中取出数据EL最主要的作用是获得四大域中的数据，格式${EL表达式}EL获得pageContext域中的值：$(pageContextScope.key);EL获得request域中的值：$(request.key);EL获得session域中的值：$(session.key);EL获得application域中的值：$(application.key);EL从四个域中获得某个值$(key);—同样是依次从pageContext域，request域，session域，application域中 获取属性，在某个域中获取后将不在向后寻找 3．EL的内置对象pageScoperequestScopesessionScopeapplicationScope 获取JSP中域中的数据 param,paramValues 接收参数 —- header,headerValues 获取请求头信息 —- initParam 获取全局初始化参数 —- cookie WEB开发中cookie —- pageContext WEB开发中的pageContext —- $(pageContext.request.contextPath)相当于&lt;%=pageContext.getRequest().getContextPath%&gt;]]></content>
      <tags>
        <tag>java</tag>
        <tag>el</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2017%2F04%2F01%2F2017-04-01-jsp%2F</url>
    <content type="text"><![CDATA[JSPJSP语法1．jsp脚本和注释jsp脚本：(1)&lt;%java代码%&gt; —– 内部的java代码翻译到service方法的内部(2)&lt;%=java变量或表达式&gt; —– 会被翻译成service方法内部out.print()(3)&lt;%!java代码%&gt; —- 会被翻译成servlet的成员的内容jsp注释： 不同的注释可见范围是不同(1)Html注释： —可见范围 jsp源码、翻译后的servlet、页面显示html源码(2)java注释：//单行注释 /多行注释/ –可见范围 jsp源码 翻译后的servlet(3)jsp注释：&lt;%–注释内容–%&gt; —– 可见范围 jsp源码可见 2．jsp运行原理—–jsp本质就是servletjsp在第一次被访问时会被Web容器翻译成servlet，在执行过程：PS：被翻译后的servlet在Tomcat的work目录中可以找到 3．jsp指令jsp的指令是指导jsp翻译和运行的命令，jsp包括三大指令：(1)page指令 — 属性最多的指令（实际开发中page指令默认）属性最多的一个指令，根据不同的属性，指导整个页面特性格式：&lt;%@ page 属性名1= “属性值1” 属性名2= “属性值2” …%&gt;常用属性如下：language：jsp脚本中可以嵌入的语言种类pageEncoding：当前jsp文件的本身编码—内部可以包含contentTypecontentType：response.setContentType(text/html;charset=UTF-8)session：是否jsp在翻译时自动创建sessionimport：导入java的包errorPage：当当前页面出错后跳转到哪个页面isErrorPage：当前页面是一个处理错误的页面 (2)include指令页面包含（静态包含）指令，可以将一个jsp页面包含到另一个jsp页面中格式：&lt;%@ include file=”被包含的文件地址”%&gt; (3)taglib指令在jsp页面中引入标签库（jstl标签库、struts2标签库）格式：&lt;%@ taglib uri=”标签库地址” prefix=”前缀”%&gt; 4．jsp内置对象（9个）jsp被翻译成servlet之后，service方法中有9个对象定义并初始化完毕，我们在jsp 脚本中可以直接使用这9个对象 名称 类型 描述 out javax.servlet.jsp.JspWriter 用于页面输出 —- request javax.servlet.http.HttpServletRequest 得到用户请求信息 —- response javax.servlet.http.HttpServletResponse 服务器向客户端的回应信息 —- config javax.servlet.ServletConfig 服务器配置，可以取得初始化参数 —- session javax.servlet.http.HttpSession 用来保存用户的信息 —- application javax.servlet.ServletContext 所有用户的共享信息 —- page java.lang.Object 指当前页面转换后的Servlet类的实例 —- pageContext javax.servlet.jsp.PageContext JSP的页面容器 —- exception java.lang.Throwable 表示JSP页面所发生的异常，在错误页中才起作用 —- (1)out对象out的类型：JspWriterout作用就是想客户端输出内容—-out.write()out缓冲区默认8kb 可以设置成0 代表关闭out缓冲区 内容直接写到respons缓冲 器 (2)pageContext对象jsp页面的上下文对象，作用如下：page对象与pageContext对象不是一回事1.pageContext是一个域对象setAttribute(String name,Object obj)getAttribute(String name)removeAttrbute(String name) 2.pageContext可以向指定的其他域中存取数据setAttribute(String name,Object obj,int scope)getAttribute(String name,int scope)removeAttrbute(String name,int scope)findAttribute(String name)—依次从pageContext域，request域，session域，application域中获取属性，在某个域中获取后将不在向后寻找 3.可以获得其他8大隐式对象例如： pageContext.getRequest()pageContext.getSession() 四大作用域：page域：当前jsp页面范围request域：一次请求session域：一次会话application域：整个web应用 5．jsp标签（动作）(1)页面包含(动态包含)：&lt;jsp :include page=&quot;a.jsp&quot;/&gt; (2)请求转发：&lt;jsp:forward page=&quot;要转发的资源&quot; /&gt; 动态包含与静态包含的区别：1.静态包含: &lt;%@include file=&quot;fileurl&quot;%&gt;2.动态包含: &lt;jsp :include page=&quot;a.jsp&quot;/&gt;(1)静态包含发生在：JSP—-&gt;java文件阶段。动态包含发生在：执行class文件阶段,动态加入。(2)静态包含：只生成一个java文件，动态包含：生成多个class文件。(3)静态包含不会检查所包含文件中的变化；但是动态包含，每次检查所含文件中的变化，并且可以带参数 请求转发与请求重定向的区别：1.请求转发：request.getRequestDispatcher().forward(req,resp)服务器行为，request.getRequestDispatcher().forward(req,resp);是一次请求，转发后请求对象会保存，地址栏的URL地址不会改变。2.请求重定向：response.sendRedirect()客户端行为，response.sendRedirect(),从本质上讲等同于两次请求，前一次的请求对象不会保存，地址栏的URL地址会改变。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session]]></title>
    <url>%2F2017%2F03%2F25%2F2017-03-25-session%2F</url>
    <content type="text"><![CDATA[SessionSession技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间存储客户的数据，但客户端需要每次都携带一个标识ID去服务器中寻找属于自己的内存空间。所以说Session的实现是基于Cookie，Session需要借助于Cookie存储客户的唯一性标识JSESSIONID Session的使用1．获得Session对象1HttpSession session = request.getSession(); 此方法会获得专属于当前会话的Session对象，如果服务器端没有该会话的Session对象会创建一个新的Session返回，如果已经有了属于该会话的Session直接将已有的Session返回（实质就是根据JSESSIONID判断该客户端是否在服务器上已经存在 session了） 2．向session中存取数据（session也是一个域对象）Session也是存储数据的区域对象，所以session对象也具有如下三个方法：123session.setAttribute(String name,Object obj);session.getAttribute(String name);session.removeAttribute(String name); 3．Session对象的生命周期创建：第一次执行request.getSession()时创建销毁：1.服务器(非正常)关闭时2.session过期/失效（默认30分钟,从不操作服务器端的资源开始计时）,可以在工程的web.xml中进行配置123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 3.手动销毁session1session.invalidate();]]></content>
      <tags>
        <tag>java</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie]]></title>
    <url>%2F2017%2F03%2F22%2F2017-03-22-cookie%2F</url>
    <content type="text"><![CDATA[CookieCookie技术是将用户的数据存储到客户端本地的技术优点：数据存储在客户端本地，减少服务器端的存储的压力缺点：安全性存在问题 Cookie的使用1．服务器端向客户端发送一个Cookie(1)创建Cookie：1Cookie cookie = new Cookie(String cookieName,String cookieValue); cookie会以响应头的形式发送给客户端注意：Cookie中不能存储中文(2)设置Cookie在客户端的持久化时间：1cookie.setMaxAge(int seconds); 注意：如果不设置持久化时间，cookie会存储在浏览器的内存中，浏览器关闭cookie信息销毁（会话级别的cookie），如果设置持久化时间，cookie信息会被持久化到浏览器的磁盘文件里cookie.setMaxAge(10*60);设置cookie信息在浏览器的磁盘文件中存储的时间是10分钟，过期浏览器会自动删除该cookie信息 (3)设置Cookie的路径：1cookie.setPath(String path); 注意：如果不设置携带路径，那么该cookie信息会在访问产生该cookie的web资源所在的路径都携带cookie信息示例： 123cookie.setPath("/WEB16"); // 代表访问WEB16应用中的任何资源都携带cookiecookie.setPath("/WEB16/cookieServlet"); // 代表访问WEB16中的cookieServlet时才携带cookie信息 (4)向客户端发送cookie： 1response.addCookie(Cookie cookie); (5)删除客户端的cookie：如果想删除客户端的已经存储的cookie信息，那么就使用同名同路径的持久化时间为0的cookie进行覆盖即可 12Cookie cookie = new Cookie("key", null);cookie.setMaxAge(0); 2．服务器端接受客户端携带的Cookiecookie信息是以请求头的方式发送到服务器端的(1)通过request获得所有的Cookie：1Cookie[] cookies = request.getCookies(); (2)遍历Cookie数组，通过Cookie的名称获得我们想要的Cookie12345for(Cookie cookie : cookies)&#123; if(cookie.getName().equal(cookieName))&#123; String cookieValue = cookie.getValue(); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2017%2F03%2F16%2F2017-03-16-jdbc%2F</url>
    <content type="text"><![CDATA[JDBC技术1.简介JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准方法。简单地说，JDBC 可做三件事：与数据库建立连接、发送 操作数据库的语句并处理结果。 2.执行过程第一步：Class.forName()加载数据库连接驱动；第二步：DriverManager.getConnection()获取数据连接对象;第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX();第五步：关闭结果集、关闭会话、关闭连接。下列代码段给出了JDBC执行过程的基本示例：123456789Class.forName("com.mysql.jdbc.Driver");Connection con = DriverManager.getConnection("jdbc:odbc:wombat","login","password");Statement stmt = con.createStatement();ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");while (rs.next()) &#123; int x = rs.getInt("a"); String s = rs.getString("b"); float f = rs.getFloat("c");&#125; 3.相关知识点PreparedStatement的优点1、PreparedStatement 接口继承 Statement，PreparedStatement 实例包含已编译的 SQL 语句，所以其执行速度要快于 Statement 对象。2、作为Statement的子类，PreparedStatement继承了Statement的所有功能。三种方法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数。3、在 JDBC 应用中,在任何时候都不要使用 Statement，原因如下：一、代码的可读性和可维护性.Statement 需要不断地拼接，而 PreparedStatement 不会。二、PreparedStatement 尽最大可能提高性能.DB 有缓存机制，相同的预编译语句再次被调用不会再次需要编译。三、最重要的一点是极大地提高了安全性.Statement 容易被 SQL 注入，而 reparedStatementc 传入的内容不会和 sql 语句发生任何匹配关系。 关系型数据库中连接池的机制前提：为数据库连接建立一个缓冲池。1：从连接池获取或创建可用连接2：使用完毕之后，把连接返回给连接池3：在系统关闭前，断开所有连接并释放连接占用的系统资源4：能够处理无效连接，限制连接池中的连接总数不低于或者不超过某个限定值。 事物处理Connection类中提供了3个事务处理方法: setAutoCommit(Boolean autoCommit):设置是否自动提交事务,默认为自动提交,即为true,通过设置false禁止自动提交事务; commit():提交事务; rollback():回滚事务]]></content>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ContentProvider]]></title>
    <url>%2F2017%2F03%2F12%2F2017-03-12-android-contentprovider%2F</url>
    <content type="text"><![CDATA[1 ContentProviderContentProvider在android中的作用是可以通过ContentProvider把应用中的数据共享给其他应用访问，其他应用可以通过ContentProvider对应用中的数据进行增、删、改、查。使用ContentProvider对外共享数据的好处是，统一了数据的访问方式，它实际上是对SQLiteOpenHelper的进一步封装，通过Uri映射来判断选择需要曹组哦数据库中的哪个表，并且进行增、删、改、查处理。]]></content>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
        <tag>ContentProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Broadcast]]></title>
    <url>%2F2017%2F02%2F26%2F2017-02-26-android-broadcast%2F</url>
    <content type="text"><![CDATA[1 Broadcast(广播)Broadcast是一种广泛运用的、在应用程序之间传输信息的机制，一个广播可以有任意个接收者。广播机制是一个典型的发布——订阅模式，最大的特点就是发送方不关心接收方是否接到数据，也不关心是如何处理数据的，通过这样的形式来达到接、收双方的完全解耦合。 Android中的广播使用了设计模式中的观察者模式：基于消息的发布 / 订阅事件模型 Android广播机制包含3个基本要素，分别是用于发送广播的Broadcast、接收广播的BroadcastReceiver以及用于传递信息的Intent。Android广播可分为普通广播、有序广播、本地广播和Sticky。 1.1 普通广播 普通广播是完全异步的，通过Context的sendBroadcast()函数发送，优点：消息传递的效率比较高。缺点：receivers(接收器)的执行顺序不确定，接收者不能讲处理结果传递给下一个接收者，并且无法终止广播Intent的传播，直到没有与之匹配的广播接收器为止。1、首先定义一个广播接收器，如下：123456public class HelloBroadcastReceiver extends BroadcaseReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "hello", Toast.LENGTH_LONG).show(); &#125;&#125; 2、注册广播，可以通过AndroidManifest.xml静态注册或者代码动态注册。 AndroidManifest.xml静态注册：&lt;receiver android:name=&quot;.broadcast.HelloBroadcastReceiver&quot;&gt;&lt;/receiver&gt; 代码动态注册：123private void registerHelloBroadcast() &#123; registerReceiver(new HelloBroadcastReceiver(), new IntentFilter(HELLO_ACTION));&#125; 如果是在Activity或者Fragment中动态测试，那么不要忘了在执行onDestory时注销该广播。 3、发送广播123private void sendNormalBroadcast() &#123; sendBroadcast(new Intent(HELLO_ACTION));&#125; 然后就会调用HelloBroadcastReceiver的onReceive函数，在该函数中执行相关操作即可。 1.2 有序广播有序广播通过Context.sendOrderedBroadcast()来发送，所有的广播接收器按照优先级依次执行，广播接收器的优先级通过AndroidManifest.xml中的receiver的intent-filter中的android:priority属性来设置，数值越大优先级越高。当广播接收器接收到广播后，可以使用setResult()函数来将结果传给下一个广播接收器接收，然后通过getResult()函数来取得上个广播接收器返回的结果，并可以用abortBroadcast()函数来让系统丢弃该广播，使该广播不再传送到别的广播接收器。 1.3 本地广播之前的广播都是全局的，所有应用程序都可以接收到，这样就会带来安全隐患。LocalBroadcastManager能够实现限于应用内的广播，只是进程内使用，提高程序的安全性。 1.4 sticky广播sticky广播通过Context.sendStickyBroadcast()函数来发送，用此函数发送的广播会一直滞留，当有匹配此广播的广播接收器被注册后，该广播接收器就会收到此条广播。使用此函数发送广播时，需要获得BROADCAST_STICKY权限： &lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot; /&gt; sendStickyBroadcast只保留最后一条广播，并且一直保留下去，这样即使已经有广播接收器处理了该广播，当再有匹配的广播接收器被注册时，此广播仍会被接收。如果你只想处理一遍该广播，可以通过removeStickyBroadcast函数实现。]]></content>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
        <tag>Broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service]]></title>
    <url>%2F2017%2F02%2F12%2F2017-02-12-android-service%2F</url>
    <content type="text"><![CDATA[1 Service与AIDLService是Android中实现程序后台运行的解决方案，适合用于那些不需要和用户交互而且还要求长期运行的任务。但不要被“后台”二字所迷惑，Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作。 Service的运行不依赖于任何用户界面，即使程序被切换到后台或者用户打开了另一个应用程序，Service仍然能够保持正常运行，这也正是Service的使用场景。当某个应用程序进程被杀掉时，所有依赖于该进程的Service也会停止运行。 1.1 普通ServiceService的生命周期只有三个，分别为onCreate、onStartCommand和onDestory。一旦在项目的任何位置调用了Context的startService()函数，相应的服务就会启动起来，首次创建时会调用onCreate函数，然后回调onStartCommand()函数。服务启动之后会一直保持运行状态，直到stopService()或stopSelf()函数被调用。虽然每调用一次startService()函数，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService()函数，只需调用一个stopService()或stopSelf()函数，服务就会被停止。 与Activity一样，Service也需要在AndroidManifest.xml中进行注册。 1.2 IntentServiceIntentService将用户的请求执行在一个子线程中，用户只需要覆写onHandleIntent函数，并且在该函数中完成自己的耗时操作即可。需要注意的是，在任务执行完毕之后IntentService会调用stopSelf自我销毁，因此，它适用于完成一些短期的耗时任务。 1.3 运行在前台的Service将Service运行在前台不仅不会被系统无情地回收，它还会在通知栏显示一条消息，下拉状态栏后可以看到更加详细的信息。例如，墨迹天气在前台运行了一个Service，并且在Service中定时更新通知栏上的天气信息。 1.4 AIDLAndroid Interface Definition Language(Android接口定义语言)，同行用于进程间通信（Android系统中的进程之间不能共享内存）。 Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL. “只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL”，其他情况下你都可以选择其他方法，如使用Messager，也能跨进程通讯。可见AIDL是处理多线程、多客户端并发访问的。而Messager是单线程处理。]]></content>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
        <tag>service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Activity]]></title>
    <url>%2F2017%2F02%2F02%2F2017-02-02-android-activity%2F</url>
    <content type="text"><![CDATA[1 Activity1.1 Activity的生命周期1.onCreate() onCreate()方法会在Activity第一次被创建时调用，通常会在这个函数中完成Activity的初始化操作，如设置布局、初始化视图、绑定事件等。 2.onStart() 这个函数在Activity可见之前被调用。 3.onResume() 这个函数在Activity变为可见时被调用，执行完onResume之后，Activity就会请求AMS渲染它所管理的视图。此时的Activity一定位于返回栈的栈顶，并且处于运行状态。可见的、有焦点的。 4.onPause() 这个函数在Activity失去焦点，从可见变为不完全可见时调用。 5.onStop() 这个函数在Activity完全不可见时调用。 6.onDestroy() 这个函数在Activity被销毁之前调用，之后Activity的状态变为销毁状态。在这个函数里释放内存。 7.onRestart() 这个函数在Activity由停止状态重新变为运行状态之前调用，下一个调用onStart()。 ###1.2 Activity的构成 ### PhoneWindow→DecorView→DefultLayout→ViewGroup:mContentParent→用户自己的xml布局 1.3 Activity的4种启动模式1.standard 在这种模式下启动的Activity可以被多次实例化，每启动一个Activity都会在栈顶创建一个新的实例。实际开发中，闹钟程序通常使采用这种模式。如果Activity是一个非常耗资源的类，那么将会使应用消耗更多的系统资源。 2.singleTop singleTop模式启动Activity时，首先会判断要启动Acitity实例是否位于栈顶，如果位于栈顶则直接复用，否则与standard模式相同，创建一个新的实例。实际开发中，浏览器的书签通常采用这种模式。 3.singleTask singleTask模式可以保证一个任务栈中只能有一个该Activity实例。每次启动该Activity时，首先会判断该Acitivity是否存在任务栈中，如果已存在，系统会销毁该Activity之上的所有Activity实例，最终让该Activity实例位于栈顶。如果任务栈中没有该Activity实例，会新创建一个实例并放在栈顶。在实际开发中，浏览器主界面通常采用这种模式。 4.singleInstance 设置为singleInstance模式的Activity会启动一个独立的任务栈来管理Activity实例，并且这个任务栈中有且只有一个实例。如果要启动的Activity已存在，无论当前Activity位于哪个程序哪个任务栈中，系统都会把Activity所在的任务栈转移到前台，从而使Activity显示。实际开发中，来电界面通常采用这种模式。]]></content>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
        <tag>activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件]]></title>
    <url>%2F2017%2F01%2F28%2F2017-01-28-android-components%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入门训练 Fibonacci数列]]></title>
    <url>%2F2017%2F01%2F18%2F2017-01-18-introductory-training-fibonacci-sequence%2F</url>
    <content type="text"><![CDATA[问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入10 样例输出55 样例输入22 样例输出7704 数据规模与约定1 &lt;= n &lt;= 1,000,000 提交序号 1209677提交时间 2017-01-18 19:05:30评测结果 正确得分 100CPU使用 250ms内存使用 21.17MB试题名称 入门训练 Fibonacci数列语言 JAVA源代码12345678910111213141516171819202122import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; int a1,a2; a1=a2=1; int sum=0,temp;//sum是保存余数的变量 ，temp是为了方便交换数据 long n;//因为n&gt;=1 and n&lt;=1000000 long i; Scanner scanner = new Scanner(System.in); n = scanner.nextLong(); for(i=1;i&lt;=n;i++) &#123; sum=a1 % 10007; temp=a2; a2=(a1+a2) % 10007; a1=temp; &#125; System.out.println(sum); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2016%2F08%2F26%2F2016-08-26-jquery%2F</url>
    <content type="text"><![CDATA[JQuery 是什么? javascript 的代码框架。 有什么用? 简化代码，提高效率。 核心 write less do more , 写得更少，做的更多。 load12345678910&lt;a href="" onclick="load()"&gt;使用JQuery执行load方法&lt;/a&gt;有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=""的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。//找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示$("#aaa").load("/day16/DemoServlet02" , function(responseText , statusTXT , xhr) &#123; //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $("#aaa").val(responseText); &#125;); Get123$.get("/day16/DemoServlet02" , function(data ,status) &#123; $("#div01").text(data); &#125;); 赋值显示 val(“aa”); 只能放那些标签带有value属性 html(“aa”); —写html代码 text(“aa”); 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() load &amp; get load 123$("#元素id").load(url地址);$("#div1").load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值 get语法格式 ： 1$.get(URL,callback); 使用案例：123$.get("/day16/DemoServlet02" , function(data ,status) &#123; $("#div01").text(data);&#125;); post语法格式：1$.post(URL,data,callback); 123456function post() &#123; $.post("/day16/DemoServlet02", &#123;name:"zhangsan",age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $("#div01").html(data); &#125;);&#125; 使用JQuery去实现校验用户名1234567891011121314151617function checkUserName() &#123; //1. 获取输入框的内容 var name = $("#name").val(); //2. 发送请求 $.post("/day16/CheckUserNameServlet" , &#123;name:name&#125; , function(data , status)&#123; //alert(data); if(data == 1)&#123;//用户名存在 //alert("用户名存在"); $("#span01").html("&lt;font color='red'&gt;用户名已被注册&lt;/font&gt;"); &#125;else&#123; //alert("用户名可用"); $("#span01").html("&lt;font color='green'&gt;用户名可以使用&lt;/font&gt;"); &#125; &#125; ); //3. 输出响应的数据到页面上。&#125; 实现百度搜索提示搭建环境 定义首页 123456789&lt;body&gt; &lt;center&gt; &lt;h2&gt;百度&lt;/h2&gt; &lt;input type="text" name="word" id="word" style="width: 600px ; height: 50px ;font-size: 20px;"&gt; &lt;input type="button" value="百度一下" style="height: 55px ; width: 100px ; "&gt; &lt;div id="div01" style="position:relative; left : -54px; width: 600px; height: 200px ; border: 1px solid blue; display: none"&gt;&lt;/div&gt; &lt;/center&gt;&lt;/body&gt; 定义数据库 捕获键盘弹起12345$(function()&#123; $("#word").keyup(function() &#123; alert("键盘弹起了.."); &#125;)&#125;); JS请求123456789101112131415161718192021$(function()&#123; $("#word").keyup(function() &#123; //2。 获取输入框的值 //var word = $("#word").val(); //this 对应就是执行这个方法的那个对象， $("#word") var word = $(this).val(); if(word == "")&#123; $("#div01").hide(); &#125;else&#123; //3. 请求数据。 $.post("find",&#123;word:word&#125; ,function(data , status)&#123; //alert(data); $("#div01").show(); $("#div01").html(data); &#125;); &#125; &#125;)&#125;); Servlet代码123456789101112131415161718192021222324252627protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); try &#123; //1. 先获取参数 String word = request.getParameter("word"); System.out.println("word="+word); //2. 让dao执行查询 WordsDao dao = new WordsDaoImpl(); List&lt;WordBean&gt; list = dao.findWords(word); for (WordBean wordBean : list) &#123; System.out.println("==="+wordBean.toString()); &#125; request.setAttribute("list", list); //3. 返回数据 response.setContentType("text/html;charset=utf-8"); //response.getWriter().write("数据是："); request.getRequestDispatcher("list.jsp").forward(request, response); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; list.jsp12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;​ &lt;table style="width: 100%"&gt; &lt;c:forEach items="$&#123;list &#125;" var="wordBean"&gt; &lt;tr&gt; &lt;td&gt;$&#123;wordBean.words&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 使用JQuery实现 省市联动环境准备 准备数据库 2 。 准备页面1234567891011121314151617&lt;script type="text/javascript" src="js/jquery-1.11.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="js/city.js"&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt; 省份: &lt;select name="province" id ="province"&gt; &lt;option value="" &gt;-请选择 - &lt;option value="1" &gt;广东 &lt;option value="2" &gt;湖南 &lt;option value="3" &gt;湖北 &lt;option value="4" &gt;四川 &lt;/select&gt; 城市: &lt;select name="city" id="city"&gt; &lt;option value="" &gt;-请选择 - &lt;/select&gt; &lt;/body&gt; XStream的使用1234567891011//3. 返回数据。手动拼 ---&gt; XStream 转化 bean对象成 xml XStream xStream = new XStream(); //想把id做成属性 xStream.useAttributeFor(CityBean.class, "id"); //设置别名 xStream.alias("city", CityBean.class); //转化一个对象成xml字符串 String xml = xStream.toXML(list); JS代码12345678910111213141516171819202122232425262728293031323334353637383940$(function() &#123; //1。找到省份的元素 $("#province").change(function() &#123; //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$("#province").varl(); var pid = $(this).val(); /*&lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt;*/ $.post( "CityServlet",&#123;pid:pid&#125; ,function(data,status)&#123; //alert("回来数据了:"+data); //先清空以前的值： $("#city").html("&lt;option value='' &gt;-请选择-") //遍历： //从data数据里面找出所有的city ， 然后遍历所有的city。 //遍历一个city，就执行一次function方法 $(data).find("city").each(function() &#123; //遍历出来的每一个city，取它的孩子。 id , cname var id = $(this).children("id").text(); var cname = $(this).children("cname").text(); $("#city").append("&lt;option value='"+id+"' &gt;"+cname) &#125;); &#125; ); &#125;);&#125;); 服务器和客户端数据传输的方式 xml 123456789101112&lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt;&lt;/list&gt; json 阅读性更好 、 容量更小。 {“name”:”aaa” , “age”:19} 把javaBean 转化成 json数据123456//3. 把list ---&gt; json数据//JSONArray ---&gt; 变成数组 ， 集合 []//JSONObject ---&gt; 变成简单的数据 &#123; name : zhangsan , age:18&#125;JSONArray jsonArray = JSONArray.fromObject(list);String json = jsonArray.toString(); 使用json格式数据显示省市联动效果serlvet代码： 123456789101112131415161718192021222324252627protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; //1. 获取参数 int pid = Integer.parseInt(request.getParameter("pid")); //2 找出所有的城市 CityDao dao = new CityDaoImpl(); List&lt;CityBean&gt; list = dao.findCity(pid); //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 &#123; name : zhangsan , age:18&#125; JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); response.setContentType("text/html;charset=utf-8"); response.getWriter().write(json); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;;&#125; js代码 123456789101112131415161718192021222324252627282930313233$(function() &#123; //1。找到省份的元素 $("#province").change(function() &#123; //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$("#province").varl(); var pid = $(this).val(); /*[ &#123; "cname": "深圳", "id": 1, "pid": 1 &#125;, &#123; "cname": "东莞", "id": 2, "pid": 1 &#125; ... ]*/ $.post( "CityServlet02",&#123;pid:pid&#125; ,function(data,status)&#123; //先清空 $("#city").html("&lt;option value='' &gt;-请选择-"); //再遍历，追加 $(data).each(function(index , c) &#123; $("#city").append("&lt;option value='"+c.id+"' &gt;"+c.cname) &#125;); &#125;,"json" ); &#125;);&#125;); 总结JQuery发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 --------------------------------------- 1. 服务器返回xml数据 2. 服务器返回json数据]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2016%2F08%2F16%2F2016-08-16-ajax%2F</url>
    <content type="text"><![CDATA[Ajax 是什么? “Asynchronous Javascript And XML”（异步JavaScript和XML）， 并不是新的技术，只是把原有的技术，整合到一起而已。 1.使用CSS和XHTML来表示。 2.使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 数据请求 Get1.创建对象1234567891011121314151617function ajaxFunction()&#123; var xmlHttp; try &#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; 发送请求 12345678910111213141516171819202122232425262728293031323334353637383940414243//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open("GET" ,"/day16/DemoServlet01" ,true ); request.send();&#125;如果发送请求的同时，还想获取数据，那么代码如下//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open("GET" ,"/day16/DemoServlet01?name=aa&amp;age=18" ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function()&#123; //前半段表示 已经能够正常处理。 再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求 Post1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;script type="text/javascript"&gt; //1. 创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125;function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( "POST", "/day16/DemoServlet01", true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //带数据过去 ， 在send方法里面写表单数据。 request.send("name=aobama&amp;age=19");&#125;&lt;/script&gt;需要获取数据function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( "POST", "/day16/DemoServlet01", true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function()&#123; if(request.readyState==4 &amp;&amp; request.status == 200)&#123; alert("post："+request.responseText); &#125; &#125; //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //带数据过去 ， 在send方法里面写表单数据。 request.send("name=aobama&amp;age=19");&#125; 校验用户名是否可用1. 搭建环境 页面准备 1234567891011121314151617181920212223&lt;body&gt; &lt;table border="1" width="500"&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name" id="name" onblur="checkUserName()"&gt;&lt;span id="span01"&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="text" name=""&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type="text" name=""&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;简介&lt;/td&gt; &lt;td&gt;&lt;input type="text" name=""&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;input type="submit" value="注册"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 数据库准备 2. Servlet代码1234567891011121314151617181920212223protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; request.setCharacterEncoding("UTF-8"); //1. 检测是否存在 String name = request.getParameter("name"); System.out.println("name="+name); UserDao dao = new UserDaomImpl(); boolean isExist = dao.checkUserName(name); //2. 通知页面，到底有还是没有。 if(isExist)&#123; response.getWriter().println(1); //存在用户名 &#125;else&#123; response.getWriter().println(2); //不存在该用户名 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 3. Dao代码12345678910111213141516public class UserDaomImpl implements UserDao&#123; @Override public boolean checkUserName(String username) throws SQLException &#123; QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource()); String sql = "select count(*) from t_user where username =?"; runner.query(sql, new ScalarHandler(), username); Long result = (Long) runner.query(sql, new ScalarHandler(), username); return result &gt; 0 ; &#125;&#125; jsp页面显示​123456789101112131415161718192021222324252627282930function checkUserName() &#123; //获取输入框的值 document 整个网页 var name = document.getElementById("name").value; // value value() val val() //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open("POST" ,"/day16/CheckUserNameServlet" , true ); //注册状态改变监听，获取服务器传送过来的数据 request.onreadystatechange = function()&#123; if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //alert(request.responseText); var data = request.responseText; if(data == 1)&#123; //alert("用户名已存在"); document.getElementById("span01").innerHTML = "&lt;font color='red'&gt;用户名已存在!&lt;/font&gt;"; &#125;else&#123; document.getElementById("span01").innerHTML = "&lt;font color='green'&gt;用户名可用!&lt;/font&gt;"; //alert("用户名未存在"); &#125; &#125; &#125; request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); request.send("name="+name);&#125; 总结Ajax发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七大查找算法汇总]]></title>
    <url>%2F2016%2F08%2F08%2F2016-08-08-search-algorithm%2F</url>
    <content type="text"><![CDATA[1.顺序查找2.二分查找3.插值查找4.斐波那契查找5.树表查找6.分块查找7.哈希查找 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。查找定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。查找算法分类：（1）静态查找和动态查找； 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。（2）无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。Pi：查找表中第i个数据元素的概率。Ci：找到第i个数据元素时已经比较过的次数。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七、哈希查找]]></title>
    <url>%2F2016%2F08%2F04%2F2016-08-04-hash-search%2F</url>
    <content type="text"><![CDATA[哈希查找什么是哈希表（Hash）？我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。 总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。 什么是哈希函数？哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。 算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 算法流程： 1）用给定的哈希函数构造哈希表； 2）根据选择的冲突处理方法解决地址冲突； 常见的解决冲突的方法：拉链法和线性探测法。详细的介绍可以参见：浅谈算法和数据结构: 十一 哈希表。 3）在哈希表的基础上执行哈希查找。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 复杂度分析： 单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(n)（注意，在查找之前我们需要构建相应的Hash表）。 使用Hash，我们付出了什么？我们在实际编程中存储一个大规模的数据，最先想到的存储结构可能就是map，也就是我们常说的KV pair，经常使用Python的博友可能更有这种体会。使用map的好处就是，我们在后续处理数据处理时，可以根据数据的key快速的查找到对应的value值。map的本质就是Hash表，那我们在获取了超高查找效率的基础上，我们付出了什么？ Hash是一种典型以空间换时间的算法，比如原来一个长度为100的数组，对其查找，只需要遍历且匹配相应记录即可，从空间复杂度上来看，假如数组存储的是byte类型数据，那么该数组占用100byte空间。现在我们采用Hash算法，我们前面说的Hash必须有一个规则，约束键与存储位置的关系，那么就需要一个固定长度的hash表，此时，仍然是100byte的数组，假设我们需要的100byte用来记录键与位置的关系，那么总的空间为200byte,而且用于记录规则的表大小会根据规则，大小可能是不定的。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六、分块查找]]></title>
    <url>%2F2016%2F07%2F25%2F2016-07-25-block-search%2F</url>
    <content type="text"><![CDATA[分块查找分块查找又称索引顺序查找，它是顺序查找的一种改进方法。 算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，…… 算法流程：step1 先选取各块中的最大关键字构成一个索引表；step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五、树表查找]]></title>
    <url>%2F2016%2F07%2F18%2F2016-07-18-tree-table-search%2F</url>
    <content type="text"><![CDATA[树表查找 最简单的树表查找算法——二叉树查找算法。 基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树： 1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 3）任意节点的左、右子树也分别为二叉查找树。 二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。 复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、斐波那契查找]]></title>
    <url>%2F2016%2F07%2F12%2F2016-07-12-fibonacci-search%2F</url>
    <content type="text"><![CDATA[在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。 黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。 0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。 大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。斐波那契搜索就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为Fn，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况： 1）相等，mid位置的元素即为所求 2）&gt;，low=mid+1; 3）&lt;，high=mid-1。 斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1; 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种 1）相等，mid位置的元素即为所求 2）&gt;，low=mid+1,k-=2; 说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。 3）&lt;，high=mid-1,k-=1。 说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。 复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。C++代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 斐波那契查找.cpp#include "stdafx.h"#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;const int max_size=20;//斐波那契数组的长度/*构造一个斐波那契数组*/void Fibonacci(int * F)&#123; F[0]=0; F[1]=1; for(int i=2;i&lt;max_size;++i) F[i]=F[i-1]+F[i-2];&#125;/*定义斐波那契查找法*/ int FibonacciSearch(int *a, int n, int key) //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字&#123; int low=0; int high=n-1; int F[max_size]; Fibonacci(F);//构造一个斐波那契数组F int k=0; while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置 ++k; int * temp;//将数组a扩展到F[k]-1的长度 temp=new int [F[k]-1]; memcpy(temp,a,n*sizeof(int)); for(int i=n;i&lt;F[k]-1;++i) temp[i]=a[n-1]; while(low&lt;=high) &#123; int mid=low+F[k-1]-1; if(key&lt;temp[mid]) &#123; high=mid-1; k-=1; &#125; else if(key&gt;temp[mid]) &#123; low=mid+1; k-=2; &#125; else &#123; if(mid&lt;n) return mid; //若相等则说明mid即为查找到的位置 else return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1 &#125; &#125; delete [] temp; return -1;&#125;int main()&#123; int a[] = &#123;0,16,24,35,47,59,62,73,88,99&#125;; int key=100; int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key); cout&lt;&lt;key&lt;&lt;" is located at:"&lt;&lt;index; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、插值查找]]></title>
    <url>%2F2016%2F07%2F06%2F2016-07-06-interpolation-search%2F</url>
    <content type="text"><![CDATA[插值查找在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？ 打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：mid=(low+high)/2, 即mid=low+1/2(high-low);通过类比，我们可以将查找的点改进为如下：mid=low+(key-a[low])/(a[high]-a[low])(high-low)，也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。 Java代码实现12345678910111213//插值查找public int InsertionSearch(int a[], int value, int low, int high) &#123; int mid = low+(value-a[low])/(a[high]-a[low])*(high-low); if(a[mid]==value) &#123; return mid; &#125; if(a[mid]&gt;value) &#123; return InsertionSearch(a, value, low, mid-1); &#125; if(a[mid]&lt;value) &#123; return InsertionSearch(a, value, mid+1, high); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、顺序查找]]></title>
    <url>%2F2016%2F06%2F24%2F2016-06-24-in-order-to-find-search%2F</url>
    <content type="text"><![CDATA[顺序查找说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ; 当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。Java代码实现12345678910//顺序查找public int SequenceSearch(int a[], int value, int n) &#123; int i; for(i=0; i&lt;n; i++) &#123; if(a[i]==value) &#123; return i; &#125; &#125; return -1;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、二分查找]]></title>
    <url>%2F2016%2F06%2F24%2F2016-06-30-binary-search%2F</url>
    <content type="text"><![CDATA[2.二分查找说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)； 注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》 Java代码实现12345678910111213141516171819202122232425262728293031323334//二分查找 版本1 循环public int BinarySearch1(int a[], int value, int n) &#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) &#123; return mid; &#125; if(a[mid]&gt;value) &#123; high = mid-1; &#125; if(a[mid]&lt;value) &#123; low = mid+1; &#125; &#125; return -1;&#125;//二分查找，递归版本public int BinarySearch2(int a[], int value, int low, int high)&#123; int mid = low+(high-low)/2; if(a[mid]==value) &#123; return mid; &#125; if(a[mid]&gt;value) &#123; return BinarySearch2(a, value, low, mid-1); &#125; if(a[mid]&lt;value) &#123; return BinarySearch2(a, value, mid+1, high); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序算法汇总]]></title>
    <url>%2F2016%2F06%2F20%2F2016-06-20-sorting-algorithm%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八、基数排序]]></title>
    <url>%2F2016%2F06%2F18%2F2016-06-18-radix-sort%2F</url>
    <content type="text"><![CDATA[基数排序(Radix Sort或Bin Sort)1.基本思想BinSort想法非常简单，首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。 2.图示①问题：当序列中存在较大值时，BinSort 的排序方法会浪费大量的空间开销。②思想：基数排序是在BinSort的基础上，通过基数的限制来减少空间的开销。 3.过程（1）首先确定基数为10，数组的长度也就是10.每个数34都会在这10个数中寻找自己的位置。（2）不同于BinSort会直接将数34放在数组的下标34处，基数排序是将34分开为3和4，第一轮排序根据最末位放在数组的下标4处，第二轮排序根据倒数第二位放在数组的下标3处，然后遍历数组即可。 4.Java代码实现1234567891011121314151617181920212223242526272829303132public static void RadixSort(int A[],int temp[],int n,int k,int r,int cnt[])&#123; //A:原数组 //temp:临时数组 //n:序列的数字个数 //k:最大的位数2 //r:基数10 //cnt:存储bin[i]的个数 for(int i=0 , rtok=1; i&lt;k ; i++ ,rtok = rtok*r)&#123; //初始化 for(int j=0;j&lt;r;j++)&#123; cnt[j] = 0; &#125; //计算每个箱子的数字个数 for(int j=0;j&lt;n;j++)&#123; cnt[(A[j]/rtok)%r]++; &#125; //cnt[j]的个数修改为前j个箱子一共有几个数字 for(int j=1;j&lt;r;j++)&#123; cnt[j] = cnt[j-1] + cnt[j]; &#125; for(int j = n-1;j&gt;=0;j--)&#123; //重点理解 cnt[(A[j]/rtok)%r]--; temp[cnt[(A[j]/rtok)%r]] = A[j]; &#125; for(int j=0;j&lt;n;j++)&#123; A[j] = temp[j]; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七、归并排序]]></title>
    <url>%2F2016%2F06%2F12%2F2016-06-12-merge-sort%2F</url>
    <content type="text"><![CDATA[归并排序(Merge Sort)1.基本思想归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。首先考虑下如何将2个有序数列合并。这个非常简单，只要从比较2个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。1234567891011121314151617181920//将有序数组a[]和b[]合并到c[]中void MemeryArray(int a[], int n, int b[], int m, int c[])&#123; int i, j, k; i = j = k = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] &lt; b[j]) c[k++] = a[i++]; else c[k++] = b[j++]; &#125; while (i &lt; n) c[k++] = a[i++]; while (j &lt; m) c[k++] = b[j++];&#125; 解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成2组A，B，如果这2组组内的数据都是有序的，那么就可以很方便的将这2组数据进行排序。如何让这2组组内数据有序了？可以将A，B组各自再分成2组。依次类推，当分出来的小组只有1个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的2个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。 2.过程 3.平均时间复杂度 O(n㏒n)归并排序的效率是比较高的，设数列长为n，将数列分开成小数列一共要㏒n步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(n)，故一共为O(n㏒n)。 4.Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142public static void merge_sort(int a[],int first,int last,int temp[])&#123; if(first &lt; last)&#123; int middle = (first + last)/2; merge_sort(a,first,middle,temp);//左半部分排好序 merge_sort(a,middle+1,last,temp);//右半部分排好序 mergeArray(a,first,middle,last,temp); //合并左右部分 &#125;&#125;//合并 ：将两个序列a[first-middle],a[middle+1-end]合并public static void mergeArray(int a[],int first,int middle,int end,int temp[])&#123; int i = first; int m = middle; int j = middle+1; int n = end; int k = 0; while(i&lt;=m &amp;&amp; j&lt;=n)&#123; if(a[i] &lt;= a[j])&#123; temp[k] = a[i]; k++; i++; &#125;else&#123; temp[k] = a[j]; k++; j++; &#125; &#125; while(i&lt;=m)&#123; temp[k] = a[i]; k++; i++; &#125; while(j&lt;=n)&#123; temp[k] = a[j]; k++; j++; &#125; for(int ii=0;ii&lt;k;ii++)&#123; a[first + ii] = temp[ii]; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六、快速排序]]></title>
    <url>%2F2016%2F06%2F06%2F2016-06-06-quick-sort%2F</url>
    <content type="text"><![CDATA[快速排序(Quick Sort)1.基本思想 （分治）1.先从数列中取出一个数作为key值；2.将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；3.对左右两个小数列重复第二步，直至各区间只有1个数。 2.辅助理解 挖坑填数1.初始时 i = 0; j = 9; key=72由于已经将a[0]中的数保存到key中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。从j开始向前找一个比key小的数。当j=8，符合条件，a[0] = a[8] ; i++ ; 将a[8]挖出再填到上一个坑a[0]中。这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于key的数，当i=3，符合条件，a[8] = a[3] ; j– ; 将a[3]挖出再填到上一个坑中。数组：72 - 6 - 57 - 88 - 60 - 42 - 83 - 73 - 48 - 85 0 1 2 3 4 5 6 7 8 92.此时 i = 3; j = 7; key=72再重复上面的步骤，先从后向前找，再从前向后找。从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;从i开始向后找，当i=5时，由于i==j退出。此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将key填入a[5]。数组：48 - 6 - 57 - 88 - 60 - 42 - 83 - 73 - 88 - 85 0 1 2 3 4 5 6 7 8 93.可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。数组：48 - 6 - 57 - 42 - 60 - 72 - 83 - 73 - 88 - 85 0 1 2 3 4 5 6 7 8 9 3.平均时间复杂度：O(n㏒n)4.Java代码实现12345678910111213141516171819202122232425262728public static void quickSort(int a[],int l,int r)&#123; if(l&gt;=r) return; int i = l; int j = r; int key = a[l];//选择第一个数为key while(i&lt;j)&#123; while(i&lt;j &amp;&amp; a[j]&gt;=key)//从右向左找第一个小于key的值 j--; if(i&lt;j)&#123; a[i] = a[j]; i++; &#125; while(i&lt;j &amp;&amp; a[i]&lt;key)//从左向右找第一个大于key的值 i++; if(i&lt;j)&#123; a[j] = a[i]; j--; &#125; &#125; //i == j a[i] = key; quickSort(a, l, i-1);//递归调用 quickSort(a, i+1, r);//递归调用&#125; key值的选取可以有多种形式，例如中间数或者随机数，分别会对算法的复杂度产生不同的影响。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五、冒泡排序]]></title>
    <url>%2F2016%2F05%2F28%2F2016-05-28-bubble-sort%2F</url>
    <content type="text"><![CDATA[冒泡排序(Bubble Sort)1.基本思想两个数比较大小，较大的数下沉，较小的数冒起来。 2.过程 比较相邻的两个数据，如果第二个数小，就交换位置。 从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。 继续重复上述过程，依次将第2.3…n-1个最小数排好位置。3.平均时间复杂度 O(n²)4.Java代码实现1234567891011121314public static void BubbleSort(int [] arr)&#123; int temp;//临时变量 for(int i=0; i&lt;arr.length-1; i++)&#123; //表示趟数，一共arr.length-1次。 for(int j=arr.length-1; j&gt;i; j--)&#123; if(arr[j] &lt; arr[j-1])&#123; temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; &#125;&#125; 5.优化 针对问题：数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。 方案：设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。 12345678910111213141516171819public static void BubbleSort1(int [] arr)&#123; int temp;//临时变量 boolean flag;//是否交换的标志 for(int i=0; i&lt;arr.length-1; i++)&#123; //表示趟数，一共arr.length-1次。 flag = false; for(int j=arr.length-1; j&gt;i; j--)&#123; if(arr[j] &lt; arr[j-1])&#123; temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; flag = true; &#125; &#125; if(!flag) break; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四、堆排序]]></title>
    <url>%2F2016%2F05%2F23%2F2016-05-23-heap-sort%2F</url>
    <content type="text"><![CDATA[堆排序(Heap Sort)1.基本思想 ①图示： （88,85,83,73,72,60,57,48,42,6） 2.平均时间复杂度：O(n㏒n)由于每次重新恢复堆的时间复杂度为O(n㏒n)，共n - 1次重新恢复堆操作，再加上前面建立堆时n / 2次向下调整，每次调整时间复杂度也为O(n㏒n)。二次操作时间相加还是O(n㏒n)。 3.Java代码实现1234567891011121314151617181920212223242526272829303132333435363738394041//构建最小堆public static void MakeMinHeap(int a[], int n)&#123; for(int i=(n-1)/2 ; i&gt;=0 ; i--)&#123; MinHeapFixdown(a,i,n); &#125;&#125;//从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2 public static void MinHeapFixdown(int a[],int i,int n)&#123; int j = 2*i+1; //子节点 int temp = 0; while(j&lt;n)&#123; //在左右子节点中寻找最小的 if(j+1&lt;n &amp;&amp; a[j+1]&lt;a[j])&#123; j++; &#125; if(a[i] &lt;= a[j]) break; //较大节点下移 temp = a[i]; a[i] = a[j]; a[j] = temp; i = j; j = 2*i+1; &#125;&#125;public static void MinHeap_Sort(int a[],int n)&#123; int temp = 0; MakeMinHeap(a,n); for(int i=n-1;i&gt;0;i--)&#123; temp = a[0]; a[0] = a[i]; a[i] = temp; MinHeapFixdown(a,0,i); &#125; &#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三、选择排序]]></title>
    <url>%2F2016%2F05%2F18%2F2016-05-18-selection-sort%2F</url>
    <content type="text"><![CDATA[选择排序(Selction Sort)1.基本思想在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；第二次遍历n-2个数，找到最小的数值与第二个元素交换；。。。第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。 2.过程 3.平均时间复杂度 O(n²)4.Java代码实现1234567891011121314151617public static void select_sort(int array[],int lenth)&#123; for(int i=0;i&lt;lenth-1;i++)&#123; int minIndex = i; for(int j=i+1;j&lt;lenth;j++)&#123; if(array[j]&lt;array[minIndex])&#123; minIndex = j; &#125; &#125; if(minIndex != i)&#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、插入排序]]></title>
    <url>%2F2016%2F05%2F04%2F2016-05-04-insertion-sort%2F</url>
    <content type="text"><![CDATA[插入排序(Insertion Sort)1.基本思想在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。算法适用于少量数据的排序，时间复杂度为O(n^2)，是稳定的排序方法。 2.过程 3.平均时间复杂度 O(n²)4.Java代码实现12345678910111213141516public static void insert_sort(int array[],int lenth)&#123; int temp; for(int i=0;i&lt;lenth-1;i++)&#123; for(int j=i+1;j&gt;0;j--)&#123; if(array[j] &lt; array[j-1])&#123; temp = array[j-1]; array[j-1] = array[j]; array[j] = temp; &#125;else&#123; //不需要交换 break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二、希尔排序]]></title>
    <url>%2F2016%2F05%2F04%2F2016-05-12-shell-sort%2F</url>
    <content type="text"><![CDATA[希尔排序(Shell Sort)1.前言数据序列1： 13-17-20-42-28 利用插入排序，13-17-20-28-42. Number of swap:1;数据序列2： 13-17-20-42-14 利用插入排序，13-14-17-20-42. Number of swap:3;如果数据序列基本有序，使用插入排序会更加高效。 2.基本思想在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。 3.过程 4.平均时间复杂度 O(n^1.3)5.Java代码实现1234567891011121314151617181920212223242526272829public static void shell_sort(int array[],int lenth)&#123; int temp = 0; int incre = lenth; while(true)&#123; incre = incre/2; for(int k = 0;k&lt;incre;k++)&#123; //根据增量分为若干子序列 for(int i=k+incre;i&lt;lenth;i+=incre)&#123; for(int j=i;j&gt;k;j-=incre)&#123; if(array[j]&lt;array[j-incre])&#123; temp = array[j-incre]; array[j-incre] = array[j]; array[j] = temp; &#125;else&#123; break; &#125; &#125; &#125; &#125; if(incre == 1)&#123; break; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F02%2F22%2F2016-02-22-hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
