<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">










  <meta name="google-site-verification" content="2_gvJ0AU4BQMbo71lVLx7ZFue1PuEupJjYtJtYYvWfI">







  <meta name="baidu-site-verification" content="NGZiuIq8y3">











<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java并发知识库">
<meta name="keywords" content="java,多线程,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程并发">
<meta property="og:url" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/index.html">
<meta property="og:site_name" content="Shado&#39;s Blog">
<meta property="og:description" content="Java并发知识库">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/java-util-concurrent.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/executor.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-lifecycle.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/synchronized-principle.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-method.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-context-switch.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-pool.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-pool-process.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-1.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-2.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-3.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-class.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/volatile.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-local.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/segment.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-scheduling.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-scheduling-2.jpg">
<meta property="og:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/abstract-queued-synchronizer.jpg">
<meta property="og:updated_time" content="2019-06-18T08:43:33.543Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程并发">
<meta name="twitter:description" content="Java并发知识库">
<meta name="twitter:image" content="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/java-util-concurrent.jpg">



  <link rel="alternate" href="/atom.xml" title="Shado's Blog" type="application/atom+xml">




  <link rel="canonical" href="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java多线程并发 | Shado's Blog</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2e95519f99e1c36388001fcde9a63479";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shado's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shado.com.cn/2019/05/06/2019-05-06-concurrency-and-multithreading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shado Fung">
      <meta itemprop="description" content="Java Developer">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shado's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java多线程并发

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-06 20:03:19" itemprop="dateCreated datePublished" datetime="2019-05-06T20:03:19+08:00">2019-05-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-18 16:43:33" itemprop="dateModified" datetime="2019-06-18T16:43:33+08:00">2019-06-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/多线程/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">49k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1:21</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Java并发知识库"><a href="#Java并发知识库" class="headerlink" title="Java并发知识库"></a>Java并发知识库</h2><p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/java-util-concurrent.jpg" alt="J.U.C"><br><a id="more"></a></p>
<h2 id="Java线程实现-创建方式"><a href="#Java线程实现-创建方式" class="headerlink" title="Java线程实现/创建方式"></a>Java线程实现/创建方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread 类本质上是实现了Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的start()实例方法。start()方法是一个native 方法，它将启动一个新线程，并执行run()方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public void run() &#123;</span><br><span class="line">    <span class="type">System</span>.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="type">MyThread</span> myThread = <span class="keyword">new</span> <span class="type">MyThread</span>();</span><br><span class="line">    myThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>如果自己的类已经extends 另一个类，就无法直接extends Thread，此时，可以实现一个Runnable 接口。</p>
<p><strong>Runnable接口对比Callable接口</strong>：Runnable不能抛出异常，不能带返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread 实例：</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ExecutorService、Callable、Future有返回值线程"><a href="#ExecutorService、Callable、Future有返回值线程" class="headerlink" title="ExecutorService、Callable、Future有返回值线程"></a>ExecutorService、Callable<class>、Future有返回值线程</class></h3><p>有返回值的任务必须实现Callable 接口，类似的，无返回值的任务必须实现Runnable 接口。执行Callable 任务后，可以获取一个Future 的对象，在该对象上调用get 就可以获取到Callable 任务返回的Object 了，再结合线程池接口ExecutorService 就可以实现传说中有返回结果的多线程了。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.<span class="keyword">new</span> FixedThreadPool(taskSize);</span><br><span class="line"><span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line"><span class="keyword">List</span>&lt;Future&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">  Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</span><br><span class="line">  <span class="comment">// 执行任务并获取Future 对象</span></span><br><span class="line">  Future f = pool.submit(c);</span><br><span class="line">  <span class="keyword">list</span>.add(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line"><span class="keyword">for</span> (Future f : <span class="keyword">list</span>) &#123;</span><br><span class="line">  <span class="comment">// 从Future 对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">  System.out.println(<span class="string">"res："</span> + f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a>基于线程池的方式</h3><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的基本大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> corePoolSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池最大数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maximumPoolSizeSize = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程活动保持时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> keepAliveTime = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue workQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池拒绝策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                corePoolSize,</span><br><span class="line">                maximumPoolSizeSize,</span><br><span class="line">                keepAliveTime,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                workQueue,</span><br><span class="line">                <span class="comment">// Google guava</span></span><br><span class="line">                <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build(),</span><br><span class="line">                <span class="comment">// 线程池拒绝策略</span></span><br><span class="line">                handler);</span><br><span class="line">        <span class="comment">//提交一个任务</span></span><br><span class="line">        executor.execute(() -&gt; System.<span class="keyword">out</span>.println(<span class="string">"ok"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">corePoolSize</td>
<td style="text-align:center">int</td>
<td style="text-align:center">核心线程池大小</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">maximumPoolSize</td>
<td style="text-align:center">int</td>
<td style="text-align:center">最大线程池大小</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">keepAliveTime</td>
<td style="text-align:center">long</td>
<td style="text-align:center">线程最大空闲时间</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">unit</td>
<td style="text-align:center">TimeUnit</td>
<td style="text-align:center">时间单位</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">workQueue</td>
<td style="text-align:center">BlockingQueue<runnable></runnable></td>
<td style="text-align:center">线程等待队列</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">threadFactory</td>
<td style="text-align:center">ThreadFactory</td>
<td style="text-align:center">线程创建工厂</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">handler</td>
<td style="text-align:center">RejectedExecutionHandler</td>
<td style="text-align:center">拒绝策略</td>
</tr>
</tbody>
</table>
<h2 id="4种线程池"><a href="#4种线程池" class="headerlink" title="4种线程池"></a>4种线程池</h2><p>Java 里面线程池的顶级接口是Executor，但是严格意义上讲Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/executor.jpg" alt="Executor"></p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式(可能会导致OOM)来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> initialDelay = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> period = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"延迟三秒"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"延迟1 秒后每三秒执行一次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。</p>
<h2 id="线程生命周期-状态"><a href="#线程生命周期-状态" class="headerlink" title="线程生命周期(状态)"></a>线程生命周期(状态)</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU 独自运行，所以CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-lifecycle.jpg" alt="Thread lifecycle"></p>
<h3 id="新建状态-new"><a href="#新建状态-new" class="headerlink" title="新建状态(new)"></a>新建状态(new)</h3><p>当程序使用new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM 为其分配内存，并初始化其成员变量的值</p>
<h3 id="就绪状态-runnable"><a href="#就绪状态-runnable" class="headerlink" title="就绪状态(runnable)"></a>就绪状态(runnable)</h3><p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<h3 id="运行状态-running"><a href="#运行状态-running" class="headerlink" title="运行状态(running)"></a>运行状态(running)</h3><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。</p>
<h3 id="阻塞状态-blocked"><a href="#阻塞状态-blocked" class="headerlink" title="阻塞状态(blocked)"></a>阻塞状态(blocked)</h3><p>阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：<br><strong>等待阻塞(o.wait-&gt;等待队列)</strong><br>运行(running)的线程执行o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。<br><strong>同步阻塞(lock-&gt;锁池)</strong><br>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM 会把该线程放入锁池(lock pool)中。<br><strong>其他阻塞(sleep/join)</strong><br>运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O 请求时，JVM 会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<h3 id="线程死亡-dead"><a href="#线程死亡-dead" class="headerlink" title="线程死亡(dead)"></a>线程死亡(dead)</h3><p>线程会以下面三种方式结束，结束后就是死亡状态。<br><strong>正常结束</strong><br>1.run()或call()方法执行完成，线程正常结束。<br><strong>异常结束</strong><br>2.线程抛出一个未捕获的Exception 或Error。<br><strong>调用stop</strong><br>3.直接调用该线程的stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p>
<h2 id="终止线程的4种方式"><a href="#终止线程的4种方式" class="headerlink" title="终止线程的4种方式"></a>终止线程的4种方式</h2><h3 id="正常运行结束"><a href="#正常运行结束" class="headerlink" title="正常运行结束"></a>正常运行结束</h3><p>程序运行结束，线程自动结束。</p>
<h3 id="使用退出标志退出线程"><a href="#使用退出标志退出线程" class="headerlink" title="使用退出标志退出线程"></a>使用退出标志退出线程</h3><p>一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean 类型的标志，并通过设置这个标志为true 或false 来控制while循环是否退出，代码示例：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadSafe extends Thread &#123;</span><br><span class="line">  public volatile boolean <span class="keyword">exit</span> = false;</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">exit</span>) &#123;</span><br><span class="line">      <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个退出标志exit，当exit 为true 时，while 循环退出，exit 的默认值为false.在定义exit时，使用了一个Java 关键字volatile，这个关键字的目的是使exit 同步，也就是说在同一时刻只能由一个线程来修改exit 的值。</p>
<h3 id="Interrupt方法结束线程"><a href="#Interrupt方法结束线程" class="headerlink" title="Interrupt方法结束线程"></a>Interrupt方法结束线程</h3><p>使用interrupt()方法来中断线程有两种情况：<br><strong>1. 线程处于阻塞状态</strong><br>如使用了sleep,同步锁的wait,socket 中的receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用interrupt 方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException 异常之后通过break 来跳出循环，才能正常结束run 方法。<br><strong>2. 线程未处于阻塞状态</strong><br>使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="comment">// 非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞过程捕获中断异常来退出</span></span><br><span class="line">                <span class="type">Thread</span>.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">InterruptedException</span> e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 捕获到异常之后，执行break 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="stop方法终止线程-线程不安全）"><a href="#stop方法终止线程-线程不安全）" class="headerlink" title="stop方法终止线程(线程不安全）"></a>stop方法终止线程(线程不安全）</h3><p>程序中可以直接使用thread.stop()来强行终止线程，但是stop 方法是很危险的，就像突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop 方法来终止线程。</p>
<h2 id="sleep与wait区别"><a href="#sleep与wait区别" class="headerlink" title="sleep与wait区别"></a>sleep与wait区别</h2><ol>
<li>对于sleep()方法，我们首先要知道该方法是属于Thread 类中的。而wait()方法，则是属于<br>Object 类中的。</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然<br>保持者，当指定的时间到了又会自动恢复运行状态。</li>
<li>在调用sleep()方法的过程中，线程不会释放对象锁。</li>
<li>而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
</ol>
<h2 id="start与run区别"><a href="#start与run区别" class="headerlink" title="start与run区别"></a>start与run区别</h2><ol>
<li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待run 方法体代码执行完毕，<br>可以直接继续执行下面的代码。</li>
<li>通过调用Thread 类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运<br>行，需要有可用的CPU资源才运行。</li>
<li>方法run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运<br>行run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后CPU 再调度其它线程。</li>
</ol>
<h2 id="Java后台线程"><a href="#Java后台线程" class="headerlink" title="Java后台线程"></a>Java后台线程</h2><ol>
<li>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。</li>
<li>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</li>
<li>设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的setDaemon 方法。</li>
<li>在Daemon 线程中产生的新线程也是Daemon 的。</li>
<li>线程则是JVM 级别的，以Tomcat 为例，如果你在Web 应用中启动一个线程，这个线程的生命周期并不会和Web 应用程序保持同步。也就是说，即使你停止了Web 应用，这个线程依旧是活跃的。</li>
<li>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</li>
<li>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则JVM 不会退出。  </li>
</ol>
<h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。<br>java 中的乐观锁基本都是通过CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。  </p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block 直到拿到锁。<br>java 中的悲观锁就是Synchronized,AQS 框架下的锁则是先尝试cas 乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<br>线程自旋是需要消耗cup 的，说白了就是让cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。<br><strong>自旋锁的优缺点</strong><br>自旋锁尽可能的减少线程的阻塞，这对于<code>锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升</code>，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！<br>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu 做无用功，占着XX 不XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup 的线程又不能获取到cpu，造成cpu 的浪费。所以这种情况下我们要关闭自旋锁；<br><code>自旋锁时间阀值(1.6引入量适应性自旋锁)</code><br>自旋锁的目的是为了占着CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！<br>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM 还针对当前CPU 的负荷情况做了较多的优化，如果平均负载小于CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果CPU 处于节电模式则停止自旋，自旋时间的最坏情况是CPU的存储延迟（CPU A 存储了一个数据，到CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。<br><code>自旋锁的开启</code><br>JDK1.6 中-XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数；<br>JDK1.7 后，去掉此参数，由jvm 控制；</p>
<h3 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a>synchronized同步锁</h3><p>synchronized 它可以把任意一个非NULL 的对象当作锁。他属于独占式的悲观锁、非公平锁，同时属于可重入锁。<br><strong>Synchronized 作用范围</strong>  </p>
<ol>
<li>作用于方法时，锁住的是当前对象的实例(this)；</li>
<li>当作用于静态方法时，锁住的是Class 实例，又因为Class 的相关数据存储在永久代PermGen<br>（jdk1.8 则是metaspace），永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，<br>会锁所有调用该方法的线程；</li>
<li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，<br>当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</li>
</ol>
<p><strong>Synchronized 核心组件</strong>  </p>
<ol>
<li>Wait Set：哪些调用wait 方法被阻塞的线程被放置在这里；</li>
<li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li>
<li>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到Entry List 中；</li>
<li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck；</li>
<li>Owner：当前已经获取到锁资源的线程被称为Owner；</li>
<li>!Owner：当前释放锁的线程。  </li>
</ol>
<p><strong>Synchronized 实现</strong><br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/synchronized-principle.jpg" alt="Synchronized Principle"></p>
<ol>
<li>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行CAS 访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList 中作为候选竞争线程。</li>
<li>Owner 线程会在unlock 时，将ContentionList 中的部分线程迁移到EntryList 中，并指定EntryList 中的某个线程为OnDeck 线程（一般是最先进去的那个线程）。</li>
<li>Owner 线程并不直接把锁传递给OnDeck 线程，而是把锁竞争的权利交给OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</li>
<li>OnDeck 线程获取到锁资源后会变为Owner 线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner 线程被wait 方法阻塞，则转移到WaitSet 队列中，直到某个时刻通过notify或者notifyAll 唤醒，会重新进去EntryList 中。</li>
<li>处于ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用pthread_mutex_lock 内核函数实现的）。</li>
<li>Synchronized 是非公平锁。 Synchronized 在线程进入ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck 线程的锁资源。</li>
<li>每个对象都有个monitor 对象，加锁就是在竞争monitor 对象，代码块加锁是在前后分别加上monitorenter 和monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</li>
<li>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</li>
<li>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的Java1.7 与1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</li>
<li>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</li>
<li>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</li>
</ol>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentantLock 继承接口Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。<br><strong>Lock 接口的主要方法</strong>  </p>
<ol>
<li>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.  </li>
<li>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回true, 否则返回false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.  </li>
<li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.  </li>
<li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。  </li>
<li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock 方法的次数。  </li>
<li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动10 个线程，1 个线程获得锁，此时返回的是9  </li>
<li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程计数。比如10 个线程，用同一个condition 对象，并且此时这10 个线程都执行了condition 对的await 方法，那么此时执行此方法返回10  </li>
<li>hasWaiters(Condition condition) ： 查询是否有线程等待与此锁有关的给定条件(condition)，对于指定contidion 对象，有多少线程执行了condition.await 方法  </li>
<li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁  </li>
<li>hasQueuedThreads()：是否有线程等待此锁  </li>
<li>isFair()：该锁是否公平锁  </li>
<li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行lock 方法的前后分别是false 和true  </li>
<li>isLock()：此锁是否有任意线程占用  </li>
<li>lockInterruptibly（）：如果当前线程未被中断，获取锁  </li>
<li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁  </li>
<li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。  </li>
</ol>
<p><strong>非公平锁</strong><br>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。<br><strong>公平锁</strong><br>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。<br><strong>ReentrantLock 与 synchronized</strong>  </p>
<ol>
<li>ReentrantLock 通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized 会被JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock 必须在finally 控制块中进行解锁操作。</li>
<li>ReentrantLock 相比synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用ReentrantLock。</li>
</ol>
<p><strong>ReentrantLock</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// lock 加锁</span></span><br><span class="line">            <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">            <span class="comment">// 1：wait 方法等待：</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过创建Condition 对象来使线程wait，必须先执行lock.lock 方法获得锁</span></span><br><span class="line">            condition.<span class="keyword">await</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2：condition 对象的signal 方法可以唤醒wait 线程</span></span><br><span class="line">            condition.signal();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName() + (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Condition 类和 Object 类锁方法区别</strong>  </p>
<ol>
<li>Condition 类的awiat 方法和Object 类的wait 方法等效</li>
<li>Condition 类的signal 方法和Object 类的notify 方法等效</li>
<li>Condition 类的signalAll 方法和Object 类的notifyAll 方法等效</li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而object 的唤醒是随机的</li>
</ol>
<p><strong>tryLock 和 lock 和 lockInterruptibly 的区别</strong>  </p>
<ol>
<li>tryLock 能获得锁就返回true，不能就立即返回false，tryLock(long timeout,TimeUnitunit)，可以增加时间限制，如果超过该时间段还没获得锁，返回false</li>
<li>lock 能获得锁就返回true，不能的话一直等待获得锁</li>
<li>lock 和lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而lockInterruptibly 会抛出异常。</li>
</ol>
<h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池<br><strong>实现互斥锁(计数器为1)</strong><br>我们也可以创建计数为1 的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。<br>它的用法如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个计数阈值为5 的信号量对象</span></span><br><span class="line">        <span class="comment">// 只能5 个线程同时访问</span></span><br><span class="line">        Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 申请许可</span></span><br><span class="line">            semp.acquire();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 业务逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放许可</span></span><br><span class="line">                semp.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Semaphore 与 ReentrantLock</strong><br>Semaphore 基本能完成ReentrantLock 的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。<br>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire 与tryLock不同，其使用方法与ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。<br>Semaphore 的锁释放操作也由手动进行，因此与ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally 代码块中完成。</p>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><p>首先说明， 此处AtomicInteger ， 一个提供原子操作的Integer 的类， 常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过AtomicReference<v>将一个对象的所有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized 将该操作变成一个原子操作，但JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock 的好几倍。</v></p>
<h3 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h3><p>本文里面讲的是广义上的可重入锁，而不是单指JAVA 下的ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA 环境下 ReentrantLock 和synchronized 都是 可重入锁。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p><strong>公平锁(Fair)</strong><br>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br><strong>非公平锁(Nonfair)</strong><br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待  </p>
<ol>
<li>非公平锁性能比公平锁高5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li>
<li>Java 中的synchronized 是非公平锁，ReentrantLock 默认的lock()方法采用的是非公平锁。</li>
</ol>
<h3 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h3><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm 自己控制的，你只要上好相应的锁即可。<br><strong>读锁</strong><br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁<br><strong>写锁</strong><br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！<br>Java 中读写锁有个接口java.util.concurrent.locks.ReadWriteLock ， 也有具体的实现ReentrantReadWriteLock。  </p>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>java 并发包提供的加锁模式分为独占锁和共享锁。<br><strong>独占锁</strong><br>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。<br><strong>共享锁</strong><br>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li>AQS 的内部类Node 定义了两个常量SHARED 和EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li>
<li>java 的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li>
</ol>
<h3 id="重量级锁-Mutex-Lock"><a href="#重量级锁-Mutex-Lock" class="headerlink" title="重量级锁(Mutex Lock)"></a>重量级锁(Mutex Lock)</h3><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br><strong>锁升级</strong><br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。  </p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁也并非一种实际的锁，而是一种思想ConcurrentHashMap 是学习分段锁的最好实践</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p><strong>减少持有时间</strong><br>只用在有线程安全要求的程序上加锁<br><strong>减小粒度</strong><br>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。<br><strong>锁分离</strong><br>最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发Java 五]JDK 并发包1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据<br><strong>锁粗化</strong><br>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。<br><strong>锁消除</strong><br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p>
<h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p>线程相关的基本方法有wait，notify，notifyAll，sleep，join，yield 等。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-method.jpg" alt="Thread Method"></p>
<h3 id="线程等待-wait"><a href="#线程等待-wait" class="headerlink" title="线程等待(wait)"></a>线程等待(wait)</h3><p>调用该方法的线程进入WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。</p>
<h3 id="线程睡眠-sleep"><a href="#线程睡眠-sleep" class="headerlink" title="线程睡眠(sleep)"></a>线程睡眠(sleep)</h3><p>sleep 导致当前线程休眠，与wait 方法不同的是sleep 不会释放当前占有的锁,sleep(long)会导致线程进入TIMED-WATING 状态，而wait()方法会导致当前线程进入WATING 状态</p>
<h3 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步(yield)"></a>线程让步(yield)</h3><p>yield 会使当前线程让出CPU 执行时间片，与其他线程一起重新竞争CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p>
<h3 id="线程中断-interrupt"><a href="#线程中断-interrupt" class="headerlink" title="线程中断(interrupt)"></a>线程中断(interrupt)</h3><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。</p>
<ol>
<li>调用interrupt()方法并不会中断一个正在运行的线程。也就是说处于Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</li>
<li>若调用sleep()而使线程处于TIMED-WATING 状态，这时调用interrupt()方法，会抛出InterruptedException,从而使线程提前结束TIMED-WATING 状态。</li>
<li>许多声明抛出InterruptedException 的方法(如Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用isInterrupted()方法将会返回false。</li>
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread 的时候，可以调用thread.interrupt()方法，在线程的run 方法内部可以根据thread.isInterrupted()的值来优雅的终止线程。</li>
</ol>
<h3 id="join等待其他线程终止"><a href="#join等待其他线程终止" class="headerlink" title="join等待其他线程终止"></a>join等待其他线程终止</h3><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p>
<h3 id="为什么要用join-方法"><a href="#为什么要用join-方法" class="headerlink" title="为什么要用join()方法"></a>为什么要用join()方法</h3><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">Thread</span>.currentThread().getName() + <span class="string">"线程运行开始!"</span>);</span><br><span class="line"><span class="keyword">Thread</span> thread1 = <span class="literal">new</span> <span class="keyword">Thread</span>();</span><br><span class="line">thread1.setName(<span class="string">"线程B"</span>);</span><br><span class="line">thread1.<span class="keyword">join</span>();</span><br><span class="line">System.out.println(<span class="string">"这时thread1 执行完毕之后才能执行主线程"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="线程唤醒-notify"><a href="#线程唤醒-notify" class="headerlink" title="线程唤醒(notify)"></a>线程唤醒(notify)</h3><p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ol>
<li>sleep()：强迫一个线程睡眠Ｎ毫秒。</li>
<li>isAlive()： 判断一个线程是否存活。</li>
<li>join()： 等待线程终止。</li>
<li>activeCount()： 程序中活跃的线程数。</li>
<li>enumerate()： 枚举程序中的线程。</li>
<li>currentThread()： 得到当前线程。</li>
<li>isDaemon()： 一个线程是否为守护线程。</li>
<li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线<br>程依赖于主线程结束而结束)</li>
<li>setName()： 为线程设置一个名称。</li>
<li>wait()： 强迫一个线程等待。</li>
<li>notify()： 通知一个线程继续运行。</li>
<li>setPriority()： 设置一个线程的优先级。</li>
<li>getPriority():：获得一个线程的优先级。</li>
</ol>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗CPU 上执行变成了可能。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-context-switch.jpg" alt="Thread-Context-Switch"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>（有时候也称做任务）是指一个程序运行的实例。在Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。</p>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>是指某一时间点 CPU 寄存器和程序计数器的内容。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p>
<h3 id="PCB-“切换帧”"><a href="#PCB-“切换帧”" class="headerlink" title="PCB-“切换帧”"></a>PCB-“切换帧”</h3><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到CPU 的内存中，直到他们被再次使用。</p>
<h3 id="上下文切换的活动"><a href="#上下文切换的活动" class="headerlink" title="上下文切换的活动"></a>上下文切换的活动</h3><ol>
<li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</li>
<li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</li>
<li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序<br>中。</li>
</ol>
<h3 id="引起线程上下文切换的原因"><a href="#引起线程上下文切换的原因" class="headerlink" title="引起线程上下文切换的原因"></a>引起线程上下文切换的原因</h3><ol>
<li>当前执行任务的时间片用完之后，系统CPU 正常调度下一个任务；</li>
<li>当前执行任务碰到IO 阻塞，调度器将此任务挂起，继续下一任务；</li>
<li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</li>
<li>用户代码挂起当前任务，让出CPU 时间；</li>
<li>硬件中断；</li>
</ol>
<h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用synchronized 关键字来取得一个对象的同步锁。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Shado</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017-06-03 14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method1"</span> + <span class="string">"\t lock o1"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method1"</span> + <span class="string">"\t lock o2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method2"</span> + <span class="string">"\t lock o2"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + <span class="string">"method2"</span> + <span class="string">"\t lock o1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock deadLock1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock deadLock2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line"></span><br><span class="line">        deadLock1.flag = <span class="number">1</span>;</span><br><span class="line">        deadLock2.flag = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(deadLock1,<span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(deadLock2, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>执行结果，程序不终止，输出内容如下:</code><br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread1	method1	 <span class="keyword">lock</span> o1</span><br><span class="line">thread2	method2	 <span class="keyword">lock</span> o2</span><br></pre></td></tr></table></figure></p>
<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。</p>
<h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h3><p>每一个 Thread 的类都有一个 start 方法。 当调用start 启动线程时Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。</p>
<h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><p>一般的线程池主要分为以下4 个组成部分：</p>
<ol>
<li>线程池管理器：用于创建并管理线程池</li>
<li>工作线程：线程池中的线程</li>
<li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li>
<li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li>
</ol>
<p>Java 中的线程池是通过Executor 框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和Future、FutureTask 这几个类。</p>
<p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-pool.jpg" alt="Thread-Pool"></p>
<p>ThreadPoolExecutor的构造方法如下:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment"> * parameters, the default thread factory and the default rejected</span></span><br><span class="line"><span class="comment"> * execution handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It may be more convenient to use one of the &#123;<span class="doctag">@link</span> Executors&#125;</span></span><br><span class="line"><span class="comment"> * factory methods instead of this general purpose constructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment"> *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment"> *        pool</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment"> *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment"> *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment"> *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment"> *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>corePoolSize：指定了线程池中的线程数量。</li>
<li>maximumPoolSize：指定了线程池中的最大线程数量。</li>
<li>keepAliveTime：当前线程池数量超过corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li>
<li>unit：keepAliveTime 的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。</li>
</ol>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。<br>JDK 内置的拒绝策略如下：</p>
<ol>
<li>AbortPolicy ： 直接抛出异常，阻止系统正常运行。</li>
<li>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>
<li>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</li>
</ol>
<p>以上内置拒绝策略均实现了RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展RejectedExecutionHandler 接口。</p>
<h3 id="Java-线程池工作过程"><a href="#Java-线程池工作过程" class="headerlink" title="Java 线程池工作过程"></a>Java 线程池工作过程</h3><ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面<br>有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
<p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-pool-process.jpg" alt="Thread-Pool-Process"></p>
<h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：  </p>
<ol>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-1.jpg" alt="BlockingQueue"></li>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-2.jpg" alt="BlockingQueue"><h3 id="阻塞队列的主要方法"><a href="#阻塞队列的主要方法" class="headerlink" title="阻塞队列的主要方法"></a>阻塞队列的主要方法</h3><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-3.jpg" alt="BlockingQueue"></li>
</ol>
<ul>
<li>抛出异常：抛出一个异常；</li>
<li>特殊值：返回一个特殊值（null 或false,视情况而定）</li>
<li>则塞：在成功操作之前，一直阻塞线程</li>
<li>超时：放弃前只在最大的时间内阻塞</li>
</ul>
<p><strong>插入操作:</strong>  </p>
<ol>
<li>public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是NULL，则会抛出NullPointerException 异常。</li>
<li>public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。</li>
<li>public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</li>
<li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间<br>内，还不能往队列中加入BlockingQueue，则返回失败。</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment"> * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取数据操作:</strong>  </p>
<ol>
<li>poll(time):取走BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time 参数<br>规定的时间,取不到时返回null;</li>
<li>poll(long timeout, TimeUnit unit)：从BlockingQueue 取出一个队首的对象，如果在<br>指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数<br>据可取，返回失败。</li>
<li>take():取走BlockingQueue 里排在首位的对象,若BlockingQueue 为空,阻断进入等待状<br>态直到BlockingQueue 有新的数据被加入。</li>
<li>drainTo():一次性从BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个<br>数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li>
</ol>
<h3 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h3><ol>
<li>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</li>
</ol>
<p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/blocking-queue-class.jpg" alt="BlockingQueue"></p>
<h3 id="ArrayBlockingQueue（公平、非公平）"><a href="#ArrayBlockingQueue（公平、非公平）" class="headerlink" title="ArrayBlockingQueue（公平、非公平）"></a>ArrayBlockingQueue（公平、非公平）</h3><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>(<span class="number">1000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="LinkedBlockingQueue（两个独立锁提高并发）"><a href="#LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="LinkedBlockingQueue（两个独立锁提高并发）"></a>LinkedBlockingQueue（两个独立锁提高并发）</h3><p>基于链表的阻塞队列，同ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p>
<h3 id="PriorityBlockingQueue（compareTo-排序实现优先）"><a href="#PriorityBlockingQueue（compareTo-排序实现优先）" class="headerlink" title="PriorityBlockingQueue（compareTo 排序实现优先）"></a>PriorityBlockingQueue（compareTo 排序实现优先）</h3><p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化PriorityBlockingQueue 时，指定构造参数Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h3 id="DelayQueue（缓存失效、定时任务-）"><a href="#DelayQueue（缓存失效、定时任务-）" class="headerlink" title="DelayQueue（缓存失效、定时任务 ）"></a>DelayQueue（缓存失效、定时任务 ）</h3><p>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue 来实现。队列中的元素必须实现Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue 运用在以下应用场景：</p>
<ol>
<li>缓存系统的设计：可以用DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue 中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度： 使用DelayQueue 保存当天将会执行的任务和执行时间， 一旦从DelayQueue 中获取到任务就开始执行，从比如TimerQueue 就是使用DelayQueue 实现的。</li>
</ol>
<h3 id="SynchronousQueue（不存储数据、可用于传递数据）"><a href="#SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="SynchronousQueue（不存储数据、可用于传递数据）"></a>SynchronousQueue（不存储数据、可用于传递数据）</h3><p>是一个不存储元素的阻塞队列。每一个put 操作必须等待一个take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用， SynchronousQueue 的吞吐量高于LinkedBlockingQueue 和ArrayBlockingQueue。</p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>是一个由链表结构组成的无界阻塞TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了tryTransfer 和transfer 方法。</p>
<ol>
<li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的tail 节点，并等到该元素被消费者消费了才返回。</li>
<li>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer 方法的区别是tryTransfer 方法无论消费者是否接收，方法立即返回。而transfer 方法是必须等到消费者消费了才返回。</li>
</ol>
<p>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列， LinkedBlockingDeque 多了addFirst ， addLast ， offerFirst ， offerLast ，peekFirst，peekLast 等方法，以First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add 等同于addLast，移除方法remove 等效于removeFirst。但是take 方法却等同于takeFirst，不知道是不是Jdk 的bug，使用时还是用带有First 和Last 后缀的方法更清楚。在初始化LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>
<h2 id="CyclicBarrier、CountDownLatch、Semaphore的用法"><a href="#CyclicBarrier、CountDownLatch、Semaphore的用法" class="headerlink" title="CyclicBarrier、CountDownLatch、Semaphore的用法"></a>CyclicBarrier、CountDownLatch、Semaphore的用法</h2><h3 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h3><p>CountDownLatch 类位于java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4 个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    final CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"正在执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"正在执行"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"等待2 个子线程执行完毕..."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"2 个子线程已经执行完毕"</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier（回环栅栏-等待至barrier-状态再全部同时执行）"><a href="#CyclicBarrier（回环栅栏-等待至barrier-状态再全部同时执行）" class="headerlink" title="CyclicBarrier（回环栅栏-等待至barrier 状态再全部同时执行）"></a>CyclicBarrier（回环栅栏-等待至barrier 状态再全部同时执行）</h3><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier 了。<br>CyclicBarrier 中最重要的方法就是await 方法，它有2 个重载版本：</p>
<ol>
<li>public int await()：用来挂起当前线程，直至所有线程都到达barrier 状态再同时执行后续任务。</li>
<li>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达barrier 状态就直接让到达barrier 的线程执行后续任务。<br>具体使用如下，另外CyclicBarrier 是可以重用的。<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Writer</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span>(<span class="params">CyclicBarrier cyclicBarrier</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟线程写入数据操作</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">" 线程"</span> + Thread.currentThread().getName() + <span class="string">"写入数据完毕,等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.<span class="keyword">await</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"所有线程写入完毕，继续处理其他任务，比如数据操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Semaphore（信号量-控制同时访问的线程个数）"><a href="#Semaphore（信号量-控制同时访问的线程个数）" class="headerlink" title="Semaphore（信号量-控制同时访问的线程个数）"></a>Semaphore（信号量-控制同时访问的线程个数）</h3><p>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>Semaphore 类中比较重要的几个方法：</p>
<ol>
<li>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</li>
<li>public void acquire(int permits):获取permits 个许可</li>
<li>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。</li>
<li>public void release(int permits) { }:释放permits 个许可上面4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法</li>
<li>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</li>
<li>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</li>
<li>public boolean tryAcquire(int permits):尝试获取permits 个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</li>
<li>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</li>
<li>还可以通过availablePermits()方法得到可用的许可数目。<br>例子：若一个工厂有5 台机器，但是有8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore 来实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工人数</span></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// 机器数目</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>CountDownLatch 和CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程A 等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而CyclicBarrier 是可以重用的。</li>
<li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。<h2 id="volatile关键字的作用-变量可见性、禁止重排序"><a href="#volatile关键字的作用-变量可见性、禁止重排序" class="headerlink" title="volatile关键字的作用(变量可见性、禁止重排序)"></a>volatile关键字的作用(变量可见性、禁止重排序)</h2>Java 语言提供了一种稍弱的同步机制，即volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile 类型的变量时总会返回最新写入的值。<br><strong>变量可见性</strong><br>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。<br><strong>禁止重排序</strong><br>volatile 禁止了指令重排。<br><code>比 synchronized 更轻量级</code><br><code>在访问volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile 变量是一种比synchronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。</code><br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/volatile.jpg" alt="volatile"><br>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU 缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPUcache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache这一步。<br><strong>适用场景</strong><br>值得说明的是对volatile 变量的单次读/写操作可以保证原子性的，如long 和double 类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。在某些场景下可以代替Synchronized。但是,volatile 的不能完全取代Synchronized 的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<br>（1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。<br>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。  <h2 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据"></a>如何在两个线程之间共享数据</h2>Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法：<br><strong>将数据抽象成一个类，并将数据的操作作为这个类的方法</strong>  </li>
</ul>
<ol>
<li>将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到<br>同步，只要在方法上加”synchronized“</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable <span class="keyword">add</span> = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">add</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">dec</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AddRunnable(MyData <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">data</span>.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DecRunnable(MyData <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">data</span>.dec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Runnable 对象作为一个类的内部类</strong>  </p>
<ol start="2">
<li>将Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable 对象调用外部类的这些方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br><strong>ThreadLocalMap(线程的一个属性)</strong>  </p>
<ol>
<li>每个线程中都有一个自己的ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，<br>各管各的，线程可以正确的访问到自己的对象。  </li>
<li>将一个共用的ThreadLocal 静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态ThreadLocal 实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li>
<li>ThreadLocalMap 其实就是线程里面的一个属性，它在Thread 类中定义<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap <span class="attr">threadLocals</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-local.jpg" alt="Thread-Local"><br><strong>适用场景</strong><br>最常见的ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal threadSession = <span class="keyword">new</span> <span class="type">ThreadLocal</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Session getSession() throws InfrastructureException &#123;</span><br><span class="line">        Session s = (Session) threadSession.<span class="keyword">get</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">                s = getSessionFactory().openSession();</span><br><span class="line">                threadSession.<span class="keyword">set</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InfrastructureException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="synchronized和reentrantLock的区别"><a href="#synchronized和reentrantLock的区别" class="headerlink" title="synchronized和reentrantLock的区别"></a>synchronized和reentrantLock的区别</h2><h3 id="两者的共同点："><a href="#两者的共同点：" class="headerlink" title="两者的共同点："></a>两者的共同点：</h3><ol>
<li>都是用来协调多线程对共享对象、变量的访问</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁</li>
<li>都保证了可见性和互斥性</li>
</ol>
<h3 id="两者的不同点："><a href="#两者的不同点：" class="headerlink" title="两者的不同点："></a>两者的不同点：</h3><ol>
<li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li>
<li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li>
<li>ReentrantLock 是API 级别的，synchronized 是JVM级别的</li>
<li>ReentrantLock 可以实现公平锁</li>
<li>ReentrantLock 通过Condition 可以绑定多个条件</li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</li>
<li>Lock 是一个接口，而synchronized 是Java 中的关键字，synchronized 是内置的语言实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock 在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock 时需要在finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断，而synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过Lock 可以知道有没有成功获取锁，而synchronized 却无法办到。</li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li>
</ol>
<h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h3 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><p>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是ConcurrentHashMap(高性能的HashMap)类的实现。对于HashMap 而言，最重要的两个方法是get 与set 方法，如果我们对整个HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为ConcurrentHashMap 的并发度。</p>
<h3 id="ConcurrentHashMap-分段锁"><a href="#ConcurrentHashMap-分段锁" class="headerlink" title="ConcurrentHashMap 分段锁"></a>ConcurrentHashMap 分段锁</h3><p>ConcurrentHashMap，它内部细分了若干个小的HashMap，称之为段(Segment)。默认情况下一个ConcurrentHashMap 被进一步细分为16 个段，既就是锁的并发度。<br>如果需要在ConcurrentHashMap 中添加一个新的表项，并不是将整个HashMap 加锁，而是首先根据hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成put 操作。在多线程环境中，如果多个线程同时进行put 操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</p>
<p><strong>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</strong><br>ConcurrentHashMap 是由Segment 数组结构和HashEntry 数组结构组成。Segment 是一种可重入锁ReentrantLock，在ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个ConcurrentHashMap 里包含一个Segment 数组，Segment 的结构和HashMap类似，是一种数组和链表结构， 一个Segment 里包含一个HashEntry 数组，每个HashEntry 是一个链表结构的元素， 每个Segment 守护一个HashEntry 数组里的元素,当对HashEntry 数组的数据进行修改时，必须首先获得它对应的Segment 锁。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/segment.jpg" alt="Segment"></p>
<h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h3 id="抢占式调度："><a href="#抢占式调度：" class="headerlink" title="抢占式调度："></a>抢占式调度：</h3><p>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p>
<h3 id="协同式调度："><a href="#协同式调度：" class="headerlink" title="协同式调度："></a>协同式调度：</h3><p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p>
<p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-scheduling.jpg" alt="Thread Scheduling"></p>
<h3 id="JVM-的线程调度实现（抢占式调度）"><a href="#JVM-的线程调度实现（抢占式调度）" class="headerlink" title="JVM 的线程调度实现（抢占式调度）"></a>JVM 的线程调度实现（抢占式调度）</h3><p>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p>
<h3 id="线程让出cpu-的情况："><a href="#线程让出cpu-的情况：" class="headerlink" title="线程让出cpu 的情况："></a>线程让出cpu 的情况：</h3><ol>
<li>当前运行线程主动放弃CPU，JVM 暂时放弃CPU 操作（基于时间片轮转调度的JVM 操作系<br>统不会让线程永久放弃CPU，或者说放弃本次时间片的执行权），例如调用yield()方法。</li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在I/O 上。</li>
<li>当前运行线程结束，即运行完run()方法里面的任务。</li>
</ol>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h3><p><strong>1. 先来先服务调度算法（FCFS）</strong><br>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。<br><strong>2. 短作业(进程)优先调度算法</strong><br>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p>
<h3 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h3><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。<br><strong>1. 非抢占式优先权算法</strong><br>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。<br><strong>2. 抢占式优先权调度算法</strong><br>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。<br><strong>3. 高响应比优先调度算法</strong><br>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p>
<p><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/thread-scheduling-2.jpg" alt="Thread Scheduling"><br>(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。<br>(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。<br>(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p>
<h3 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h3><p><strong>1. 时间片轮转法</strong><br>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。<br><strong>2. 多级反馈队列调度算法</strong><br>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1 个队列的时间片要比第i 个队列的时间片长一倍。<br>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n 队列后，在第n 队列便采取按时间片轮转的方式运行。<br>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i 队列中的进程运行。如果处理机正在第i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p>
<h2 id="什么是CAS-乐观锁-自旋锁-比较并交换-compare-and-swap"><a href="#什么是CAS-乐观锁-自旋锁-比较并交换-compare-and-swap" class="headerlink" title="什么是CAS(乐观锁-自旋锁-比较并交换 compare and swap)"></a>什么是CAS(乐观锁-自旋锁-比较并交换 compare and swap)</h2><h3 id="概念及特性"><a href="#概念及特性" class="headerlink" title="概念及特性"></a>概念及特性</h3><p>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当V 值等于E 值时，才会将V 的值设为N，如果V 值和E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前V 的真实值。<br>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p>
<h3 id="原子包-java-util-concurrent-atomic（锁自旋）"><a href="#原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="原子包 java.util.concurrent.atomic（锁自旋）"></a>原子包 java.util.concurrent.atomic（锁自旋）</h3><p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般CPU 切换时间比CPU 指令集操作更加长， 所以J.U.C 在性能上有了很大的提升。如下代码：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getAndIncrement 采用了CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行CAS 操作，如果成功就返回结果，否则重试直到成功为止。而compareAndSet 利用JNI 来完成CPU 指令的操作。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmpxchg</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * accumulator = AL,AX,or EAX,depending on whether</span></span><br><span class="line"><span class="comment"> * a byte,word,or doubleword comparison is being performed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> // 更新的变量和旧的预期值是否相等</span><br><span class="line"> <span class="keyword">if</span>(<span class="attr">accumulator</span> == Destination) &#123;</span><br><span class="line">   // 设置跳转标识</span><br><span class="line">   <span class="attr">ZF</span> = <span class="number">1</span>;</span><br><span class="line">   <span class="attr">Destination</span> = Source;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   // 不设置值类</span><br><span class="line">   <span class="attr">ZF</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="attr">accumulator</span> = Destination;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。<br>比如说一个线程one 从内存位置V 中取出A，这时候另一个线程two 也从内存中取出A，并且two 进行了一些操作变成了B，然后two 又将V 位置的数据变成A，这时候线程one 进行CAS 操作发现内存中仍然是A，然后one 操作成功。尽管线程one 的CAS 操作成功，但是不代表这个过程就是没有问题的。<br>部分乐观锁的实现是通过版本号（version）的方式来解决ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA 问题，因为版本号只会增加不会减少。</p>
<h2 id="什么是AQS-抽象的队列同步器AbstractQueuedSynchronizer"><a href="#什么是AQS-抽象的队列同步器AbstractQueuedSynchronizer" class="headerlink" title="什么是AQS(抽象的队列同步器AbstractQueuedSynchronizer)"></a>什么是AQS(抽象的队列同步器AbstractQueuedSynchronizer)</h2><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。<br><img src="/2019/05/06/2019-05-06-concurrency-and-multithreading/abstract-queued-synchronizer.jpg" alt="AbstractQueuedSynchronizer"><br>它维护了一个volatile int state（代表共享资源）和一个FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile 是核心关键词，具体volatile 的语义，在此不述。state 的访问方式有三种:</p>
<ul>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ul>
<h3 id="AQS-定义两种资源共享方式"><a href="#AQS-定义两种资源共享方式" class="headerlink" title="AQS 定义两种资源共享方式"></a>AQS 定义两种资源共享方式</h3><p><strong>Exclusive 独占资源-ReentrantLock</strong><br>Exclusive（独占，只有一个线程能执行，如ReentrantLock）<br><strong>Share 共享资源-Semaphore/CountDownLatch</strong><br>Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。<br>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state 的get/set/CAS)之所以没有定义成abstract ， 是因为独占模式下只用实现tryAcquire-tryRelease ， 而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition 才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余<br>可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回<br>true，否则返回false。</li>
</ol>
<p><code>同步器的实现是ABS核心(state资源状态计数)</code><br>同步器的实现是ABS 核心，以ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A 线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state 是能回到零态的。<br>以CountDownLatch 以例，任务分为N 个子线程去执行，state 也初始化为N（注意N 要与线程个数一致）。这N 个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS 减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p><code>ReentrantReadWriteLock 实现独占和共享两种方式</code><br>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但AQS 也支持自定义同步器,同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
            <a href="/tags/并发/" rel="tag"># 并发</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/16/2019-04-16-message-queue/" rel="next" title="消息中间件MQ总结">
                <i class="fa fa-chevron-left"></i> 消息中间件MQ总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Shado Fung">
            
              <p class="site-author-name" itemprop="name">Shado Fung</p>
              <p class="site-description motion-element" itemprop="description">Java Developer</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ShadoFung" title="GitHub &rarr; https://github.com/ShadoFung" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:ShadoFung@gmail.com" title="E-Mail &rarr; mailto:ShadoFung@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/u/3247997722" title="Weibo &rarr; https://weibo.com/u/3247997722" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/users/10678850/shado-fung" title="StackOverflow &rarr; https://stackoverflow.com/users/10678850/shado-fung" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://docs.oracle.com/javase/tutorial/" title="https://docs.oracle.com/javase/tutorial/" rel="noopener" target="_blank">Oracle Java Tutorial</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://spring.io/guides" title="https://spring.io/guides" rel="noopener" target="_blank">Spring Guides</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java并发知识库"><span class="nav-number">1.</span> <span class="nav-text">Java并发知识库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java线程实现-创建方式"><span class="nav-number">2.</span> <span class="nav-text">Java线程实现/创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Thread类"><span class="nav-number">2.1.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Runnable接口"><span class="nav-number">2.2.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService、Callable、Future有返回值线程"><span class="nav-number">2.3.</span> <span class="nav-text">ExecutorService、Callable、Future有返回值线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于线程池的方式"><span class="nav-number">2.4.</span> <span class="nav-text">基于线程池的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4种线程池"><span class="nav-number">3.</span> <span class="nav-text">4种线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">3.1.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">3.2.</span> <span class="nav-text">newFixedThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">3.3.</span> <span class="nav-text">newScheduledThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">3.4.</span> <span class="nav-text">newSingleThreadExecutor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程生命周期-状态"><span class="nav-number">4.</span> <span class="nav-text">线程生命周期(状态)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新建状态-new"><span class="nav-number">4.1.</span> <span class="nav-text">新建状态(new)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#就绪状态-runnable"><span class="nav-number">4.2.</span> <span class="nav-text">就绪状态(runnable)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行状态-running"><span class="nav-number">4.3.</span> <span class="nav-text">运行状态(running)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞状态-blocked"><span class="nav-number">4.4.</span> <span class="nav-text">阻塞状态(blocked)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程死亡-dead"><span class="nav-number">4.5.</span> <span class="nav-text">线程死亡(dead)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止线程的4种方式"><span class="nav-number">5.</span> <span class="nav-text">终止线程的4种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正常运行结束"><span class="nav-number">5.1.</span> <span class="nav-text">正常运行结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用退出标志退出线程"><span class="nav-number">5.2.</span> <span class="nav-text">使用退出标志退出线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt方法结束线程"><span class="nav-number">5.3.</span> <span class="nav-text">Interrupt方法结束线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stop方法终止线程-线程不安全）"><span class="nav-number">5.4.</span> <span class="nav-text">stop方法终止线程(线程不安全）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep与wait区别"><span class="nav-number">6.</span> <span class="nav-text">sleep与wait区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start与run区别"><span class="nav-number">7.</span> <span class="nav-text">start与run区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java后台线程"><span class="nav-number">8.</span> <span class="nav-text">Java后台线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java锁"><span class="nav-number">9.</span> <span class="nav-text">Java锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁"><span class="nav-number">9.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁"><span class="nav-number">9.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-number">9.3.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized同步锁"><span class="nav-number">9.4.</span> <span class="nav-text">synchronized同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">9.5.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore信号量"><span class="nav-number">9.6.</span> <span class="nav-text">Semaphore信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AtomicInteger"><span class="nav-number">9.7.</span> <span class="nav-text">AtomicInteger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入锁-递归锁"><span class="nav-number">9.8.</span> <span class="nav-text">可重入锁(递归锁)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公平锁与非公平锁"><span class="nav-number">9.9.</span> <span class="nav-text">公平锁与非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock读写锁"><span class="nav-number">9.10.</span> <span class="nav-text">ReadWriteLock读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享锁和独占锁"><span class="nav-number">9.11.</span> <span class="nav-text">共享锁和独占锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁-Mutex-Lock"><span class="nav-number">9.12.</span> <span class="nav-text">重量级锁(Mutex Lock)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-number">9.13.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">9.14.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段锁"><span class="nav-number">9.15.</span> <span class="nav-text">分段锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁优化"><span class="nav-number">9.16.</span> <span class="nav-text">锁优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程基本方法"><span class="nav-number">10.</span> <span class="nav-text">线程基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程等待-wait"><span class="nav-number">10.1.</span> <span class="nav-text">线程等待(wait)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程睡眠-sleep"><span class="nav-number">10.2.</span> <span class="nav-text">线程睡眠(sleep)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程让步-yield"><span class="nav-number">10.3.</span> <span class="nav-text">线程让步(yield)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程中断-interrupt"><span class="nav-number">10.4.</span> <span class="nav-text">线程中断(interrupt)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join等待其他线程终止"><span class="nav-number">10.5.</span> <span class="nav-text">join等待其他线程终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用join-方法"><span class="nav-number">10.6.</span> <span class="nav-text">为什么要用join()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程唤醒-notify"><span class="nav-number">10.7.</span> <span class="nav-text">线程唤醒(notify)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他方法"><span class="nav-number">10.8.</span> <span class="nav-text">其他方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程上下文切换"><span class="nav-number">11.</span> <span class="nav-text">线程上下文切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程"><span class="nav-number">11.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文"><span class="nav-number">11.2.</span> <span class="nav-text">上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器"><span class="nav-number">11.3.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器"><span class="nav-number">11.4.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB-“切换帧”"><span class="nav-number">11.5.</span> <span class="nav-text">PCB-“切换帧”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换的活动"><span class="nav-number">11.6.</span> <span class="nav-text">上下文切换的活动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引起线程上下文切换的原因"><span class="nav-number">11.7.</span> <span class="nav-text">引起线程上下文切换的原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步锁与死锁"><span class="nav-number">12.</span> <span class="nav-text">同步锁与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步锁"><span class="nav-number">12.1.</span> <span class="nav-text">同步锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">12.2.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池原理"><span class="nav-number">13.</span> <span class="nav-text">线程池原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程复用"><span class="nav-number">13.1.</span> <span class="nav-text">线程复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的组成"><span class="nav-number">13.2.</span> <span class="nav-text">线程池的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拒绝策略"><span class="nav-number">13.3.</span> <span class="nav-text">拒绝策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-线程池工作过程"><span class="nav-number">13.4.</span> <span class="nav-text">Java 线程池工作过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java阻塞队列原理"><span class="nav-number">14.</span> <span class="nav-text">Java阻塞队列原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列的主要方法"><span class="nav-number">14.1.</span> <span class="nav-text">阻塞队列的主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的阻塞队列"><span class="nav-number">14.2.</span> <span class="nav-text">Java中的阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue（公平、非公平）"><span class="nav-number">14.3.</span> <span class="nav-text">ArrayBlockingQueue（公平、非公平）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingQueue（两个独立锁提高并发）"><span class="nav-number">14.4.</span> <span class="nav-text">LinkedBlockingQueue（两个独立锁提高并发）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityBlockingQueue（compareTo-排序实现优先）"><span class="nav-number">14.5.</span> <span class="nav-text">PriorityBlockingQueue（compareTo 排序实现优先）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DelayQueue（缓存失效、定时任务-）"><span class="nav-number">14.6.</span> <span class="nav-text">DelayQueue（缓存失效、定时任务 ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SynchronousQueue（不存储数据、可用于传递数据）"><span class="nav-number">14.7.</span> <span class="nav-text">SynchronousQueue（不存储数据、可用于传递数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedTransferQueue"><span class="nav-number">14.8.</span> <span class="nav-text">LinkedTransferQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedBlockingDeque"><span class="nav-number">14.9.</span> <span class="nav-text">LinkedBlockingDeque</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier、CountDownLatch、Semaphore的用法"><span class="nav-number">15.</span> <span class="nav-text">CyclicBarrier、CountDownLatch、Semaphore的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch-线程计数器"><span class="nav-number">15.1.</span> <span class="nav-text">CountDownLatch(线程计数器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier（回环栅栏-等待至barrier-状态再全部同时执行）"><span class="nav-number">15.2.</span> <span class="nav-text">CyclicBarrier（回环栅栏-等待至barrier 状态再全部同时执行）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore（信号量-控制同时访问的线程个数）"><span class="nav-number">15.3.</span> <span class="nav-text">Semaphore（信号量-控制同时访问的线程个数）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile关键字的作用-变量可见性、禁止重排序"><span class="nav-number">16.</span> <span class="nav-text">volatile关键字的作用(变量可见性、禁止重排序)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何在两个线程之间共享数据"><span class="nav-number">17.</span> <span class="nav-text">如何在两个线程之间共享数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal作用-线程本地存储"><span class="nav-number">18.</span> <span class="nav-text">ThreadLocal作用(线程本地存储)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和reentrantLock的区别"><span class="nav-number">19.</span> <span class="nav-text">synchronized和reentrantLock的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两者的共同点："><span class="nav-number">19.1.</span> <span class="nav-text">两者的共同点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两者的不同点："><span class="nav-number">19.2.</span> <span class="nav-text">两者的不同点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap并发"><span class="nav-number">20.</span> <span class="nav-text">ConcurrentHashMap并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#减小锁粒度"><span class="nav-number">20.1.</span> <span class="nav-text">减小锁粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap-分段锁"><span class="nav-number">20.2.</span> <span class="nav-text">ConcurrentHashMap 分段锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中用到的线程调度"><span class="nav-number">21.</span> <span class="nav-text">Java中用到的线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占式调度："><span class="nav-number">21.1.</span> <span class="nav-text">抢占式调度：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协同式调度："><span class="nav-number">21.2.</span> <span class="nav-text">协同式调度：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-的线程调度实现（抢占式调度）"><span class="nav-number">21.3.</span> <span class="nav-text">JVM 的线程调度实现（抢占式调度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程让出cpu-的情况："><span class="nav-number">21.4.</span> <span class="nav-text">线程让出cpu 的情况：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度算法"><span class="nav-number">22.</span> <span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优先调度算法"><span class="nav-number">22.1.</span> <span class="nav-text">优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高优先权优先调度算法"><span class="nav-number">22.2.</span> <span class="nav-text">高优先权优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于时间片的轮转调度算法"><span class="nav-number">22.3.</span> <span class="nav-text">基于时间片的轮转调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是CAS-乐观锁-自旋锁-比较并交换-compare-and-swap"><span class="nav-number">23.</span> <span class="nav-text">什么是CAS(乐观锁-自旋锁-比较并交换 compare and swap)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念及特性"><span class="nav-number">23.1.</span> <span class="nav-text">概念及特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子包-java-util-concurrent-atomic（锁自旋）"><span class="nav-number">23.2.</span> <span class="nav-text">原子包 java.util.concurrent.atomic（锁自旋）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA-问题"><span class="nav-number">23.3.</span> <span class="nav-text">ABA 问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是AQS-抽象的队列同步器AbstractQueuedSynchronizer"><span class="nav-number">24.</span> <span class="nav-text">什么是AQS(抽象的队列同步器AbstractQueuedSynchronizer)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-定义两种资源共享方式"><span class="nav-number">24.1.</span> <span class="nav-text">AQS 定义两种资源共享方式</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shado Fung</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">239k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">6:38</span>
  
</div>









        




  <script>
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66183427";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>





        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; 
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>
